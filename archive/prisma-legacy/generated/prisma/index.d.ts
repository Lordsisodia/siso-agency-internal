
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model LightWorkTask
 * 
 */
export type LightWorkTask = $Result.DefaultSelection<Prisma.$LightWorkTaskPayload>
/**
 * Model LightWorkSubtask
 * 
 */
export type LightWorkSubtask = $Result.DefaultSelection<Prisma.$LightWorkSubtaskPayload>
/**
 * Model DeepWorkTask
 * 
 */
export type DeepWorkTask = $Result.DefaultSelection<Prisma.$DeepWorkTaskPayload>
/**
 * Model DeepWorkSubtask
 * 
 */
export type DeepWorkSubtask = $Result.DefaultSelection<Prisma.$DeepWorkSubtaskPayload>
/**
 * Model AutomationTask
 * 
 */
export type AutomationTask = $Result.DefaultSelection<Prisma.$AutomationTaskPayload>
/**
 * Model DailyHabits
 * 
 */
export type DailyHabits = $Result.DefaultSelection<Prisma.$DailyHabitsPayload>
/**
 * Model DailyHealth
 * 
 */
export type DailyHealth = $Result.DefaultSelection<Prisma.$DailyHealthPayload>
/**
 * Model DailyWorkout
 * 
 */
export type DailyWorkout = $Result.DefaultSelection<Prisma.$DailyWorkoutPayload>
/**
 * Model DailyRoutine
 * 
 */
export type DailyRoutine = $Result.DefaultSelection<Prisma.$DailyRoutinePayload>
/**
 * Model DailyReflections
 * 
 */
export type DailyReflections = $Result.DefaultSelection<Prisma.$DailyReflectionsPayload>
/**
 * Model TimeBlock
 * 
 */
export type TimeBlock = $Result.DefaultSelection<Prisma.$TimeBlockPayload>
/**
 * Model PersonalContext
 * 
 */
export type PersonalContext = $Result.DefaultSelection<Prisma.$PersonalContextPayload>
/**
 * Model UserProgress
 * 
 */
export type UserProgress = $Result.DefaultSelection<Prisma.$UserProgressPayload>
/**
 * Model Achievement
 * 
 */
export type Achievement = $Result.DefaultSelection<Prisma.$AchievementPayload>
/**
 * Model DailyStats
 * 
 */
export type DailyStats = $Result.DefaultSelection<Prisma.$DailyStatsPayload>
/**
 * Model XPBalance
 * 
 */
export type XPBalance = $Result.DefaultSelection<Prisma.$XPBalancePayload>
/**
 * Model XPPurchase
 * 
 */
export type XPPurchase = $Result.DefaultSelection<Prisma.$XPPurchasePayload>
/**
 * Model XPEarningLog
 * 
 */
export type XPEarningLog = $Result.DefaultSelection<Prisma.$XPEarningLogPayload>
/**
 * Model RewardDefinition
 * 
 */
export type RewardDefinition = $Result.DefaultSelection<Prisma.$RewardDefinitionPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  ADMIN: 'ADMIN',
  USER: 'USER',
  TEAM_MEMBER: 'TEAM_MEMBER'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const Priority: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  URGENT: 'URGENT'
};

export type Priority = (typeof Priority)[keyof typeof Priority]


export const TaskDifficulty: {
  TRIVIAL: 'TRIVIAL',
  EASY: 'EASY',
  MODERATE: 'MODERATE',
  HARD: 'HARD',
  EXPERT: 'EXPERT'
};

export type TaskDifficulty = (typeof TaskDifficulty)[keyof typeof TaskDifficulty]


export const AchievementCategory: {
  STREAK: 'STREAK',
  POINTS: 'POINTS',
  COMPLETION: 'COMPLETION',
  CONSISTENCY: 'CONSISTENCY'
};

export type AchievementCategory = (typeof AchievementCategory)[keyof typeof AchievementCategory]


export const AutomationCategory: {
  DEVELOPMENT: 'DEVELOPMENT',
  TESTING: 'TESTING',
  DEPLOYMENT: 'DEPLOYMENT',
  ANALYSIS: 'ANALYSIS',
  MAINTENANCE: 'MAINTENANCE'
};

export type AutomationCategory = (typeof AutomationCategory)[keyof typeof AutomationCategory]


export const AutomationStatus: {
  PENDING: 'PENDING',
  RUNNING: 'RUNNING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  PAUSED: 'PAUSED'
};

export type AutomationStatus = (typeof AutomationStatus)[keyof typeof AutomationStatus]


export const RoutineType: {
  MORNING: 'MORNING',
  EVENING: 'EVENING'
};

export type RoutineType = (typeof RoutineType)[keyof typeof RoutineType]


export const TimeBlockCategory: {
  DEEP_WORK: 'DEEP_WORK',
  LIGHT_WORK: 'LIGHT_WORK',
  MEETING: 'MEETING',
  BREAK: 'BREAK',
  PERSONAL: 'PERSONAL',
  HEALTH: 'HEALTH',
  LEARNING: 'LEARNING',
  ADMIN: 'ADMIN'
};

export type TimeBlockCategory = (typeof TimeBlockCategory)[keyof typeof TimeBlockCategory]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type Priority = $Enums.Priority

export const Priority: typeof $Enums.Priority

export type TaskDifficulty = $Enums.TaskDifficulty

export const TaskDifficulty: typeof $Enums.TaskDifficulty

export type AchievementCategory = $Enums.AchievementCategory

export const AchievementCategory: typeof $Enums.AchievementCategory

export type AutomationCategory = $Enums.AutomationCategory

export const AutomationCategory: typeof $Enums.AutomationCategory

export type AutomationStatus = $Enums.AutomationStatus

export const AutomationStatus: typeof $Enums.AutomationStatus

export type RoutineType = $Enums.RoutineType

export const RoutineType: typeof $Enums.RoutineType

export type TimeBlockCategory = $Enums.TimeBlockCategory

export const TimeBlockCategory: typeof $Enums.TimeBlockCategory

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lightWorkTask`: Exposes CRUD operations for the **LightWorkTask** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LightWorkTasks
    * const lightWorkTasks = await prisma.lightWorkTask.findMany()
    * ```
    */
  get lightWorkTask(): Prisma.LightWorkTaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lightWorkSubtask`: Exposes CRUD operations for the **LightWorkSubtask** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LightWorkSubtasks
    * const lightWorkSubtasks = await prisma.lightWorkSubtask.findMany()
    * ```
    */
  get lightWorkSubtask(): Prisma.LightWorkSubtaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deepWorkTask`: Exposes CRUD operations for the **DeepWorkTask** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeepWorkTasks
    * const deepWorkTasks = await prisma.deepWorkTask.findMany()
    * ```
    */
  get deepWorkTask(): Prisma.DeepWorkTaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deepWorkSubtask`: Exposes CRUD operations for the **DeepWorkSubtask** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeepWorkSubtasks
    * const deepWorkSubtasks = await prisma.deepWorkSubtask.findMany()
    * ```
    */
  get deepWorkSubtask(): Prisma.DeepWorkSubtaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.automationTask`: Exposes CRUD operations for the **AutomationTask** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AutomationTasks
    * const automationTasks = await prisma.automationTask.findMany()
    * ```
    */
  get automationTask(): Prisma.AutomationTaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dailyHabits`: Exposes CRUD operations for the **DailyHabits** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DailyHabits
    * const dailyHabits = await prisma.dailyHabits.findMany()
    * ```
    */
  get dailyHabits(): Prisma.DailyHabitsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dailyHealth`: Exposes CRUD operations for the **DailyHealth** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DailyHealths
    * const dailyHealths = await prisma.dailyHealth.findMany()
    * ```
    */
  get dailyHealth(): Prisma.DailyHealthDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dailyWorkout`: Exposes CRUD operations for the **DailyWorkout** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DailyWorkouts
    * const dailyWorkouts = await prisma.dailyWorkout.findMany()
    * ```
    */
  get dailyWorkout(): Prisma.DailyWorkoutDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dailyRoutine`: Exposes CRUD operations for the **DailyRoutine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DailyRoutines
    * const dailyRoutines = await prisma.dailyRoutine.findMany()
    * ```
    */
  get dailyRoutine(): Prisma.DailyRoutineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dailyReflections`: Exposes CRUD operations for the **DailyReflections** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DailyReflections
    * const dailyReflections = await prisma.dailyReflections.findMany()
    * ```
    */
  get dailyReflections(): Prisma.DailyReflectionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.timeBlock`: Exposes CRUD operations for the **TimeBlock** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TimeBlocks
    * const timeBlocks = await prisma.timeBlock.findMany()
    * ```
    */
  get timeBlock(): Prisma.TimeBlockDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.personalContext`: Exposes CRUD operations for the **PersonalContext** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PersonalContexts
    * const personalContexts = await prisma.personalContext.findMany()
    * ```
    */
  get personalContext(): Prisma.PersonalContextDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userProgress`: Exposes CRUD operations for the **UserProgress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserProgresses
    * const userProgresses = await prisma.userProgress.findMany()
    * ```
    */
  get userProgress(): Prisma.UserProgressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.achievement`: Exposes CRUD operations for the **Achievement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Achievements
    * const achievements = await prisma.achievement.findMany()
    * ```
    */
  get achievement(): Prisma.AchievementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dailyStats`: Exposes CRUD operations for the **DailyStats** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DailyStats
    * const dailyStats = await prisma.dailyStats.findMany()
    * ```
    */
  get dailyStats(): Prisma.DailyStatsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.xPBalance`: Exposes CRUD operations for the **XPBalance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more XPBalances
    * const xPBalances = await prisma.xPBalance.findMany()
    * ```
    */
  get xPBalance(): Prisma.XPBalanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.xPPurchase`: Exposes CRUD operations for the **XPPurchase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more XPPurchases
    * const xPPurchases = await prisma.xPPurchase.findMany()
    * ```
    */
  get xPPurchase(): Prisma.XPPurchaseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.xPEarningLog`: Exposes CRUD operations for the **XPEarningLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more XPEarningLogs
    * const xPEarningLogs = await prisma.xPEarningLog.findMany()
    * ```
    */
  get xPEarningLog(): Prisma.XPEarningLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rewardDefinition`: Exposes CRUD operations for the **RewardDefinition** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RewardDefinitions
    * const rewardDefinitions = await prisma.rewardDefinition.findMany()
    * ```
    */
  get rewardDefinition(): Prisma.RewardDefinitionDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.14.0
   * Query Engine version: 717184b7b35ea05dfa71a3236b7af656013e1e49
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    LightWorkTask: 'LightWorkTask',
    LightWorkSubtask: 'LightWorkSubtask',
    DeepWorkTask: 'DeepWorkTask',
    DeepWorkSubtask: 'DeepWorkSubtask',
    AutomationTask: 'AutomationTask',
    DailyHabits: 'DailyHabits',
    DailyHealth: 'DailyHealth',
    DailyWorkout: 'DailyWorkout',
    DailyRoutine: 'DailyRoutine',
    DailyReflections: 'DailyReflections',
    TimeBlock: 'TimeBlock',
    PersonalContext: 'PersonalContext',
    UserProgress: 'UserProgress',
    Achievement: 'Achievement',
    DailyStats: 'DailyStats',
    XPBalance: 'XPBalance',
    XPPurchase: 'XPPurchase',
    XPEarningLog: 'XPEarningLog',
    RewardDefinition: 'RewardDefinition'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "lightWorkTask" | "lightWorkSubtask" | "deepWorkTask" | "deepWorkSubtask" | "automationTask" | "dailyHabits" | "dailyHealth" | "dailyWorkout" | "dailyRoutine" | "dailyReflections" | "timeBlock" | "personalContext" | "userProgress" | "achievement" | "dailyStats" | "xPBalance" | "xPPurchase" | "xPEarningLog" | "rewardDefinition"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      LightWorkTask: {
        payload: Prisma.$LightWorkTaskPayload<ExtArgs>
        fields: Prisma.LightWorkTaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LightWorkTaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LightWorkTaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LightWorkTaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LightWorkTaskPayload>
          }
          findFirst: {
            args: Prisma.LightWorkTaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LightWorkTaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LightWorkTaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LightWorkTaskPayload>
          }
          findMany: {
            args: Prisma.LightWorkTaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LightWorkTaskPayload>[]
          }
          create: {
            args: Prisma.LightWorkTaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LightWorkTaskPayload>
          }
          createMany: {
            args: Prisma.LightWorkTaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LightWorkTaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LightWorkTaskPayload>[]
          }
          delete: {
            args: Prisma.LightWorkTaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LightWorkTaskPayload>
          }
          update: {
            args: Prisma.LightWorkTaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LightWorkTaskPayload>
          }
          deleteMany: {
            args: Prisma.LightWorkTaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LightWorkTaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LightWorkTaskUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LightWorkTaskPayload>[]
          }
          upsert: {
            args: Prisma.LightWorkTaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LightWorkTaskPayload>
          }
          aggregate: {
            args: Prisma.LightWorkTaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLightWorkTask>
          }
          groupBy: {
            args: Prisma.LightWorkTaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<LightWorkTaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.LightWorkTaskCountArgs<ExtArgs>
            result: $Utils.Optional<LightWorkTaskCountAggregateOutputType> | number
          }
        }
      }
      LightWorkSubtask: {
        payload: Prisma.$LightWorkSubtaskPayload<ExtArgs>
        fields: Prisma.LightWorkSubtaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LightWorkSubtaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LightWorkSubtaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LightWorkSubtaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LightWorkSubtaskPayload>
          }
          findFirst: {
            args: Prisma.LightWorkSubtaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LightWorkSubtaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LightWorkSubtaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LightWorkSubtaskPayload>
          }
          findMany: {
            args: Prisma.LightWorkSubtaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LightWorkSubtaskPayload>[]
          }
          create: {
            args: Prisma.LightWorkSubtaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LightWorkSubtaskPayload>
          }
          createMany: {
            args: Prisma.LightWorkSubtaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LightWorkSubtaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LightWorkSubtaskPayload>[]
          }
          delete: {
            args: Prisma.LightWorkSubtaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LightWorkSubtaskPayload>
          }
          update: {
            args: Prisma.LightWorkSubtaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LightWorkSubtaskPayload>
          }
          deleteMany: {
            args: Prisma.LightWorkSubtaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LightWorkSubtaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LightWorkSubtaskUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LightWorkSubtaskPayload>[]
          }
          upsert: {
            args: Prisma.LightWorkSubtaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LightWorkSubtaskPayload>
          }
          aggregate: {
            args: Prisma.LightWorkSubtaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLightWorkSubtask>
          }
          groupBy: {
            args: Prisma.LightWorkSubtaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<LightWorkSubtaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.LightWorkSubtaskCountArgs<ExtArgs>
            result: $Utils.Optional<LightWorkSubtaskCountAggregateOutputType> | number
          }
        }
      }
      DeepWorkTask: {
        payload: Prisma.$DeepWorkTaskPayload<ExtArgs>
        fields: Prisma.DeepWorkTaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeepWorkTaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeepWorkTaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeepWorkTaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeepWorkTaskPayload>
          }
          findFirst: {
            args: Prisma.DeepWorkTaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeepWorkTaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeepWorkTaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeepWorkTaskPayload>
          }
          findMany: {
            args: Prisma.DeepWorkTaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeepWorkTaskPayload>[]
          }
          create: {
            args: Prisma.DeepWorkTaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeepWorkTaskPayload>
          }
          createMany: {
            args: Prisma.DeepWorkTaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeepWorkTaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeepWorkTaskPayload>[]
          }
          delete: {
            args: Prisma.DeepWorkTaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeepWorkTaskPayload>
          }
          update: {
            args: Prisma.DeepWorkTaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeepWorkTaskPayload>
          }
          deleteMany: {
            args: Prisma.DeepWorkTaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeepWorkTaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeepWorkTaskUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeepWorkTaskPayload>[]
          }
          upsert: {
            args: Prisma.DeepWorkTaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeepWorkTaskPayload>
          }
          aggregate: {
            args: Prisma.DeepWorkTaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeepWorkTask>
          }
          groupBy: {
            args: Prisma.DeepWorkTaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeepWorkTaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeepWorkTaskCountArgs<ExtArgs>
            result: $Utils.Optional<DeepWorkTaskCountAggregateOutputType> | number
          }
        }
      }
      DeepWorkSubtask: {
        payload: Prisma.$DeepWorkSubtaskPayload<ExtArgs>
        fields: Prisma.DeepWorkSubtaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeepWorkSubtaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeepWorkSubtaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeepWorkSubtaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeepWorkSubtaskPayload>
          }
          findFirst: {
            args: Prisma.DeepWorkSubtaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeepWorkSubtaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeepWorkSubtaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeepWorkSubtaskPayload>
          }
          findMany: {
            args: Prisma.DeepWorkSubtaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeepWorkSubtaskPayload>[]
          }
          create: {
            args: Prisma.DeepWorkSubtaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeepWorkSubtaskPayload>
          }
          createMany: {
            args: Prisma.DeepWorkSubtaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeepWorkSubtaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeepWorkSubtaskPayload>[]
          }
          delete: {
            args: Prisma.DeepWorkSubtaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeepWorkSubtaskPayload>
          }
          update: {
            args: Prisma.DeepWorkSubtaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeepWorkSubtaskPayload>
          }
          deleteMany: {
            args: Prisma.DeepWorkSubtaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeepWorkSubtaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeepWorkSubtaskUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeepWorkSubtaskPayload>[]
          }
          upsert: {
            args: Prisma.DeepWorkSubtaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeepWorkSubtaskPayload>
          }
          aggregate: {
            args: Prisma.DeepWorkSubtaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeepWorkSubtask>
          }
          groupBy: {
            args: Prisma.DeepWorkSubtaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeepWorkSubtaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeepWorkSubtaskCountArgs<ExtArgs>
            result: $Utils.Optional<DeepWorkSubtaskCountAggregateOutputType> | number
          }
        }
      }
      AutomationTask: {
        payload: Prisma.$AutomationTaskPayload<ExtArgs>
        fields: Prisma.AutomationTaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AutomationTaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationTaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AutomationTaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationTaskPayload>
          }
          findFirst: {
            args: Prisma.AutomationTaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationTaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AutomationTaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationTaskPayload>
          }
          findMany: {
            args: Prisma.AutomationTaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationTaskPayload>[]
          }
          create: {
            args: Prisma.AutomationTaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationTaskPayload>
          }
          createMany: {
            args: Prisma.AutomationTaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AutomationTaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationTaskPayload>[]
          }
          delete: {
            args: Prisma.AutomationTaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationTaskPayload>
          }
          update: {
            args: Prisma.AutomationTaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationTaskPayload>
          }
          deleteMany: {
            args: Prisma.AutomationTaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AutomationTaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AutomationTaskUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationTaskPayload>[]
          }
          upsert: {
            args: Prisma.AutomationTaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationTaskPayload>
          }
          aggregate: {
            args: Prisma.AutomationTaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAutomationTask>
          }
          groupBy: {
            args: Prisma.AutomationTaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<AutomationTaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.AutomationTaskCountArgs<ExtArgs>
            result: $Utils.Optional<AutomationTaskCountAggregateOutputType> | number
          }
        }
      }
      DailyHabits: {
        payload: Prisma.$DailyHabitsPayload<ExtArgs>
        fields: Prisma.DailyHabitsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DailyHabitsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyHabitsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DailyHabitsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyHabitsPayload>
          }
          findFirst: {
            args: Prisma.DailyHabitsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyHabitsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DailyHabitsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyHabitsPayload>
          }
          findMany: {
            args: Prisma.DailyHabitsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyHabitsPayload>[]
          }
          create: {
            args: Prisma.DailyHabitsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyHabitsPayload>
          }
          createMany: {
            args: Prisma.DailyHabitsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DailyHabitsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyHabitsPayload>[]
          }
          delete: {
            args: Prisma.DailyHabitsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyHabitsPayload>
          }
          update: {
            args: Prisma.DailyHabitsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyHabitsPayload>
          }
          deleteMany: {
            args: Prisma.DailyHabitsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DailyHabitsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DailyHabitsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyHabitsPayload>[]
          }
          upsert: {
            args: Prisma.DailyHabitsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyHabitsPayload>
          }
          aggregate: {
            args: Prisma.DailyHabitsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDailyHabits>
          }
          groupBy: {
            args: Prisma.DailyHabitsGroupByArgs<ExtArgs>
            result: $Utils.Optional<DailyHabitsGroupByOutputType>[]
          }
          count: {
            args: Prisma.DailyHabitsCountArgs<ExtArgs>
            result: $Utils.Optional<DailyHabitsCountAggregateOutputType> | number
          }
        }
      }
      DailyHealth: {
        payload: Prisma.$DailyHealthPayload<ExtArgs>
        fields: Prisma.DailyHealthFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DailyHealthFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyHealthPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DailyHealthFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyHealthPayload>
          }
          findFirst: {
            args: Prisma.DailyHealthFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyHealthPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DailyHealthFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyHealthPayload>
          }
          findMany: {
            args: Prisma.DailyHealthFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyHealthPayload>[]
          }
          create: {
            args: Prisma.DailyHealthCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyHealthPayload>
          }
          createMany: {
            args: Prisma.DailyHealthCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DailyHealthCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyHealthPayload>[]
          }
          delete: {
            args: Prisma.DailyHealthDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyHealthPayload>
          }
          update: {
            args: Prisma.DailyHealthUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyHealthPayload>
          }
          deleteMany: {
            args: Prisma.DailyHealthDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DailyHealthUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DailyHealthUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyHealthPayload>[]
          }
          upsert: {
            args: Prisma.DailyHealthUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyHealthPayload>
          }
          aggregate: {
            args: Prisma.DailyHealthAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDailyHealth>
          }
          groupBy: {
            args: Prisma.DailyHealthGroupByArgs<ExtArgs>
            result: $Utils.Optional<DailyHealthGroupByOutputType>[]
          }
          count: {
            args: Prisma.DailyHealthCountArgs<ExtArgs>
            result: $Utils.Optional<DailyHealthCountAggregateOutputType> | number
          }
        }
      }
      DailyWorkout: {
        payload: Prisma.$DailyWorkoutPayload<ExtArgs>
        fields: Prisma.DailyWorkoutFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DailyWorkoutFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyWorkoutPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DailyWorkoutFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyWorkoutPayload>
          }
          findFirst: {
            args: Prisma.DailyWorkoutFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyWorkoutPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DailyWorkoutFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyWorkoutPayload>
          }
          findMany: {
            args: Prisma.DailyWorkoutFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyWorkoutPayload>[]
          }
          create: {
            args: Prisma.DailyWorkoutCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyWorkoutPayload>
          }
          createMany: {
            args: Prisma.DailyWorkoutCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DailyWorkoutCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyWorkoutPayload>[]
          }
          delete: {
            args: Prisma.DailyWorkoutDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyWorkoutPayload>
          }
          update: {
            args: Prisma.DailyWorkoutUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyWorkoutPayload>
          }
          deleteMany: {
            args: Prisma.DailyWorkoutDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DailyWorkoutUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DailyWorkoutUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyWorkoutPayload>[]
          }
          upsert: {
            args: Prisma.DailyWorkoutUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyWorkoutPayload>
          }
          aggregate: {
            args: Prisma.DailyWorkoutAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDailyWorkout>
          }
          groupBy: {
            args: Prisma.DailyWorkoutGroupByArgs<ExtArgs>
            result: $Utils.Optional<DailyWorkoutGroupByOutputType>[]
          }
          count: {
            args: Prisma.DailyWorkoutCountArgs<ExtArgs>
            result: $Utils.Optional<DailyWorkoutCountAggregateOutputType> | number
          }
        }
      }
      DailyRoutine: {
        payload: Prisma.$DailyRoutinePayload<ExtArgs>
        fields: Prisma.DailyRoutineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DailyRoutineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRoutinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DailyRoutineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRoutinePayload>
          }
          findFirst: {
            args: Prisma.DailyRoutineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRoutinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DailyRoutineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRoutinePayload>
          }
          findMany: {
            args: Prisma.DailyRoutineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRoutinePayload>[]
          }
          create: {
            args: Prisma.DailyRoutineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRoutinePayload>
          }
          createMany: {
            args: Prisma.DailyRoutineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DailyRoutineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRoutinePayload>[]
          }
          delete: {
            args: Prisma.DailyRoutineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRoutinePayload>
          }
          update: {
            args: Prisma.DailyRoutineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRoutinePayload>
          }
          deleteMany: {
            args: Prisma.DailyRoutineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DailyRoutineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DailyRoutineUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRoutinePayload>[]
          }
          upsert: {
            args: Prisma.DailyRoutineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRoutinePayload>
          }
          aggregate: {
            args: Prisma.DailyRoutineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDailyRoutine>
          }
          groupBy: {
            args: Prisma.DailyRoutineGroupByArgs<ExtArgs>
            result: $Utils.Optional<DailyRoutineGroupByOutputType>[]
          }
          count: {
            args: Prisma.DailyRoutineCountArgs<ExtArgs>
            result: $Utils.Optional<DailyRoutineCountAggregateOutputType> | number
          }
        }
      }
      DailyReflections: {
        payload: Prisma.$DailyReflectionsPayload<ExtArgs>
        fields: Prisma.DailyReflectionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DailyReflectionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyReflectionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DailyReflectionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyReflectionsPayload>
          }
          findFirst: {
            args: Prisma.DailyReflectionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyReflectionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DailyReflectionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyReflectionsPayload>
          }
          findMany: {
            args: Prisma.DailyReflectionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyReflectionsPayload>[]
          }
          create: {
            args: Prisma.DailyReflectionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyReflectionsPayload>
          }
          createMany: {
            args: Prisma.DailyReflectionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DailyReflectionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyReflectionsPayload>[]
          }
          delete: {
            args: Prisma.DailyReflectionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyReflectionsPayload>
          }
          update: {
            args: Prisma.DailyReflectionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyReflectionsPayload>
          }
          deleteMany: {
            args: Prisma.DailyReflectionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DailyReflectionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DailyReflectionsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyReflectionsPayload>[]
          }
          upsert: {
            args: Prisma.DailyReflectionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyReflectionsPayload>
          }
          aggregate: {
            args: Prisma.DailyReflectionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDailyReflections>
          }
          groupBy: {
            args: Prisma.DailyReflectionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<DailyReflectionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.DailyReflectionsCountArgs<ExtArgs>
            result: $Utils.Optional<DailyReflectionsCountAggregateOutputType> | number
          }
        }
      }
      TimeBlock: {
        payload: Prisma.$TimeBlockPayload<ExtArgs>
        fields: Prisma.TimeBlockFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TimeBlockFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeBlockPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TimeBlockFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeBlockPayload>
          }
          findFirst: {
            args: Prisma.TimeBlockFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeBlockPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TimeBlockFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeBlockPayload>
          }
          findMany: {
            args: Prisma.TimeBlockFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeBlockPayload>[]
          }
          create: {
            args: Prisma.TimeBlockCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeBlockPayload>
          }
          createMany: {
            args: Prisma.TimeBlockCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TimeBlockCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeBlockPayload>[]
          }
          delete: {
            args: Prisma.TimeBlockDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeBlockPayload>
          }
          update: {
            args: Prisma.TimeBlockUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeBlockPayload>
          }
          deleteMany: {
            args: Prisma.TimeBlockDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TimeBlockUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TimeBlockUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeBlockPayload>[]
          }
          upsert: {
            args: Prisma.TimeBlockUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeBlockPayload>
          }
          aggregate: {
            args: Prisma.TimeBlockAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTimeBlock>
          }
          groupBy: {
            args: Prisma.TimeBlockGroupByArgs<ExtArgs>
            result: $Utils.Optional<TimeBlockGroupByOutputType>[]
          }
          count: {
            args: Prisma.TimeBlockCountArgs<ExtArgs>
            result: $Utils.Optional<TimeBlockCountAggregateOutputType> | number
          }
        }
      }
      PersonalContext: {
        payload: Prisma.$PersonalContextPayload<ExtArgs>
        fields: Prisma.PersonalContextFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PersonalContextFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalContextPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PersonalContextFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalContextPayload>
          }
          findFirst: {
            args: Prisma.PersonalContextFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalContextPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PersonalContextFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalContextPayload>
          }
          findMany: {
            args: Prisma.PersonalContextFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalContextPayload>[]
          }
          create: {
            args: Prisma.PersonalContextCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalContextPayload>
          }
          createMany: {
            args: Prisma.PersonalContextCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PersonalContextCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalContextPayload>[]
          }
          delete: {
            args: Prisma.PersonalContextDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalContextPayload>
          }
          update: {
            args: Prisma.PersonalContextUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalContextPayload>
          }
          deleteMany: {
            args: Prisma.PersonalContextDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PersonalContextUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PersonalContextUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalContextPayload>[]
          }
          upsert: {
            args: Prisma.PersonalContextUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalContextPayload>
          }
          aggregate: {
            args: Prisma.PersonalContextAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePersonalContext>
          }
          groupBy: {
            args: Prisma.PersonalContextGroupByArgs<ExtArgs>
            result: $Utils.Optional<PersonalContextGroupByOutputType>[]
          }
          count: {
            args: Prisma.PersonalContextCountArgs<ExtArgs>
            result: $Utils.Optional<PersonalContextCountAggregateOutputType> | number
          }
        }
      }
      UserProgress: {
        payload: Prisma.$UserProgressPayload<ExtArgs>
        fields: Prisma.UserProgressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserProgressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserProgressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>
          }
          findFirst: {
            args: Prisma.UserProgressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserProgressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>
          }
          findMany: {
            args: Prisma.UserProgressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>[]
          }
          create: {
            args: Prisma.UserProgressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>
          }
          createMany: {
            args: Prisma.UserProgressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserProgressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>[]
          }
          delete: {
            args: Prisma.UserProgressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>
          }
          update: {
            args: Prisma.UserProgressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>
          }
          deleteMany: {
            args: Prisma.UserProgressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserProgressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserProgressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>[]
          }
          upsert: {
            args: Prisma.UserProgressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>
          }
          aggregate: {
            args: Prisma.UserProgressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserProgress>
          }
          groupBy: {
            args: Prisma.UserProgressGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserProgressGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserProgressCountArgs<ExtArgs>
            result: $Utils.Optional<UserProgressCountAggregateOutputType> | number
          }
        }
      }
      Achievement: {
        payload: Prisma.$AchievementPayload<ExtArgs>
        fields: Prisma.AchievementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AchievementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AchievementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          findFirst: {
            args: Prisma.AchievementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AchievementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          findMany: {
            args: Prisma.AchievementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>[]
          }
          create: {
            args: Prisma.AchievementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          createMany: {
            args: Prisma.AchievementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AchievementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>[]
          }
          delete: {
            args: Prisma.AchievementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          update: {
            args: Prisma.AchievementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          deleteMany: {
            args: Prisma.AchievementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AchievementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AchievementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>[]
          }
          upsert: {
            args: Prisma.AchievementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          aggregate: {
            args: Prisma.AchievementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAchievement>
          }
          groupBy: {
            args: Prisma.AchievementGroupByArgs<ExtArgs>
            result: $Utils.Optional<AchievementGroupByOutputType>[]
          }
          count: {
            args: Prisma.AchievementCountArgs<ExtArgs>
            result: $Utils.Optional<AchievementCountAggregateOutputType> | number
          }
        }
      }
      DailyStats: {
        payload: Prisma.$DailyStatsPayload<ExtArgs>
        fields: Prisma.DailyStatsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DailyStatsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyStatsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DailyStatsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyStatsPayload>
          }
          findFirst: {
            args: Prisma.DailyStatsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyStatsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DailyStatsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyStatsPayload>
          }
          findMany: {
            args: Prisma.DailyStatsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyStatsPayload>[]
          }
          create: {
            args: Prisma.DailyStatsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyStatsPayload>
          }
          createMany: {
            args: Prisma.DailyStatsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DailyStatsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyStatsPayload>[]
          }
          delete: {
            args: Prisma.DailyStatsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyStatsPayload>
          }
          update: {
            args: Prisma.DailyStatsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyStatsPayload>
          }
          deleteMany: {
            args: Prisma.DailyStatsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DailyStatsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DailyStatsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyStatsPayload>[]
          }
          upsert: {
            args: Prisma.DailyStatsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyStatsPayload>
          }
          aggregate: {
            args: Prisma.DailyStatsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDailyStats>
          }
          groupBy: {
            args: Prisma.DailyStatsGroupByArgs<ExtArgs>
            result: $Utils.Optional<DailyStatsGroupByOutputType>[]
          }
          count: {
            args: Prisma.DailyStatsCountArgs<ExtArgs>
            result: $Utils.Optional<DailyStatsCountAggregateOutputType> | number
          }
        }
      }
      XPBalance: {
        payload: Prisma.$XPBalancePayload<ExtArgs>
        fields: Prisma.XPBalanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.XPBalanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XPBalancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.XPBalanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XPBalancePayload>
          }
          findFirst: {
            args: Prisma.XPBalanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XPBalancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.XPBalanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XPBalancePayload>
          }
          findMany: {
            args: Prisma.XPBalanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XPBalancePayload>[]
          }
          create: {
            args: Prisma.XPBalanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XPBalancePayload>
          }
          createMany: {
            args: Prisma.XPBalanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.XPBalanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XPBalancePayload>[]
          }
          delete: {
            args: Prisma.XPBalanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XPBalancePayload>
          }
          update: {
            args: Prisma.XPBalanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XPBalancePayload>
          }
          deleteMany: {
            args: Prisma.XPBalanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.XPBalanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.XPBalanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XPBalancePayload>[]
          }
          upsert: {
            args: Prisma.XPBalanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XPBalancePayload>
          }
          aggregate: {
            args: Prisma.XPBalanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateXPBalance>
          }
          groupBy: {
            args: Prisma.XPBalanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<XPBalanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.XPBalanceCountArgs<ExtArgs>
            result: $Utils.Optional<XPBalanceCountAggregateOutputType> | number
          }
        }
      }
      XPPurchase: {
        payload: Prisma.$XPPurchasePayload<ExtArgs>
        fields: Prisma.XPPurchaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.XPPurchaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XPPurchasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.XPPurchaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XPPurchasePayload>
          }
          findFirst: {
            args: Prisma.XPPurchaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XPPurchasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.XPPurchaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XPPurchasePayload>
          }
          findMany: {
            args: Prisma.XPPurchaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XPPurchasePayload>[]
          }
          create: {
            args: Prisma.XPPurchaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XPPurchasePayload>
          }
          createMany: {
            args: Prisma.XPPurchaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.XPPurchaseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XPPurchasePayload>[]
          }
          delete: {
            args: Prisma.XPPurchaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XPPurchasePayload>
          }
          update: {
            args: Prisma.XPPurchaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XPPurchasePayload>
          }
          deleteMany: {
            args: Prisma.XPPurchaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.XPPurchaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.XPPurchaseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XPPurchasePayload>[]
          }
          upsert: {
            args: Prisma.XPPurchaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XPPurchasePayload>
          }
          aggregate: {
            args: Prisma.XPPurchaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateXPPurchase>
          }
          groupBy: {
            args: Prisma.XPPurchaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<XPPurchaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.XPPurchaseCountArgs<ExtArgs>
            result: $Utils.Optional<XPPurchaseCountAggregateOutputType> | number
          }
        }
      }
      XPEarningLog: {
        payload: Prisma.$XPEarningLogPayload<ExtArgs>
        fields: Prisma.XPEarningLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.XPEarningLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XPEarningLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.XPEarningLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XPEarningLogPayload>
          }
          findFirst: {
            args: Prisma.XPEarningLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XPEarningLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.XPEarningLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XPEarningLogPayload>
          }
          findMany: {
            args: Prisma.XPEarningLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XPEarningLogPayload>[]
          }
          create: {
            args: Prisma.XPEarningLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XPEarningLogPayload>
          }
          createMany: {
            args: Prisma.XPEarningLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.XPEarningLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XPEarningLogPayload>[]
          }
          delete: {
            args: Prisma.XPEarningLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XPEarningLogPayload>
          }
          update: {
            args: Prisma.XPEarningLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XPEarningLogPayload>
          }
          deleteMany: {
            args: Prisma.XPEarningLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.XPEarningLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.XPEarningLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XPEarningLogPayload>[]
          }
          upsert: {
            args: Prisma.XPEarningLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XPEarningLogPayload>
          }
          aggregate: {
            args: Prisma.XPEarningLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateXPEarningLog>
          }
          groupBy: {
            args: Prisma.XPEarningLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<XPEarningLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.XPEarningLogCountArgs<ExtArgs>
            result: $Utils.Optional<XPEarningLogCountAggregateOutputType> | number
          }
        }
      }
      RewardDefinition: {
        payload: Prisma.$RewardDefinitionPayload<ExtArgs>
        fields: Prisma.RewardDefinitionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RewardDefinitionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardDefinitionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RewardDefinitionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardDefinitionPayload>
          }
          findFirst: {
            args: Prisma.RewardDefinitionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardDefinitionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RewardDefinitionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardDefinitionPayload>
          }
          findMany: {
            args: Prisma.RewardDefinitionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardDefinitionPayload>[]
          }
          create: {
            args: Prisma.RewardDefinitionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardDefinitionPayload>
          }
          createMany: {
            args: Prisma.RewardDefinitionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RewardDefinitionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardDefinitionPayload>[]
          }
          delete: {
            args: Prisma.RewardDefinitionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardDefinitionPayload>
          }
          update: {
            args: Prisma.RewardDefinitionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardDefinitionPayload>
          }
          deleteMany: {
            args: Prisma.RewardDefinitionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RewardDefinitionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RewardDefinitionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardDefinitionPayload>[]
          }
          upsert: {
            args: Prisma.RewardDefinitionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardDefinitionPayload>
          }
          aggregate: {
            args: Prisma.RewardDefinitionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRewardDefinition>
          }
          groupBy: {
            args: Prisma.RewardDefinitionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RewardDefinitionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RewardDefinitionCountArgs<ExtArgs>
            result: $Utils.Optional<RewardDefinitionCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    lightWorkTask?: LightWorkTaskOmit
    lightWorkSubtask?: LightWorkSubtaskOmit
    deepWorkTask?: DeepWorkTaskOmit
    deepWorkSubtask?: DeepWorkSubtaskOmit
    automationTask?: AutomationTaskOmit
    dailyHabits?: DailyHabitsOmit
    dailyHealth?: DailyHealthOmit
    dailyWorkout?: DailyWorkoutOmit
    dailyRoutine?: DailyRoutineOmit
    dailyReflections?: DailyReflectionsOmit
    timeBlock?: TimeBlockOmit
    personalContext?: PersonalContextOmit
    userProgress?: UserProgressOmit
    achievement?: AchievementOmit
    dailyStats?: DailyStatsOmit
    xPBalance?: XPBalanceOmit
    xPPurchase?: XPPurchaseOmit
    xPEarningLog?: XPEarningLogOmit
    rewardDefinition?: RewardDefinitionOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    lightWorkTasks: number
    deepWorkTasks: number
    personalContext: number
    automationTasks: number
    dailyHabits: number
    dailyHealth: number
    dailyWorkout: number
    dailyRoutine: number
    dailyReflections: number
    timeBlocks: number
    userProgress: number
    xpBalance: number
    xpPurchases: number
    xpEarningLog: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lightWorkTasks?: boolean | UserCountOutputTypeCountLightWorkTasksArgs
    deepWorkTasks?: boolean | UserCountOutputTypeCountDeepWorkTasksArgs
    personalContext?: boolean | UserCountOutputTypeCountPersonalContextArgs
    automationTasks?: boolean | UserCountOutputTypeCountAutomationTasksArgs
    dailyHabits?: boolean | UserCountOutputTypeCountDailyHabitsArgs
    dailyHealth?: boolean | UserCountOutputTypeCountDailyHealthArgs
    dailyWorkout?: boolean | UserCountOutputTypeCountDailyWorkoutArgs
    dailyRoutine?: boolean | UserCountOutputTypeCountDailyRoutineArgs
    dailyReflections?: boolean | UserCountOutputTypeCountDailyReflectionsArgs
    timeBlocks?: boolean | UserCountOutputTypeCountTimeBlocksArgs
    userProgress?: boolean | UserCountOutputTypeCountUserProgressArgs
    xpBalance?: boolean | UserCountOutputTypeCountXpBalanceArgs
    xpPurchases?: boolean | UserCountOutputTypeCountXpPurchasesArgs
    xpEarningLog?: boolean | UserCountOutputTypeCountXpEarningLogArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLightWorkTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LightWorkTaskWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDeepWorkTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeepWorkTaskWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPersonalContextArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonalContextWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAutomationTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutomationTaskWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDailyHabitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyHabitsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDailyHealthArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyHealthWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDailyWorkoutArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyWorkoutWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDailyRoutineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyRoutineWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDailyReflectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyReflectionsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTimeBlocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimeBlockWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserProgressWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountXpBalanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: XPBalanceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountXpPurchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: XPPurchaseWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountXpEarningLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: XPEarningLogWhereInput
  }


  /**
   * Count Type LightWorkTaskCountOutputType
   */

  export type LightWorkTaskCountOutputType = {
    subtasks: number
  }

  export type LightWorkTaskCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subtasks?: boolean | LightWorkTaskCountOutputTypeCountSubtasksArgs
  }

  // Custom InputTypes
  /**
   * LightWorkTaskCountOutputType without action
   */
  export type LightWorkTaskCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LightWorkTaskCountOutputType
     */
    select?: LightWorkTaskCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LightWorkTaskCountOutputType without action
   */
  export type LightWorkTaskCountOutputTypeCountSubtasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LightWorkSubtaskWhereInput
  }


  /**
   * Count Type DeepWorkTaskCountOutputType
   */

  export type DeepWorkTaskCountOutputType = {
    subtasks: number
  }

  export type DeepWorkTaskCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subtasks?: boolean | DeepWorkTaskCountOutputTypeCountSubtasksArgs
  }

  // Custom InputTypes
  /**
   * DeepWorkTaskCountOutputType without action
   */
  export type DeepWorkTaskCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeepWorkTaskCountOutputType
     */
    select?: DeepWorkTaskCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DeepWorkTaskCountOutputType without action
   */
  export type DeepWorkTaskCountOutputTypeCountSubtasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeepWorkSubtaskWhereInput
  }


  /**
   * Count Type UserProgressCountOutputType
   */

  export type UserProgressCountOutputType = {
    achievements: number
    dailyStats: number
  }

  export type UserProgressCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    achievements?: boolean | UserProgressCountOutputTypeCountAchievementsArgs
    dailyStats?: boolean | UserProgressCountOutputTypeCountDailyStatsArgs
  }

  // Custom InputTypes
  /**
   * UserProgressCountOutputType without action
   */
  export type UserProgressCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgressCountOutputType
     */
    select?: UserProgressCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserProgressCountOutputType without action
   */
  export type UserProgressCountOutputTypeCountAchievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AchievementWhereInput
  }

  /**
   * UserProgressCountOutputType without action
   */
  export type UserProgressCountOutputTypeCountDailyStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyStatsWhereInput
  }


  /**
   * Count Type RewardDefinitionCountOutputType
   */

  export type RewardDefinitionCountOutputType = {
    purchases: number
  }

  export type RewardDefinitionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchases?: boolean | RewardDefinitionCountOutputTypeCountPurchasesArgs
  }

  // Custom InputTypes
  /**
   * RewardDefinitionCountOutputType without action
   */
  export type RewardDefinitionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardDefinitionCountOutputType
     */
    select?: RewardDefinitionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RewardDefinitionCountOutputType without action
   */
  export type RewardDefinitionCountOutputTypeCountPurchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: XPPurchaseWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    supabaseId: string | null
    email: string | null
    displayName: string | null
    role: $Enums.UserRole | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    supabaseId: string | null
    email: string | null
    displayName: string | null
    role: $Enums.UserRole | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    supabaseId: number
    email: number
    displayName: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    supabaseId?: true
    email?: true
    displayName?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    supabaseId?: true
    email?: true
    displayName?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    supabaseId?: true
    email?: true
    displayName?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    supabaseId: string
    email: string
    displayName: string | null
    role: $Enums.UserRole
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supabaseId?: boolean
    email?: boolean
    displayName?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lightWorkTasks?: boolean | User$lightWorkTasksArgs<ExtArgs>
    deepWorkTasks?: boolean | User$deepWorkTasksArgs<ExtArgs>
    personalContext?: boolean | User$personalContextArgs<ExtArgs>
    automationTasks?: boolean | User$automationTasksArgs<ExtArgs>
    dailyHabits?: boolean | User$dailyHabitsArgs<ExtArgs>
    dailyHealth?: boolean | User$dailyHealthArgs<ExtArgs>
    dailyWorkout?: boolean | User$dailyWorkoutArgs<ExtArgs>
    dailyRoutine?: boolean | User$dailyRoutineArgs<ExtArgs>
    dailyReflections?: boolean | User$dailyReflectionsArgs<ExtArgs>
    timeBlocks?: boolean | User$timeBlocksArgs<ExtArgs>
    userProgress?: boolean | User$userProgressArgs<ExtArgs>
    xpBalance?: boolean | User$xpBalanceArgs<ExtArgs>
    xpPurchases?: boolean | User$xpPurchasesArgs<ExtArgs>
    xpEarningLog?: boolean | User$xpEarningLogArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supabaseId?: boolean
    email?: boolean
    displayName?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supabaseId?: boolean
    email?: boolean
    displayName?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    supabaseId?: boolean
    email?: boolean
    displayName?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "supabaseId" | "email" | "displayName" | "role" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lightWorkTasks?: boolean | User$lightWorkTasksArgs<ExtArgs>
    deepWorkTasks?: boolean | User$deepWorkTasksArgs<ExtArgs>
    personalContext?: boolean | User$personalContextArgs<ExtArgs>
    automationTasks?: boolean | User$automationTasksArgs<ExtArgs>
    dailyHabits?: boolean | User$dailyHabitsArgs<ExtArgs>
    dailyHealth?: boolean | User$dailyHealthArgs<ExtArgs>
    dailyWorkout?: boolean | User$dailyWorkoutArgs<ExtArgs>
    dailyRoutine?: boolean | User$dailyRoutineArgs<ExtArgs>
    dailyReflections?: boolean | User$dailyReflectionsArgs<ExtArgs>
    timeBlocks?: boolean | User$timeBlocksArgs<ExtArgs>
    userProgress?: boolean | User$userProgressArgs<ExtArgs>
    xpBalance?: boolean | User$xpBalanceArgs<ExtArgs>
    xpPurchases?: boolean | User$xpPurchasesArgs<ExtArgs>
    xpEarningLog?: boolean | User$xpEarningLogArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      lightWorkTasks: Prisma.$LightWorkTaskPayload<ExtArgs>[]
      deepWorkTasks: Prisma.$DeepWorkTaskPayload<ExtArgs>[]
      personalContext: Prisma.$PersonalContextPayload<ExtArgs>[]
      automationTasks: Prisma.$AutomationTaskPayload<ExtArgs>[]
      dailyHabits: Prisma.$DailyHabitsPayload<ExtArgs>[]
      dailyHealth: Prisma.$DailyHealthPayload<ExtArgs>[]
      dailyWorkout: Prisma.$DailyWorkoutPayload<ExtArgs>[]
      dailyRoutine: Prisma.$DailyRoutinePayload<ExtArgs>[]
      dailyReflections: Prisma.$DailyReflectionsPayload<ExtArgs>[]
      timeBlocks: Prisma.$TimeBlockPayload<ExtArgs>[]
      userProgress: Prisma.$UserProgressPayload<ExtArgs>[]
      xpBalance: Prisma.$XPBalancePayload<ExtArgs>[]
      xpPurchases: Prisma.$XPPurchasePayload<ExtArgs>[]
      xpEarningLog: Prisma.$XPEarningLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      supabaseId: string
      email: string
      displayName: string | null
      role: $Enums.UserRole
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lightWorkTasks<T extends User$lightWorkTasksArgs<ExtArgs> = {}>(args?: Subset<T, User$lightWorkTasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LightWorkTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    deepWorkTasks<T extends User$deepWorkTasksArgs<ExtArgs> = {}>(args?: Subset<T, User$deepWorkTasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeepWorkTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    personalContext<T extends User$personalContextArgs<ExtArgs> = {}>(args?: Subset<T, User$personalContextArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonalContextPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    automationTasks<T extends User$automationTasksArgs<ExtArgs> = {}>(args?: Subset<T, User$automationTasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dailyHabits<T extends User$dailyHabitsArgs<ExtArgs> = {}>(args?: Subset<T, User$dailyHabitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyHabitsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dailyHealth<T extends User$dailyHealthArgs<ExtArgs> = {}>(args?: Subset<T, User$dailyHealthArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyHealthPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dailyWorkout<T extends User$dailyWorkoutArgs<ExtArgs> = {}>(args?: Subset<T, User$dailyWorkoutArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyWorkoutPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dailyRoutine<T extends User$dailyRoutineArgs<ExtArgs> = {}>(args?: Subset<T, User$dailyRoutineArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyRoutinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dailyReflections<T extends User$dailyReflectionsArgs<ExtArgs> = {}>(args?: Subset<T, User$dailyReflectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyReflectionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    timeBlocks<T extends User$timeBlocksArgs<ExtArgs> = {}>(args?: Subset<T, User$timeBlocksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeBlockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userProgress<T extends User$userProgressArgs<ExtArgs> = {}>(args?: Subset<T, User$userProgressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    xpBalance<T extends User$xpBalanceArgs<ExtArgs> = {}>(args?: Subset<T, User$xpBalanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$XPBalancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    xpPurchases<T extends User$xpPurchasesArgs<ExtArgs> = {}>(args?: Subset<T, User$xpPurchasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$XPPurchasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    xpEarningLog<T extends User$xpEarningLogArgs<ExtArgs> = {}>(args?: Subset<T, User$xpEarningLogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$XPEarningLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly supabaseId: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly displayName: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.lightWorkTasks
   */
  export type User$lightWorkTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LightWorkTask
     */
    select?: LightWorkTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LightWorkTask
     */
    omit?: LightWorkTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LightWorkTaskInclude<ExtArgs> | null
    where?: LightWorkTaskWhereInput
    orderBy?: LightWorkTaskOrderByWithRelationInput | LightWorkTaskOrderByWithRelationInput[]
    cursor?: LightWorkTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LightWorkTaskScalarFieldEnum | LightWorkTaskScalarFieldEnum[]
  }

  /**
   * User.deepWorkTasks
   */
  export type User$deepWorkTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeepWorkTask
     */
    select?: DeepWorkTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeepWorkTask
     */
    omit?: DeepWorkTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeepWorkTaskInclude<ExtArgs> | null
    where?: DeepWorkTaskWhereInput
    orderBy?: DeepWorkTaskOrderByWithRelationInput | DeepWorkTaskOrderByWithRelationInput[]
    cursor?: DeepWorkTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeepWorkTaskScalarFieldEnum | DeepWorkTaskScalarFieldEnum[]
  }

  /**
   * User.personalContext
   */
  export type User$personalContextArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalContext
     */
    select?: PersonalContextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalContext
     */
    omit?: PersonalContextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalContextInclude<ExtArgs> | null
    where?: PersonalContextWhereInput
    orderBy?: PersonalContextOrderByWithRelationInput | PersonalContextOrderByWithRelationInput[]
    cursor?: PersonalContextWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersonalContextScalarFieldEnum | PersonalContextScalarFieldEnum[]
  }

  /**
   * User.automationTasks
   */
  export type User$automationTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationTask
     */
    select?: AutomationTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationTask
     */
    omit?: AutomationTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationTaskInclude<ExtArgs> | null
    where?: AutomationTaskWhereInput
    orderBy?: AutomationTaskOrderByWithRelationInput | AutomationTaskOrderByWithRelationInput[]
    cursor?: AutomationTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AutomationTaskScalarFieldEnum | AutomationTaskScalarFieldEnum[]
  }

  /**
   * User.dailyHabits
   */
  export type User$dailyHabitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyHabits
     */
    select?: DailyHabitsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyHabits
     */
    omit?: DailyHabitsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyHabitsInclude<ExtArgs> | null
    where?: DailyHabitsWhereInput
    orderBy?: DailyHabitsOrderByWithRelationInput | DailyHabitsOrderByWithRelationInput[]
    cursor?: DailyHabitsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DailyHabitsScalarFieldEnum | DailyHabitsScalarFieldEnum[]
  }

  /**
   * User.dailyHealth
   */
  export type User$dailyHealthArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyHealth
     */
    select?: DailyHealthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyHealth
     */
    omit?: DailyHealthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyHealthInclude<ExtArgs> | null
    where?: DailyHealthWhereInput
    orderBy?: DailyHealthOrderByWithRelationInput | DailyHealthOrderByWithRelationInput[]
    cursor?: DailyHealthWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DailyHealthScalarFieldEnum | DailyHealthScalarFieldEnum[]
  }

  /**
   * User.dailyWorkout
   */
  export type User$dailyWorkoutArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyWorkout
     */
    select?: DailyWorkoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyWorkout
     */
    omit?: DailyWorkoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyWorkoutInclude<ExtArgs> | null
    where?: DailyWorkoutWhereInput
    orderBy?: DailyWorkoutOrderByWithRelationInput | DailyWorkoutOrderByWithRelationInput[]
    cursor?: DailyWorkoutWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DailyWorkoutScalarFieldEnum | DailyWorkoutScalarFieldEnum[]
  }

  /**
   * User.dailyRoutine
   */
  export type User$dailyRoutineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRoutine
     */
    select?: DailyRoutineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyRoutine
     */
    omit?: DailyRoutineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRoutineInclude<ExtArgs> | null
    where?: DailyRoutineWhereInput
    orderBy?: DailyRoutineOrderByWithRelationInput | DailyRoutineOrderByWithRelationInput[]
    cursor?: DailyRoutineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DailyRoutineScalarFieldEnum | DailyRoutineScalarFieldEnum[]
  }

  /**
   * User.dailyReflections
   */
  export type User$dailyReflectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyReflections
     */
    select?: DailyReflectionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyReflections
     */
    omit?: DailyReflectionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyReflectionsInclude<ExtArgs> | null
    where?: DailyReflectionsWhereInput
    orderBy?: DailyReflectionsOrderByWithRelationInput | DailyReflectionsOrderByWithRelationInput[]
    cursor?: DailyReflectionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DailyReflectionsScalarFieldEnum | DailyReflectionsScalarFieldEnum[]
  }

  /**
   * User.timeBlocks
   */
  export type User$timeBlocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeBlock
     */
    select?: TimeBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeBlock
     */
    omit?: TimeBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeBlockInclude<ExtArgs> | null
    where?: TimeBlockWhereInput
    orderBy?: TimeBlockOrderByWithRelationInput | TimeBlockOrderByWithRelationInput[]
    cursor?: TimeBlockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TimeBlockScalarFieldEnum | TimeBlockScalarFieldEnum[]
  }

  /**
   * User.userProgress
   */
  export type User$userProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    where?: UserProgressWhereInput
    orderBy?: UserProgressOrderByWithRelationInput | UserProgressOrderByWithRelationInput[]
    cursor?: UserProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserProgressScalarFieldEnum | UserProgressScalarFieldEnum[]
  }

  /**
   * User.xpBalance
   */
  export type User$xpBalanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XPBalance
     */
    select?: XPBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XPBalance
     */
    omit?: XPBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XPBalanceInclude<ExtArgs> | null
    where?: XPBalanceWhereInput
    orderBy?: XPBalanceOrderByWithRelationInput | XPBalanceOrderByWithRelationInput[]
    cursor?: XPBalanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: XPBalanceScalarFieldEnum | XPBalanceScalarFieldEnum[]
  }

  /**
   * User.xpPurchases
   */
  export type User$xpPurchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XPPurchase
     */
    select?: XPPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XPPurchase
     */
    omit?: XPPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XPPurchaseInclude<ExtArgs> | null
    where?: XPPurchaseWhereInput
    orderBy?: XPPurchaseOrderByWithRelationInput | XPPurchaseOrderByWithRelationInput[]
    cursor?: XPPurchaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: XPPurchaseScalarFieldEnum | XPPurchaseScalarFieldEnum[]
  }

  /**
   * User.xpEarningLog
   */
  export type User$xpEarningLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XPEarningLog
     */
    select?: XPEarningLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XPEarningLog
     */
    omit?: XPEarningLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XPEarningLogInclude<ExtArgs> | null
    where?: XPEarningLogWhereInput
    orderBy?: XPEarningLogOrderByWithRelationInput | XPEarningLogOrderByWithRelationInput[]
    cursor?: XPEarningLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: XPEarningLogScalarFieldEnum | XPEarningLogScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model LightWorkTask
   */

  export type AggregateLightWorkTask = {
    _count: LightWorkTaskCountAggregateOutputType | null
    _avg: LightWorkTaskAvgAggregateOutputType | null
    _sum: LightWorkTaskSumAggregateOutputType | null
    _min: LightWorkTaskMinAggregateOutputType | null
    _max: LightWorkTaskMaxAggregateOutputType | null
  }

  export type LightWorkTaskAvgAggregateOutputType = {
    estimatedDuration: number | null
    rollovers: number | null
    actualDurationMin: number | null
    xpReward: number | null
    complexity: number | null
    confidence: number | null
    contextualBonus: number | null
    difficulty: number | null
    learningValue: number | null
    priorityRank: number | null
    strategicImportance: number | null
    timeAccuracy: number | null
  }

  export type LightWorkTaskSumAggregateOutputType = {
    estimatedDuration: number | null
    rollovers: number | null
    actualDurationMin: number | null
    xpReward: number | null
    complexity: number | null
    confidence: number | null
    contextualBonus: number | null
    difficulty: number | null
    learningValue: number | null
    priorityRank: number | null
    strategicImportance: number | null
    timeAccuracy: number | null
  }

  export type LightWorkTaskMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    description: string | null
    priority: $Enums.Priority | null
    completed: boolean | null
    originalDate: string | null
    currentDate: string | null
    estimatedDuration: number | null
    rollovers: number | null
    category: string | null
    createdAt: Date | null
    updatedAt: Date | null
    completedAt: Date | null
    startedAt: Date | null
    actualDurationMin: number | null
    timeEstimate: string | null
    aiAnalyzed: boolean | null
    aiReasoning: string | null
    analyzedAt: Date | null
    xpReward: number | null
    complexity: number | null
    confidence: number | null
    contextualBonus: number | null
    difficulty: number | null
    learningValue: number | null
    priorityRank: number | null
    strategicImportance: number | null
    timeAccuracy: number | null
  }

  export type LightWorkTaskMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    description: string | null
    priority: $Enums.Priority | null
    completed: boolean | null
    originalDate: string | null
    currentDate: string | null
    estimatedDuration: number | null
    rollovers: number | null
    category: string | null
    createdAt: Date | null
    updatedAt: Date | null
    completedAt: Date | null
    startedAt: Date | null
    actualDurationMin: number | null
    timeEstimate: string | null
    aiAnalyzed: boolean | null
    aiReasoning: string | null
    analyzedAt: Date | null
    xpReward: number | null
    complexity: number | null
    confidence: number | null
    contextualBonus: number | null
    difficulty: number | null
    learningValue: number | null
    priorityRank: number | null
    strategicImportance: number | null
    timeAccuracy: number | null
  }

  export type LightWorkTaskCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    description: number
    priority: number
    completed: number
    originalDate: number
    currentDate: number
    estimatedDuration: number
    rollovers: number
    tags: number
    category: number
    createdAt: number
    updatedAt: number
    completedAt: number
    startedAt: number
    actualDurationMin: number
    timeEstimate: number
    aiAnalyzed: number
    aiReasoning: number
    analyzedAt: number
    xpReward: number
    complexity: number
    confidence: number
    contextualBonus: number
    difficulty: number
    learningValue: number
    priorityRank: number
    strategicImportance: number
    timeAccuracy: number
    _all: number
  }


  export type LightWorkTaskAvgAggregateInputType = {
    estimatedDuration?: true
    rollovers?: true
    actualDurationMin?: true
    xpReward?: true
    complexity?: true
    confidence?: true
    contextualBonus?: true
    difficulty?: true
    learningValue?: true
    priorityRank?: true
    strategicImportance?: true
    timeAccuracy?: true
  }

  export type LightWorkTaskSumAggregateInputType = {
    estimatedDuration?: true
    rollovers?: true
    actualDurationMin?: true
    xpReward?: true
    complexity?: true
    confidence?: true
    contextualBonus?: true
    difficulty?: true
    learningValue?: true
    priorityRank?: true
    strategicImportance?: true
    timeAccuracy?: true
  }

  export type LightWorkTaskMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    priority?: true
    completed?: true
    originalDate?: true
    currentDate?: true
    estimatedDuration?: true
    rollovers?: true
    category?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
    startedAt?: true
    actualDurationMin?: true
    timeEstimate?: true
    aiAnalyzed?: true
    aiReasoning?: true
    analyzedAt?: true
    xpReward?: true
    complexity?: true
    confidence?: true
    contextualBonus?: true
    difficulty?: true
    learningValue?: true
    priorityRank?: true
    strategicImportance?: true
    timeAccuracy?: true
  }

  export type LightWorkTaskMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    priority?: true
    completed?: true
    originalDate?: true
    currentDate?: true
    estimatedDuration?: true
    rollovers?: true
    category?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
    startedAt?: true
    actualDurationMin?: true
    timeEstimate?: true
    aiAnalyzed?: true
    aiReasoning?: true
    analyzedAt?: true
    xpReward?: true
    complexity?: true
    confidence?: true
    contextualBonus?: true
    difficulty?: true
    learningValue?: true
    priorityRank?: true
    strategicImportance?: true
    timeAccuracy?: true
  }

  export type LightWorkTaskCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    priority?: true
    completed?: true
    originalDate?: true
    currentDate?: true
    estimatedDuration?: true
    rollovers?: true
    tags?: true
    category?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
    startedAt?: true
    actualDurationMin?: true
    timeEstimate?: true
    aiAnalyzed?: true
    aiReasoning?: true
    analyzedAt?: true
    xpReward?: true
    complexity?: true
    confidence?: true
    contextualBonus?: true
    difficulty?: true
    learningValue?: true
    priorityRank?: true
    strategicImportance?: true
    timeAccuracy?: true
    _all?: true
  }

  export type LightWorkTaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LightWorkTask to aggregate.
     */
    where?: LightWorkTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LightWorkTasks to fetch.
     */
    orderBy?: LightWorkTaskOrderByWithRelationInput | LightWorkTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LightWorkTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LightWorkTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LightWorkTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LightWorkTasks
    **/
    _count?: true | LightWorkTaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LightWorkTaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LightWorkTaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LightWorkTaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LightWorkTaskMaxAggregateInputType
  }

  export type GetLightWorkTaskAggregateType<T extends LightWorkTaskAggregateArgs> = {
        [P in keyof T & keyof AggregateLightWorkTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLightWorkTask[P]>
      : GetScalarType<T[P], AggregateLightWorkTask[P]>
  }




  export type LightWorkTaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LightWorkTaskWhereInput
    orderBy?: LightWorkTaskOrderByWithAggregationInput | LightWorkTaskOrderByWithAggregationInput[]
    by: LightWorkTaskScalarFieldEnum[] | LightWorkTaskScalarFieldEnum
    having?: LightWorkTaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LightWorkTaskCountAggregateInputType | true
    _avg?: LightWorkTaskAvgAggregateInputType
    _sum?: LightWorkTaskSumAggregateInputType
    _min?: LightWorkTaskMinAggregateInputType
    _max?: LightWorkTaskMaxAggregateInputType
  }

  export type LightWorkTaskGroupByOutputType = {
    id: string
    userId: string
    title: string
    description: string | null
    priority: $Enums.Priority
    completed: boolean
    originalDate: string
    currentDate: string
    estimatedDuration: number | null
    rollovers: number
    tags: string[]
    category: string | null
    createdAt: Date
    updatedAt: Date
    completedAt: Date | null
    startedAt: Date | null
    actualDurationMin: number | null
    timeEstimate: string | null
    aiAnalyzed: boolean
    aiReasoning: string | null
    analyzedAt: Date | null
    xpReward: number | null
    complexity: number | null
    confidence: number | null
    contextualBonus: number | null
    difficulty: number | null
    learningValue: number | null
    priorityRank: number | null
    strategicImportance: number | null
    timeAccuracy: number | null
    _count: LightWorkTaskCountAggregateOutputType | null
    _avg: LightWorkTaskAvgAggregateOutputType | null
    _sum: LightWorkTaskSumAggregateOutputType | null
    _min: LightWorkTaskMinAggregateOutputType | null
    _max: LightWorkTaskMaxAggregateOutputType | null
  }

  type GetLightWorkTaskGroupByPayload<T extends LightWorkTaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LightWorkTaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LightWorkTaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LightWorkTaskGroupByOutputType[P]>
            : GetScalarType<T[P], LightWorkTaskGroupByOutputType[P]>
        }
      >
    >


  export type LightWorkTaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    priority?: boolean
    completed?: boolean
    originalDate?: boolean
    currentDate?: boolean
    estimatedDuration?: boolean
    rollovers?: boolean
    tags?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    startedAt?: boolean
    actualDurationMin?: boolean
    timeEstimate?: boolean
    aiAnalyzed?: boolean
    aiReasoning?: boolean
    analyzedAt?: boolean
    xpReward?: boolean
    complexity?: boolean
    confidence?: boolean
    contextualBonus?: boolean
    difficulty?: boolean
    learningValue?: boolean
    priorityRank?: boolean
    strategicImportance?: boolean
    timeAccuracy?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    subtasks?: boolean | LightWorkTask$subtasksArgs<ExtArgs>
    _count?: boolean | LightWorkTaskCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lightWorkTask"]>

  export type LightWorkTaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    priority?: boolean
    completed?: boolean
    originalDate?: boolean
    currentDate?: boolean
    estimatedDuration?: boolean
    rollovers?: boolean
    tags?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    startedAt?: boolean
    actualDurationMin?: boolean
    timeEstimate?: boolean
    aiAnalyzed?: boolean
    aiReasoning?: boolean
    analyzedAt?: boolean
    xpReward?: boolean
    complexity?: boolean
    confidence?: boolean
    contextualBonus?: boolean
    difficulty?: boolean
    learningValue?: boolean
    priorityRank?: boolean
    strategicImportance?: boolean
    timeAccuracy?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lightWorkTask"]>

  export type LightWorkTaskSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    priority?: boolean
    completed?: boolean
    originalDate?: boolean
    currentDate?: boolean
    estimatedDuration?: boolean
    rollovers?: boolean
    tags?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    startedAt?: boolean
    actualDurationMin?: boolean
    timeEstimate?: boolean
    aiAnalyzed?: boolean
    aiReasoning?: boolean
    analyzedAt?: boolean
    xpReward?: boolean
    complexity?: boolean
    confidence?: boolean
    contextualBonus?: boolean
    difficulty?: boolean
    learningValue?: boolean
    priorityRank?: boolean
    strategicImportance?: boolean
    timeAccuracy?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lightWorkTask"]>

  export type LightWorkTaskSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    priority?: boolean
    completed?: boolean
    originalDate?: boolean
    currentDate?: boolean
    estimatedDuration?: boolean
    rollovers?: boolean
    tags?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    startedAt?: boolean
    actualDurationMin?: boolean
    timeEstimate?: boolean
    aiAnalyzed?: boolean
    aiReasoning?: boolean
    analyzedAt?: boolean
    xpReward?: boolean
    complexity?: boolean
    confidence?: boolean
    contextualBonus?: boolean
    difficulty?: boolean
    learningValue?: boolean
    priorityRank?: boolean
    strategicImportance?: boolean
    timeAccuracy?: boolean
  }

  export type LightWorkTaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "title" | "description" | "priority" | "completed" | "originalDate" | "currentDate" | "estimatedDuration" | "rollovers" | "tags" | "category" | "createdAt" | "updatedAt" | "completedAt" | "startedAt" | "actualDurationMin" | "timeEstimate" | "aiAnalyzed" | "aiReasoning" | "analyzedAt" | "xpReward" | "complexity" | "confidence" | "contextualBonus" | "difficulty" | "learningValue" | "priorityRank" | "strategicImportance" | "timeAccuracy", ExtArgs["result"]["lightWorkTask"]>
  export type LightWorkTaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    subtasks?: boolean | LightWorkTask$subtasksArgs<ExtArgs>
    _count?: boolean | LightWorkTaskCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LightWorkTaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LightWorkTaskIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LightWorkTaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LightWorkTask"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      subtasks: Prisma.$LightWorkSubtaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      description: string | null
      priority: $Enums.Priority
      completed: boolean
      originalDate: string
      currentDate: string
      estimatedDuration: number | null
      rollovers: number
      tags: string[]
      category: string | null
      createdAt: Date
      updatedAt: Date
      completedAt: Date | null
      startedAt: Date | null
      actualDurationMin: number | null
      timeEstimate: string | null
      aiAnalyzed: boolean
      aiReasoning: string | null
      analyzedAt: Date | null
      xpReward: number | null
      complexity: number | null
      confidence: number | null
      contextualBonus: number | null
      difficulty: number | null
      learningValue: number | null
      priorityRank: number | null
      strategicImportance: number | null
      timeAccuracy: number | null
    }, ExtArgs["result"]["lightWorkTask"]>
    composites: {}
  }

  type LightWorkTaskGetPayload<S extends boolean | null | undefined | LightWorkTaskDefaultArgs> = $Result.GetResult<Prisma.$LightWorkTaskPayload, S>

  type LightWorkTaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LightWorkTaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LightWorkTaskCountAggregateInputType | true
    }

  export interface LightWorkTaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LightWorkTask'], meta: { name: 'LightWorkTask' } }
    /**
     * Find zero or one LightWorkTask that matches the filter.
     * @param {LightWorkTaskFindUniqueArgs} args - Arguments to find a LightWorkTask
     * @example
     * // Get one LightWorkTask
     * const lightWorkTask = await prisma.lightWorkTask.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LightWorkTaskFindUniqueArgs>(args: SelectSubset<T, LightWorkTaskFindUniqueArgs<ExtArgs>>): Prisma__LightWorkTaskClient<$Result.GetResult<Prisma.$LightWorkTaskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LightWorkTask that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LightWorkTaskFindUniqueOrThrowArgs} args - Arguments to find a LightWorkTask
     * @example
     * // Get one LightWorkTask
     * const lightWorkTask = await prisma.lightWorkTask.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LightWorkTaskFindUniqueOrThrowArgs>(args: SelectSubset<T, LightWorkTaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LightWorkTaskClient<$Result.GetResult<Prisma.$LightWorkTaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LightWorkTask that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LightWorkTaskFindFirstArgs} args - Arguments to find a LightWorkTask
     * @example
     * // Get one LightWorkTask
     * const lightWorkTask = await prisma.lightWorkTask.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LightWorkTaskFindFirstArgs>(args?: SelectSubset<T, LightWorkTaskFindFirstArgs<ExtArgs>>): Prisma__LightWorkTaskClient<$Result.GetResult<Prisma.$LightWorkTaskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LightWorkTask that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LightWorkTaskFindFirstOrThrowArgs} args - Arguments to find a LightWorkTask
     * @example
     * // Get one LightWorkTask
     * const lightWorkTask = await prisma.lightWorkTask.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LightWorkTaskFindFirstOrThrowArgs>(args?: SelectSubset<T, LightWorkTaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__LightWorkTaskClient<$Result.GetResult<Prisma.$LightWorkTaskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LightWorkTasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LightWorkTaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LightWorkTasks
     * const lightWorkTasks = await prisma.lightWorkTask.findMany()
     * 
     * // Get first 10 LightWorkTasks
     * const lightWorkTasks = await prisma.lightWorkTask.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lightWorkTaskWithIdOnly = await prisma.lightWorkTask.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LightWorkTaskFindManyArgs>(args?: SelectSubset<T, LightWorkTaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LightWorkTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LightWorkTask.
     * @param {LightWorkTaskCreateArgs} args - Arguments to create a LightWorkTask.
     * @example
     * // Create one LightWorkTask
     * const LightWorkTask = await prisma.lightWorkTask.create({
     *   data: {
     *     // ... data to create a LightWorkTask
     *   }
     * })
     * 
     */
    create<T extends LightWorkTaskCreateArgs>(args: SelectSubset<T, LightWorkTaskCreateArgs<ExtArgs>>): Prisma__LightWorkTaskClient<$Result.GetResult<Prisma.$LightWorkTaskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LightWorkTasks.
     * @param {LightWorkTaskCreateManyArgs} args - Arguments to create many LightWorkTasks.
     * @example
     * // Create many LightWorkTasks
     * const lightWorkTask = await prisma.lightWorkTask.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LightWorkTaskCreateManyArgs>(args?: SelectSubset<T, LightWorkTaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LightWorkTasks and returns the data saved in the database.
     * @param {LightWorkTaskCreateManyAndReturnArgs} args - Arguments to create many LightWorkTasks.
     * @example
     * // Create many LightWorkTasks
     * const lightWorkTask = await prisma.lightWorkTask.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LightWorkTasks and only return the `id`
     * const lightWorkTaskWithIdOnly = await prisma.lightWorkTask.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LightWorkTaskCreateManyAndReturnArgs>(args?: SelectSubset<T, LightWorkTaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LightWorkTaskPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LightWorkTask.
     * @param {LightWorkTaskDeleteArgs} args - Arguments to delete one LightWorkTask.
     * @example
     * // Delete one LightWorkTask
     * const LightWorkTask = await prisma.lightWorkTask.delete({
     *   where: {
     *     // ... filter to delete one LightWorkTask
     *   }
     * })
     * 
     */
    delete<T extends LightWorkTaskDeleteArgs>(args: SelectSubset<T, LightWorkTaskDeleteArgs<ExtArgs>>): Prisma__LightWorkTaskClient<$Result.GetResult<Prisma.$LightWorkTaskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LightWorkTask.
     * @param {LightWorkTaskUpdateArgs} args - Arguments to update one LightWorkTask.
     * @example
     * // Update one LightWorkTask
     * const lightWorkTask = await prisma.lightWorkTask.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LightWorkTaskUpdateArgs>(args: SelectSubset<T, LightWorkTaskUpdateArgs<ExtArgs>>): Prisma__LightWorkTaskClient<$Result.GetResult<Prisma.$LightWorkTaskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LightWorkTasks.
     * @param {LightWorkTaskDeleteManyArgs} args - Arguments to filter LightWorkTasks to delete.
     * @example
     * // Delete a few LightWorkTasks
     * const { count } = await prisma.lightWorkTask.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LightWorkTaskDeleteManyArgs>(args?: SelectSubset<T, LightWorkTaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LightWorkTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LightWorkTaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LightWorkTasks
     * const lightWorkTask = await prisma.lightWorkTask.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LightWorkTaskUpdateManyArgs>(args: SelectSubset<T, LightWorkTaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LightWorkTasks and returns the data updated in the database.
     * @param {LightWorkTaskUpdateManyAndReturnArgs} args - Arguments to update many LightWorkTasks.
     * @example
     * // Update many LightWorkTasks
     * const lightWorkTask = await prisma.lightWorkTask.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LightWorkTasks and only return the `id`
     * const lightWorkTaskWithIdOnly = await prisma.lightWorkTask.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LightWorkTaskUpdateManyAndReturnArgs>(args: SelectSubset<T, LightWorkTaskUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LightWorkTaskPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LightWorkTask.
     * @param {LightWorkTaskUpsertArgs} args - Arguments to update or create a LightWorkTask.
     * @example
     * // Update or create a LightWorkTask
     * const lightWorkTask = await prisma.lightWorkTask.upsert({
     *   create: {
     *     // ... data to create a LightWorkTask
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LightWorkTask we want to update
     *   }
     * })
     */
    upsert<T extends LightWorkTaskUpsertArgs>(args: SelectSubset<T, LightWorkTaskUpsertArgs<ExtArgs>>): Prisma__LightWorkTaskClient<$Result.GetResult<Prisma.$LightWorkTaskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LightWorkTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LightWorkTaskCountArgs} args - Arguments to filter LightWorkTasks to count.
     * @example
     * // Count the number of LightWorkTasks
     * const count = await prisma.lightWorkTask.count({
     *   where: {
     *     // ... the filter for the LightWorkTasks we want to count
     *   }
     * })
    **/
    count<T extends LightWorkTaskCountArgs>(
      args?: Subset<T, LightWorkTaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LightWorkTaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LightWorkTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LightWorkTaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LightWorkTaskAggregateArgs>(args: Subset<T, LightWorkTaskAggregateArgs>): Prisma.PrismaPromise<GetLightWorkTaskAggregateType<T>>

    /**
     * Group by LightWorkTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LightWorkTaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LightWorkTaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LightWorkTaskGroupByArgs['orderBy'] }
        : { orderBy?: LightWorkTaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LightWorkTaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLightWorkTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LightWorkTask model
   */
  readonly fields: LightWorkTaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LightWorkTask.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LightWorkTaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subtasks<T extends LightWorkTask$subtasksArgs<ExtArgs> = {}>(args?: Subset<T, LightWorkTask$subtasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LightWorkSubtaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LightWorkTask model
   */
  interface LightWorkTaskFieldRefs {
    readonly id: FieldRef<"LightWorkTask", 'String'>
    readonly userId: FieldRef<"LightWorkTask", 'String'>
    readonly title: FieldRef<"LightWorkTask", 'String'>
    readonly description: FieldRef<"LightWorkTask", 'String'>
    readonly priority: FieldRef<"LightWorkTask", 'Priority'>
    readonly completed: FieldRef<"LightWorkTask", 'Boolean'>
    readonly originalDate: FieldRef<"LightWorkTask", 'String'>
    readonly currentDate: FieldRef<"LightWorkTask", 'String'>
    readonly estimatedDuration: FieldRef<"LightWorkTask", 'Int'>
    readonly rollovers: FieldRef<"LightWorkTask", 'Int'>
    readonly tags: FieldRef<"LightWorkTask", 'String[]'>
    readonly category: FieldRef<"LightWorkTask", 'String'>
    readonly createdAt: FieldRef<"LightWorkTask", 'DateTime'>
    readonly updatedAt: FieldRef<"LightWorkTask", 'DateTime'>
    readonly completedAt: FieldRef<"LightWorkTask", 'DateTime'>
    readonly startedAt: FieldRef<"LightWorkTask", 'DateTime'>
    readonly actualDurationMin: FieldRef<"LightWorkTask", 'Int'>
    readonly timeEstimate: FieldRef<"LightWorkTask", 'String'>
    readonly aiAnalyzed: FieldRef<"LightWorkTask", 'Boolean'>
    readonly aiReasoning: FieldRef<"LightWorkTask", 'String'>
    readonly analyzedAt: FieldRef<"LightWorkTask", 'DateTime'>
    readonly xpReward: FieldRef<"LightWorkTask", 'Int'>
    readonly complexity: FieldRef<"LightWorkTask", 'Int'>
    readonly confidence: FieldRef<"LightWorkTask", 'Float'>
    readonly contextualBonus: FieldRef<"LightWorkTask", 'Float'>
    readonly difficulty: FieldRef<"LightWorkTask", 'Int'>
    readonly learningValue: FieldRef<"LightWorkTask", 'Int'>
    readonly priorityRank: FieldRef<"LightWorkTask", 'Int'>
    readonly strategicImportance: FieldRef<"LightWorkTask", 'Int'>
    readonly timeAccuracy: FieldRef<"LightWorkTask", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * LightWorkTask findUnique
   */
  export type LightWorkTaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LightWorkTask
     */
    select?: LightWorkTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LightWorkTask
     */
    omit?: LightWorkTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LightWorkTaskInclude<ExtArgs> | null
    /**
     * Filter, which LightWorkTask to fetch.
     */
    where: LightWorkTaskWhereUniqueInput
  }

  /**
   * LightWorkTask findUniqueOrThrow
   */
  export type LightWorkTaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LightWorkTask
     */
    select?: LightWorkTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LightWorkTask
     */
    omit?: LightWorkTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LightWorkTaskInclude<ExtArgs> | null
    /**
     * Filter, which LightWorkTask to fetch.
     */
    where: LightWorkTaskWhereUniqueInput
  }

  /**
   * LightWorkTask findFirst
   */
  export type LightWorkTaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LightWorkTask
     */
    select?: LightWorkTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LightWorkTask
     */
    omit?: LightWorkTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LightWorkTaskInclude<ExtArgs> | null
    /**
     * Filter, which LightWorkTask to fetch.
     */
    where?: LightWorkTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LightWorkTasks to fetch.
     */
    orderBy?: LightWorkTaskOrderByWithRelationInput | LightWorkTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LightWorkTasks.
     */
    cursor?: LightWorkTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LightWorkTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LightWorkTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LightWorkTasks.
     */
    distinct?: LightWorkTaskScalarFieldEnum | LightWorkTaskScalarFieldEnum[]
  }

  /**
   * LightWorkTask findFirstOrThrow
   */
  export type LightWorkTaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LightWorkTask
     */
    select?: LightWorkTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LightWorkTask
     */
    omit?: LightWorkTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LightWorkTaskInclude<ExtArgs> | null
    /**
     * Filter, which LightWorkTask to fetch.
     */
    where?: LightWorkTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LightWorkTasks to fetch.
     */
    orderBy?: LightWorkTaskOrderByWithRelationInput | LightWorkTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LightWorkTasks.
     */
    cursor?: LightWorkTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LightWorkTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LightWorkTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LightWorkTasks.
     */
    distinct?: LightWorkTaskScalarFieldEnum | LightWorkTaskScalarFieldEnum[]
  }

  /**
   * LightWorkTask findMany
   */
  export type LightWorkTaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LightWorkTask
     */
    select?: LightWorkTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LightWorkTask
     */
    omit?: LightWorkTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LightWorkTaskInclude<ExtArgs> | null
    /**
     * Filter, which LightWorkTasks to fetch.
     */
    where?: LightWorkTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LightWorkTasks to fetch.
     */
    orderBy?: LightWorkTaskOrderByWithRelationInput | LightWorkTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LightWorkTasks.
     */
    cursor?: LightWorkTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LightWorkTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LightWorkTasks.
     */
    skip?: number
    distinct?: LightWorkTaskScalarFieldEnum | LightWorkTaskScalarFieldEnum[]
  }

  /**
   * LightWorkTask create
   */
  export type LightWorkTaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LightWorkTask
     */
    select?: LightWorkTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LightWorkTask
     */
    omit?: LightWorkTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LightWorkTaskInclude<ExtArgs> | null
    /**
     * The data needed to create a LightWorkTask.
     */
    data: XOR<LightWorkTaskCreateInput, LightWorkTaskUncheckedCreateInput>
  }

  /**
   * LightWorkTask createMany
   */
  export type LightWorkTaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LightWorkTasks.
     */
    data: LightWorkTaskCreateManyInput | LightWorkTaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LightWorkTask createManyAndReturn
   */
  export type LightWorkTaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LightWorkTask
     */
    select?: LightWorkTaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LightWorkTask
     */
    omit?: LightWorkTaskOmit<ExtArgs> | null
    /**
     * The data used to create many LightWorkTasks.
     */
    data: LightWorkTaskCreateManyInput | LightWorkTaskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LightWorkTaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LightWorkTask update
   */
  export type LightWorkTaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LightWorkTask
     */
    select?: LightWorkTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LightWorkTask
     */
    omit?: LightWorkTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LightWorkTaskInclude<ExtArgs> | null
    /**
     * The data needed to update a LightWorkTask.
     */
    data: XOR<LightWorkTaskUpdateInput, LightWorkTaskUncheckedUpdateInput>
    /**
     * Choose, which LightWorkTask to update.
     */
    where: LightWorkTaskWhereUniqueInput
  }

  /**
   * LightWorkTask updateMany
   */
  export type LightWorkTaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LightWorkTasks.
     */
    data: XOR<LightWorkTaskUpdateManyMutationInput, LightWorkTaskUncheckedUpdateManyInput>
    /**
     * Filter which LightWorkTasks to update
     */
    where?: LightWorkTaskWhereInput
    /**
     * Limit how many LightWorkTasks to update.
     */
    limit?: number
  }

  /**
   * LightWorkTask updateManyAndReturn
   */
  export type LightWorkTaskUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LightWorkTask
     */
    select?: LightWorkTaskSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LightWorkTask
     */
    omit?: LightWorkTaskOmit<ExtArgs> | null
    /**
     * The data used to update LightWorkTasks.
     */
    data: XOR<LightWorkTaskUpdateManyMutationInput, LightWorkTaskUncheckedUpdateManyInput>
    /**
     * Filter which LightWorkTasks to update
     */
    where?: LightWorkTaskWhereInput
    /**
     * Limit how many LightWorkTasks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LightWorkTaskIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LightWorkTask upsert
   */
  export type LightWorkTaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LightWorkTask
     */
    select?: LightWorkTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LightWorkTask
     */
    omit?: LightWorkTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LightWorkTaskInclude<ExtArgs> | null
    /**
     * The filter to search for the LightWorkTask to update in case it exists.
     */
    where: LightWorkTaskWhereUniqueInput
    /**
     * In case the LightWorkTask found by the `where` argument doesn't exist, create a new LightWorkTask with this data.
     */
    create: XOR<LightWorkTaskCreateInput, LightWorkTaskUncheckedCreateInput>
    /**
     * In case the LightWorkTask was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LightWorkTaskUpdateInput, LightWorkTaskUncheckedUpdateInput>
  }

  /**
   * LightWorkTask delete
   */
  export type LightWorkTaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LightWorkTask
     */
    select?: LightWorkTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LightWorkTask
     */
    omit?: LightWorkTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LightWorkTaskInclude<ExtArgs> | null
    /**
     * Filter which LightWorkTask to delete.
     */
    where: LightWorkTaskWhereUniqueInput
  }

  /**
   * LightWorkTask deleteMany
   */
  export type LightWorkTaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LightWorkTasks to delete
     */
    where?: LightWorkTaskWhereInput
    /**
     * Limit how many LightWorkTasks to delete.
     */
    limit?: number
  }

  /**
   * LightWorkTask.subtasks
   */
  export type LightWorkTask$subtasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LightWorkSubtask
     */
    select?: LightWorkSubtaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LightWorkSubtask
     */
    omit?: LightWorkSubtaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LightWorkSubtaskInclude<ExtArgs> | null
    where?: LightWorkSubtaskWhereInput
    orderBy?: LightWorkSubtaskOrderByWithRelationInput | LightWorkSubtaskOrderByWithRelationInput[]
    cursor?: LightWorkSubtaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LightWorkSubtaskScalarFieldEnum | LightWorkSubtaskScalarFieldEnum[]
  }

  /**
   * LightWorkTask without action
   */
  export type LightWorkTaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LightWorkTask
     */
    select?: LightWorkTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LightWorkTask
     */
    omit?: LightWorkTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LightWorkTaskInclude<ExtArgs> | null
  }


  /**
   * Model LightWorkSubtask
   */

  export type AggregateLightWorkSubtask = {
    _count: LightWorkSubtaskCountAggregateOutputType | null
    _avg: LightWorkSubtaskAvgAggregateOutputType | null
    _sum: LightWorkSubtaskSumAggregateOutputType | null
    _min: LightWorkSubtaskMinAggregateOutputType | null
    _max: LightWorkSubtaskMaxAggregateOutputType | null
  }

  export type LightWorkSubtaskAvgAggregateOutputType = {
    actualDurationMin: number | null
    timeAccuracy: number | null
    xpReward: number | null
    complexity: number | null
    confidence: number | null
    contextualBonus: number | null
    difficulty: number | null
    learningValue: number | null
    priorityRank: number | null
    strategicImportance: number | null
  }

  export type LightWorkSubtaskSumAggregateOutputType = {
    actualDurationMin: number | null
    timeAccuracy: number | null
    xpReward: number | null
    complexity: number | null
    confidence: number | null
    contextualBonus: number | null
    difficulty: number | null
    learningValue: number | null
    priorityRank: number | null
    strategicImportance: number | null
  }

  export type LightWorkSubtaskMinAggregateOutputType = {
    id: string | null
    taskId: string | null
    title: string | null
    text: string | null
    completed: boolean | null
    priority: string | null
    dueDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    completedAt: Date | null
    startedAt: Date | null
    actualDurationMin: number | null
    timeAccuracy: number | null
    aiAnalyzed: boolean | null
    aiReasoning: string | null
    analyzedAt: Date | null
    xpReward: number | null
    complexity: number | null
    confidence: number | null
    contextualBonus: number | null
    difficulty: number | null
    learningValue: number | null
    priorityRank: number | null
    strategicImportance: number | null
  }

  export type LightWorkSubtaskMaxAggregateOutputType = {
    id: string | null
    taskId: string | null
    title: string | null
    text: string | null
    completed: boolean | null
    priority: string | null
    dueDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    completedAt: Date | null
    startedAt: Date | null
    actualDurationMin: number | null
    timeAccuracy: number | null
    aiAnalyzed: boolean | null
    aiReasoning: string | null
    analyzedAt: Date | null
    xpReward: number | null
    complexity: number | null
    confidence: number | null
    contextualBonus: number | null
    difficulty: number | null
    learningValue: number | null
    priorityRank: number | null
    strategicImportance: number | null
  }

  export type LightWorkSubtaskCountAggregateOutputType = {
    id: number
    taskId: number
    title: number
    text: number
    completed: number
    priority: number
    dueDate: number
    createdAt: number
    updatedAt: number
    completedAt: number
    startedAt: number
    actualDurationMin: number
    timeAccuracy: number
    aiAnalyzed: number
    aiReasoning: number
    analyzedAt: number
    xpReward: number
    complexity: number
    confidence: number
    contextualBonus: number
    difficulty: number
    learningValue: number
    priorityRank: number
    strategicImportance: number
    _all: number
  }


  export type LightWorkSubtaskAvgAggregateInputType = {
    actualDurationMin?: true
    timeAccuracy?: true
    xpReward?: true
    complexity?: true
    confidence?: true
    contextualBonus?: true
    difficulty?: true
    learningValue?: true
    priorityRank?: true
    strategicImportance?: true
  }

  export type LightWorkSubtaskSumAggregateInputType = {
    actualDurationMin?: true
    timeAccuracy?: true
    xpReward?: true
    complexity?: true
    confidence?: true
    contextualBonus?: true
    difficulty?: true
    learningValue?: true
    priorityRank?: true
    strategicImportance?: true
  }

  export type LightWorkSubtaskMinAggregateInputType = {
    id?: true
    taskId?: true
    title?: true
    text?: true
    completed?: true
    priority?: true
    dueDate?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
    startedAt?: true
    actualDurationMin?: true
    timeAccuracy?: true
    aiAnalyzed?: true
    aiReasoning?: true
    analyzedAt?: true
    xpReward?: true
    complexity?: true
    confidence?: true
    contextualBonus?: true
    difficulty?: true
    learningValue?: true
    priorityRank?: true
    strategicImportance?: true
  }

  export type LightWorkSubtaskMaxAggregateInputType = {
    id?: true
    taskId?: true
    title?: true
    text?: true
    completed?: true
    priority?: true
    dueDate?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
    startedAt?: true
    actualDurationMin?: true
    timeAccuracy?: true
    aiAnalyzed?: true
    aiReasoning?: true
    analyzedAt?: true
    xpReward?: true
    complexity?: true
    confidence?: true
    contextualBonus?: true
    difficulty?: true
    learningValue?: true
    priorityRank?: true
    strategicImportance?: true
  }

  export type LightWorkSubtaskCountAggregateInputType = {
    id?: true
    taskId?: true
    title?: true
    text?: true
    completed?: true
    priority?: true
    dueDate?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
    startedAt?: true
    actualDurationMin?: true
    timeAccuracy?: true
    aiAnalyzed?: true
    aiReasoning?: true
    analyzedAt?: true
    xpReward?: true
    complexity?: true
    confidence?: true
    contextualBonus?: true
    difficulty?: true
    learningValue?: true
    priorityRank?: true
    strategicImportance?: true
    _all?: true
  }

  export type LightWorkSubtaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LightWorkSubtask to aggregate.
     */
    where?: LightWorkSubtaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LightWorkSubtasks to fetch.
     */
    orderBy?: LightWorkSubtaskOrderByWithRelationInput | LightWorkSubtaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LightWorkSubtaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LightWorkSubtasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LightWorkSubtasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LightWorkSubtasks
    **/
    _count?: true | LightWorkSubtaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LightWorkSubtaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LightWorkSubtaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LightWorkSubtaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LightWorkSubtaskMaxAggregateInputType
  }

  export type GetLightWorkSubtaskAggregateType<T extends LightWorkSubtaskAggregateArgs> = {
        [P in keyof T & keyof AggregateLightWorkSubtask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLightWorkSubtask[P]>
      : GetScalarType<T[P], AggregateLightWorkSubtask[P]>
  }




  export type LightWorkSubtaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LightWorkSubtaskWhereInput
    orderBy?: LightWorkSubtaskOrderByWithAggregationInput | LightWorkSubtaskOrderByWithAggregationInput[]
    by: LightWorkSubtaskScalarFieldEnum[] | LightWorkSubtaskScalarFieldEnum
    having?: LightWorkSubtaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LightWorkSubtaskCountAggregateInputType | true
    _avg?: LightWorkSubtaskAvgAggregateInputType
    _sum?: LightWorkSubtaskSumAggregateInputType
    _min?: LightWorkSubtaskMinAggregateInputType
    _max?: LightWorkSubtaskMaxAggregateInputType
  }

  export type LightWorkSubtaskGroupByOutputType = {
    id: string
    taskId: string
    title: string
    text: string
    completed: boolean
    priority: string | null
    dueDate: Date | null
    createdAt: Date
    updatedAt: Date
    completedAt: Date | null
    startedAt: Date | null
    actualDurationMin: number | null
    timeAccuracy: number | null
    aiAnalyzed: boolean
    aiReasoning: string | null
    analyzedAt: Date | null
    xpReward: number | null
    complexity: number | null
    confidence: number | null
    contextualBonus: number | null
    difficulty: number | null
    learningValue: number | null
    priorityRank: number | null
    strategicImportance: number | null
    _count: LightWorkSubtaskCountAggregateOutputType | null
    _avg: LightWorkSubtaskAvgAggregateOutputType | null
    _sum: LightWorkSubtaskSumAggregateOutputType | null
    _min: LightWorkSubtaskMinAggregateOutputType | null
    _max: LightWorkSubtaskMaxAggregateOutputType | null
  }

  type GetLightWorkSubtaskGroupByPayload<T extends LightWorkSubtaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LightWorkSubtaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LightWorkSubtaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LightWorkSubtaskGroupByOutputType[P]>
            : GetScalarType<T[P], LightWorkSubtaskGroupByOutputType[P]>
        }
      >
    >


  export type LightWorkSubtaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    title?: boolean
    text?: boolean
    completed?: boolean
    priority?: boolean
    dueDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    startedAt?: boolean
    actualDurationMin?: boolean
    timeAccuracy?: boolean
    aiAnalyzed?: boolean
    aiReasoning?: boolean
    analyzedAt?: boolean
    xpReward?: boolean
    complexity?: boolean
    confidence?: boolean
    contextualBonus?: boolean
    difficulty?: boolean
    learningValue?: boolean
    priorityRank?: boolean
    strategicImportance?: boolean
    task?: boolean | LightWorkTaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lightWorkSubtask"]>

  export type LightWorkSubtaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    title?: boolean
    text?: boolean
    completed?: boolean
    priority?: boolean
    dueDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    startedAt?: boolean
    actualDurationMin?: boolean
    timeAccuracy?: boolean
    aiAnalyzed?: boolean
    aiReasoning?: boolean
    analyzedAt?: boolean
    xpReward?: boolean
    complexity?: boolean
    confidence?: boolean
    contextualBonus?: boolean
    difficulty?: boolean
    learningValue?: boolean
    priorityRank?: boolean
    strategicImportance?: boolean
    task?: boolean | LightWorkTaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lightWorkSubtask"]>

  export type LightWorkSubtaskSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    title?: boolean
    text?: boolean
    completed?: boolean
    priority?: boolean
    dueDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    startedAt?: boolean
    actualDurationMin?: boolean
    timeAccuracy?: boolean
    aiAnalyzed?: boolean
    aiReasoning?: boolean
    analyzedAt?: boolean
    xpReward?: boolean
    complexity?: boolean
    confidence?: boolean
    contextualBonus?: boolean
    difficulty?: boolean
    learningValue?: boolean
    priorityRank?: boolean
    strategicImportance?: boolean
    task?: boolean | LightWorkTaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lightWorkSubtask"]>

  export type LightWorkSubtaskSelectScalar = {
    id?: boolean
    taskId?: boolean
    title?: boolean
    text?: boolean
    completed?: boolean
    priority?: boolean
    dueDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    startedAt?: boolean
    actualDurationMin?: boolean
    timeAccuracy?: boolean
    aiAnalyzed?: boolean
    aiReasoning?: boolean
    analyzedAt?: boolean
    xpReward?: boolean
    complexity?: boolean
    confidence?: boolean
    contextualBonus?: boolean
    difficulty?: boolean
    learningValue?: boolean
    priorityRank?: boolean
    strategicImportance?: boolean
  }

  export type LightWorkSubtaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "taskId" | "title" | "text" | "completed" | "priority" | "dueDate" | "createdAt" | "updatedAt" | "completedAt" | "startedAt" | "actualDurationMin" | "timeAccuracy" | "aiAnalyzed" | "aiReasoning" | "analyzedAt" | "xpReward" | "complexity" | "confidence" | "contextualBonus" | "difficulty" | "learningValue" | "priorityRank" | "strategicImportance", ExtArgs["result"]["lightWorkSubtask"]>
  export type LightWorkSubtaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | LightWorkTaskDefaultArgs<ExtArgs>
  }
  export type LightWorkSubtaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | LightWorkTaskDefaultArgs<ExtArgs>
  }
  export type LightWorkSubtaskIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | LightWorkTaskDefaultArgs<ExtArgs>
  }

  export type $LightWorkSubtaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LightWorkSubtask"
    objects: {
      task: Prisma.$LightWorkTaskPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      taskId: string
      title: string
      text: string
      completed: boolean
      priority: string | null
      dueDate: Date | null
      createdAt: Date
      updatedAt: Date
      completedAt: Date | null
      startedAt: Date | null
      actualDurationMin: number | null
      timeAccuracy: number | null
      aiAnalyzed: boolean
      aiReasoning: string | null
      analyzedAt: Date | null
      xpReward: number | null
      complexity: number | null
      confidence: number | null
      contextualBonus: number | null
      difficulty: number | null
      learningValue: number | null
      priorityRank: number | null
      strategicImportance: number | null
    }, ExtArgs["result"]["lightWorkSubtask"]>
    composites: {}
  }

  type LightWorkSubtaskGetPayload<S extends boolean | null | undefined | LightWorkSubtaskDefaultArgs> = $Result.GetResult<Prisma.$LightWorkSubtaskPayload, S>

  type LightWorkSubtaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LightWorkSubtaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LightWorkSubtaskCountAggregateInputType | true
    }

  export interface LightWorkSubtaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LightWorkSubtask'], meta: { name: 'LightWorkSubtask' } }
    /**
     * Find zero or one LightWorkSubtask that matches the filter.
     * @param {LightWorkSubtaskFindUniqueArgs} args - Arguments to find a LightWorkSubtask
     * @example
     * // Get one LightWorkSubtask
     * const lightWorkSubtask = await prisma.lightWorkSubtask.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LightWorkSubtaskFindUniqueArgs>(args: SelectSubset<T, LightWorkSubtaskFindUniqueArgs<ExtArgs>>): Prisma__LightWorkSubtaskClient<$Result.GetResult<Prisma.$LightWorkSubtaskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LightWorkSubtask that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LightWorkSubtaskFindUniqueOrThrowArgs} args - Arguments to find a LightWorkSubtask
     * @example
     * // Get one LightWorkSubtask
     * const lightWorkSubtask = await prisma.lightWorkSubtask.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LightWorkSubtaskFindUniqueOrThrowArgs>(args: SelectSubset<T, LightWorkSubtaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LightWorkSubtaskClient<$Result.GetResult<Prisma.$LightWorkSubtaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LightWorkSubtask that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LightWorkSubtaskFindFirstArgs} args - Arguments to find a LightWorkSubtask
     * @example
     * // Get one LightWorkSubtask
     * const lightWorkSubtask = await prisma.lightWorkSubtask.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LightWorkSubtaskFindFirstArgs>(args?: SelectSubset<T, LightWorkSubtaskFindFirstArgs<ExtArgs>>): Prisma__LightWorkSubtaskClient<$Result.GetResult<Prisma.$LightWorkSubtaskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LightWorkSubtask that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LightWorkSubtaskFindFirstOrThrowArgs} args - Arguments to find a LightWorkSubtask
     * @example
     * // Get one LightWorkSubtask
     * const lightWorkSubtask = await prisma.lightWorkSubtask.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LightWorkSubtaskFindFirstOrThrowArgs>(args?: SelectSubset<T, LightWorkSubtaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__LightWorkSubtaskClient<$Result.GetResult<Prisma.$LightWorkSubtaskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LightWorkSubtasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LightWorkSubtaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LightWorkSubtasks
     * const lightWorkSubtasks = await prisma.lightWorkSubtask.findMany()
     * 
     * // Get first 10 LightWorkSubtasks
     * const lightWorkSubtasks = await prisma.lightWorkSubtask.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lightWorkSubtaskWithIdOnly = await prisma.lightWorkSubtask.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LightWorkSubtaskFindManyArgs>(args?: SelectSubset<T, LightWorkSubtaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LightWorkSubtaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LightWorkSubtask.
     * @param {LightWorkSubtaskCreateArgs} args - Arguments to create a LightWorkSubtask.
     * @example
     * // Create one LightWorkSubtask
     * const LightWorkSubtask = await prisma.lightWorkSubtask.create({
     *   data: {
     *     // ... data to create a LightWorkSubtask
     *   }
     * })
     * 
     */
    create<T extends LightWorkSubtaskCreateArgs>(args: SelectSubset<T, LightWorkSubtaskCreateArgs<ExtArgs>>): Prisma__LightWorkSubtaskClient<$Result.GetResult<Prisma.$LightWorkSubtaskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LightWorkSubtasks.
     * @param {LightWorkSubtaskCreateManyArgs} args - Arguments to create many LightWorkSubtasks.
     * @example
     * // Create many LightWorkSubtasks
     * const lightWorkSubtask = await prisma.lightWorkSubtask.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LightWorkSubtaskCreateManyArgs>(args?: SelectSubset<T, LightWorkSubtaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LightWorkSubtasks and returns the data saved in the database.
     * @param {LightWorkSubtaskCreateManyAndReturnArgs} args - Arguments to create many LightWorkSubtasks.
     * @example
     * // Create many LightWorkSubtasks
     * const lightWorkSubtask = await prisma.lightWorkSubtask.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LightWorkSubtasks and only return the `id`
     * const lightWorkSubtaskWithIdOnly = await prisma.lightWorkSubtask.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LightWorkSubtaskCreateManyAndReturnArgs>(args?: SelectSubset<T, LightWorkSubtaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LightWorkSubtaskPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LightWorkSubtask.
     * @param {LightWorkSubtaskDeleteArgs} args - Arguments to delete one LightWorkSubtask.
     * @example
     * // Delete one LightWorkSubtask
     * const LightWorkSubtask = await prisma.lightWorkSubtask.delete({
     *   where: {
     *     // ... filter to delete one LightWorkSubtask
     *   }
     * })
     * 
     */
    delete<T extends LightWorkSubtaskDeleteArgs>(args: SelectSubset<T, LightWorkSubtaskDeleteArgs<ExtArgs>>): Prisma__LightWorkSubtaskClient<$Result.GetResult<Prisma.$LightWorkSubtaskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LightWorkSubtask.
     * @param {LightWorkSubtaskUpdateArgs} args - Arguments to update one LightWorkSubtask.
     * @example
     * // Update one LightWorkSubtask
     * const lightWorkSubtask = await prisma.lightWorkSubtask.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LightWorkSubtaskUpdateArgs>(args: SelectSubset<T, LightWorkSubtaskUpdateArgs<ExtArgs>>): Prisma__LightWorkSubtaskClient<$Result.GetResult<Prisma.$LightWorkSubtaskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LightWorkSubtasks.
     * @param {LightWorkSubtaskDeleteManyArgs} args - Arguments to filter LightWorkSubtasks to delete.
     * @example
     * // Delete a few LightWorkSubtasks
     * const { count } = await prisma.lightWorkSubtask.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LightWorkSubtaskDeleteManyArgs>(args?: SelectSubset<T, LightWorkSubtaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LightWorkSubtasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LightWorkSubtaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LightWorkSubtasks
     * const lightWorkSubtask = await prisma.lightWorkSubtask.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LightWorkSubtaskUpdateManyArgs>(args: SelectSubset<T, LightWorkSubtaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LightWorkSubtasks and returns the data updated in the database.
     * @param {LightWorkSubtaskUpdateManyAndReturnArgs} args - Arguments to update many LightWorkSubtasks.
     * @example
     * // Update many LightWorkSubtasks
     * const lightWorkSubtask = await prisma.lightWorkSubtask.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LightWorkSubtasks and only return the `id`
     * const lightWorkSubtaskWithIdOnly = await prisma.lightWorkSubtask.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LightWorkSubtaskUpdateManyAndReturnArgs>(args: SelectSubset<T, LightWorkSubtaskUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LightWorkSubtaskPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LightWorkSubtask.
     * @param {LightWorkSubtaskUpsertArgs} args - Arguments to update or create a LightWorkSubtask.
     * @example
     * // Update or create a LightWorkSubtask
     * const lightWorkSubtask = await prisma.lightWorkSubtask.upsert({
     *   create: {
     *     // ... data to create a LightWorkSubtask
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LightWorkSubtask we want to update
     *   }
     * })
     */
    upsert<T extends LightWorkSubtaskUpsertArgs>(args: SelectSubset<T, LightWorkSubtaskUpsertArgs<ExtArgs>>): Prisma__LightWorkSubtaskClient<$Result.GetResult<Prisma.$LightWorkSubtaskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LightWorkSubtasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LightWorkSubtaskCountArgs} args - Arguments to filter LightWorkSubtasks to count.
     * @example
     * // Count the number of LightWorkSubtasks
     * const count = await prisma.lightWorkSubtask.count({
     *   where: {
     *     // ... the filter for the LightWorkSubtasks we want to count
     *   }
     * })
    **/
    count<T extends LightWorkSubtaskCountArgs>(
      args?: Subset<T, LightWorkSubtaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LightWorkSubtaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LightWorkSubtask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LightWorkSubtaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LightWorkSubtaskAggregateArgs>(args: Subset<T, LightWorkSubtaskAggregateArgs>): Prisma.PrismaPromise<GetLightWorkSubtaskAggregateType<T>>

    /**
     * Group by LightWorkSubtask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LightWorkSubtaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LightWorkSubtaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LightWorkSubtaskGroupByArgs['orderBy'] }
        : { orderBy?: LightWorkSubtaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LightWorkSubtaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLightWorkSubtaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LightWorkSubtask model
   */
  readonly fields: LightWorkSubtaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LightWorkSubtask.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LightWorkSubtaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task<T extends LightWorkTaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LightWorkTaskDefaultArgs<ExtArgs>>): Prisma__LightWorkTaskClient<$Result.GetResult<Prisma.$LightWorkTaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LightWorkSubtask model
   */
  interface LightWorkSubtaskFieldRefs {
    readonly id: FieldRef<"LightWorkSubtask", 'String'>
    readonly taskId: FieldRef<"LightWorkSubtask", 'String'>
    readonly title: FieldRef<"LightWorkSubtask", 'String'>
    readonly text: FieldRef<"LightWorkSubtask", 'String'>
    readonly completed: FieldRef<"LightWorkSubtask", 'Boolean'>
    readonly priority: FieldRef<"LightWorkSubtask", 'String'>
    readonly dueDate: FieldRef<"LightWorkSubtask", 'DateTime'>
    readonly createdAt: FieldRef<"LightWorkSubtask", 'DateTime'>
    readonly updatedAt: FieldRef<"LightWorkSubtask", 'DateTime'>
    readonly completedAt: FieldRef<"LightWorkSubtask", 'DateTime'>
    readonly startedAt: FieldRef<"LightWorkSubtask", 'DateTime'>
    readonly actualDurationMin: FieldRef<"LightWorkSubtask", 'Int'>
    readonly timeAccuracy: FieldRef<"LightWorkSubtask", 'Float'>
    readonly aiAnalyzed: FieldRef<"LightWorkSubtask", 'Boolean'>
    readonly aiReasoning: FieldRef<"LightWorkSubtask", 'String'>
    readonly analyzedAt: FieldRef<"LightWorkSubtask", 'DateTime'>
    readonly xpReward: FieldRef<"LightWorkSubtask", 'Int'>
    readonly complexity: FieldRef<"LightWorkSubtask", 'Int'>
    readonly confidence: FieldRef<"LightWorkSubtask", 'Float'>
    readonly contextualBonus: FieldRef<"LightWorkSubtask", 'Float'>
    readonly difficulty: FieldRef<"LightWorkSubtask", 'Int'>
    readonly learningValue: FieldRef<"LightWorkSubtask", 'Int'>
    readonly priorityRank: FieldRef<"LightWorkSubtask", 'Int'>
    readonly strategicImportance: FieldRef<"LightWorkSubtask", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * LightWorkSubtask findUnique
   */
  export type LightWorkSubtaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LightWorkSubtask
     */
    select?: LightWorkSubtaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LightWorkSubtask
     */
    omit?: LightWorkSubtaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LightWorkSubtaskInclude<ExtArgs> | null
    /**
     * Filter, which LightWorkSubtask to fetch.
     */
    where: LightWorkSubtaskWhereUniqueInput
  }

  /**
   * LightWorkSubtask findUniqueOrThrow
   */
  export type LightWorkSubtaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LightWorkSubtask
     */
    select?: LightWorkSubtaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LightWorkSubtask
     */
    omit?: LightWorkSubtaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LightWorkSubtaskInclude<ExtArgs> | null
    /**
     * Filter, which LightWorkSubtask to fetch.
     */
    where: LightWorkSubtaskWhereUniqueInput
  }

  /**
   * LightWorkSubtask findFirst
   */
  export type LightWorkSubtaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LightWorkSubtask
     */
    select?: LightWorkSubtaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LightWorkSubtask
     */
    omit?: LightWorkSubtaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LightWorkSubtaskInclude<ExtArgs> | null
    /**
     * Filter, which LightWorkSubtask to fetch.
     */
    where?: LightWorkSubtaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LightWorkSubtasks to fetch.
     */
    orderBy?: LightWorkSubtaskOrderByWithRelationInput | LightWorkSubtaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LightWorkSubtasks.
     */
    cursor?: LightWorkSubtaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LightWorkSubtasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LightWorkSubtasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LightWorkSubtasks.
     */
    distinct?: LightWorkSubtaskScalarFieldEnum | LightWorkSubtaskScalarFieldEnum[]
  }

  /**
   * LightWorkSubtask findFirstOrThrow
   */
  export type LightWorkSubtaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LightWorkSubtask
     */
    select?: LightWorkSubtaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LightWorkSubtask
     */
    omit?: LightWorkSubtaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LightWorkSubtaskInclude<ExtArgs> | null
    /**
     * Filter, which LightWorkSubtask to fetch.
     */
    where?: LightWorkSubtaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LightWorkSubtasks to fetch.
     */
    orderBy?: LightWorkSubtaskOrderByWithRelationInput | LightWorkSubtaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LightWorkSubtasks.
     */
    cursor?: LightWorkSubtaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LightWorkSubtasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LightWorkSubtasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LightWorkSubtasks.
     */
    distinct?: LightWorkSubtaskScalarFieldEnum | LightWorkSubtaskScalarFieldEnum[]
  }

  /**
   * LightWorkSubtask findMany
   */
  export type LightWorkSubtaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LightWorkSubtask
     */
    select?: LightWorkSubtaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LightWorkSubtask
     */
    omit?: LightWorkSubtaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LightWorkSubtaskInclude<ExtArgs> | null
    /**
     * Filter, which LightWorkSubtasks to fetch.
     */
    where?: LightWorkSubtaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LightWorkSubtasks to fetch.
     */
    orderBy?: LightWorkSubtaskOrderByWithRelationInput | LightWorkSubtaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LightWorkSubtasks.
     */
    cursor?: LightWorkSubtaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LightWorkSubtasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LightWorkSubtasks.
     */
    skip?: number
    distinct?: LightWorkSubtaskScalarFieldEnum | LightWorkSubtaskScalarFieldEnum[]
  }

  /**
   * LightWorkSubtask create
   */
  export type LightWorkSubtaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LightWorkSubtask
     */
    select?: LightWorkSubtaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LightWorkSubtask
     */
    omit?: LightWorkSubtaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LightWorkSubtaskInclude<ExtArgs> | null
    /**
     * The data needed to create a LightWorkSubtask.
     */
    data: XOR<LightWorkSubtaskCreateInput, LightWorkSubtaskUncheckedCreateInput>
  }

  /**
   * LightWorkSubtask createMany
   */
  export type LightWorkSubtaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LightWorkSubtasks.
     */
    data: LightWorkSubtaskCreateManyInput | LightWorkSubtaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LightWorkSubtask createManyAndReturn
   */
  export type LightWorkSubtaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LightWorkSubtask
     */
    select?: LightWorkSubtaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LightWorkSubtask
     */
    omit?: LightWorkSubtaskOmit<ExtArgs> | null
    /**
     * The data used to create many LightWorkSubtasks.
     */
    data: LightWorkSubtaskCreateManyInput | LightWorkSubtaskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LightWorkSubtaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LightWorkSubtask update
   */
  export type LightWorkSubtaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LightWorkSubtask
     */
    select?: LightWorkSubtaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LightWorkSubtask
     */
    omit?: LightWorkSubtaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LightWorkSubtaskInclude<ExtArgs> | null
    /**
     * The data needed to update a LightWorkSubtask.
     */
    data: XOR<LightWorkSubtaskUpdateInput, LightWorkSubtaskUncheckedUpdateInput>
    /**
     * Choose, which LightWorkSubtask to update.
     */
    where: LightWorkSubtaskWhereUniqueInput
  }

  /**
   * LightWorkSubtask updateMany
   */
  export type LightWorkSubtaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LightWorkSubtasks.
     */
    data: XOR<LightWorkSubtaskUpdateManyMutationInput, LightWorkSubtaskUncheckedUpdateManyInput>
    /**
     * Filter which LightWorkSubtasks to update
     */
    where?: LightWorkSubtaskWhereInput
    /**
     * Limit how many LightWorkSubtasks to update.
     */
    limit?: number
  }

  /**
   * LightWorkSubtask updateManyAndReturn
   */
  export type LightWorkSubtaskUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LightWorkSubtask
     */
    select?: LightWorkSubtaskSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LightWorkSubtask
     */
    omit?: LightWorkSubtaskOmit<ExtArgs> | null
    /**
     * The data used to update LightWorkSubtasks.
     */
    data: XOR<LightWorkSubtaskUpdateManyMutationInput, LightWorkSubtaskUncheckedUpdateManyInput>
    /**
     * Filter which LightWorkSubtasks to update
     */
    where?: LightWorkSubtaskWhereInput
    /**
     * Limit how many LightWorkSubtasks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LightWorkSubtaskIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LightWorkSubtask upsert
   */
  export type LightWorkSubtaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LightWorkSubtask
     */
    select?: LightWorkSubtaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LightWorkSubtask
     */
    omit?: LightWorkSubtaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LightWorkSubtaskInclude<ExtArgs> | null
    /**
     * The filter to search for the LightWorkSubtask to update in case it exists.
     */
    where: LightWorkSubtaskWhereUniqueInput
    /**
     * In case the LightWorkSubtask found by the `where` argument doesn't exist, create a new LightWorkSubtask with this data.
     */
    create: XOR<LightWorkSubtaskCreateInput, LightWorkSubtaskUncheckedCreateInput>
    /**
     * In case the LightWorkSubtask was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LightWorkSubtaskUpdateInput, LightWorkSubtaskUncheckedUpdateInput>
  }

  /**
   * LightWorkSubtask delete
   */
  export type LightWorkSubtaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LightWorkSubtask
     */
    select?: LightWorkSubtaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LightWorkSubtask
     */
    omit?: LightWorkSubtaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LightWorkSubtaskInclude<ExtArgs> | null
    /**
     * Filter which LightWorkSubtask to delete.
     */
    where: LightWorkSubtaskWhereUniqueInput
  }

  /**
   * LightWorkSubtask deleteMany
   */
  export type LightWorkSubtaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LightWorkSubtasks to delete
     */
    where?: LightWorkSubtaskWhereInput
    /**
     * Limit how many LightWorkSubtasks to delete.
     */
    limit?: number
  }

  /**
   * LightWorkSubtask without action
   */
  export type LightWorkSubtaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LightWorkSubtask
     */
    select?: LightWorkSubtaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LightWorkSubtask
     */
    omit?: LightWorkSubtaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LightWorkSubtaskInclude<ExtArgs> | null
  }


  /**
   * Model DeepWorkTask
   */

  export type AggregateDeepWorkTask = {
    _count: DeepWorkTaskCountAggregateOutputType | null
    _avg: DeepWorkTaskAvgAggregateOutputType | null
    _sum: DeepWorkTaskSumAggregateOutputType | null
    _min: DeepWorkTaskMinAggregateOutputType | null
    _max: DeepWorkTaskMaxAggregateOutputType | null
  }

  export type DeepWorkTaskAvgAggregateOutputType = {
    estimatedDuration: number | null
    focusBlocks: number | null
    breakDuration: number | null
    rollovers: number | null
    actualDurationMin: number | null
    xpReward: number | null
    complexity: number | null
    confidence: number | null
    contextualBonus: number | null
    difficulty: number | null
    learningValue: number | null
    priorityRank: number | null
    strategicImportance: number | null
    timeAccuracy: number | null
  }

  export type DeepWorkTaskSumAggregateOutputType = {
    estimatedDuration: number | null
    focusBlocks: number | null
    breakDuration: number | null
    rollovers: number | null
    actualDurationMin: number | null
    xpReward: number | null
    complexity: number | null
    confidence: number | null
    contextualBonus: number | null
    difficulty: number | null
    learningValue: number | null
    priorityRank: number | null
    strategicImportance: number | null
    timeAccuracy: number | null
  }

  export type DeepWorkTaskMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    description: string | null
    priority: $Enums.Priority | null
    completed: boolean | null
    originalDate: string | null
    currentDate: string | null
    estimatedDuration: number | null
    focusBlocks: number | null
    breakDuration: number | null
    interruptionMode: boolean | null
    rollovers: number | null
    category: string | null
    createdAt: Date | null
    updatedAt: Date | null
    completedAt: Date | null
    startedAt: Date | null
    actualDurationMin: number | null
    timeEstimate: string | null
    aiAnalyzed: boolean | null
    aiReasoning: string | null
    analyzedAt: Date | null
    xpReward: number | null
    complexity: number | null
    confidence: number | null
    contextualBonus: number | null
    difficulty: number | null
    learningValue: number | null
    priorityRank: number | null
    strategicImportance: number | null
    timeAccuracy: number | null
  }

  export type DeepWorkTaskMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    description: string | null
    priority: $Enums.Priority | null
    completed: boolean | null
    originalDate: string | null
    currentDate: string | null
    estimatedDuration: number | null
    focusBlocks: number | null
    breakDuration: number | null
    interruptionMode: boolean | null
    rollovers: number | null
    category: string | null
    createdAt: Date | null
    updatedAt: Date | null
    completedAt: Date | null
    startedAt: Date | null
    actualDurationMin: number | null
    timeEstimate: string | null
    aiAnalyzed: boolean | null
    aiReasoning: string | null
    analyzedAt: Date | null
    xpReward: number | null
    complexity: number | null
    confidence: number | null
    contextualBonus: number | null
    difficulty: number | null
    learningValue: number | null
    priorityRank: number | null
    strategicImportance: number | null
    timeAccuracy: number | null
  }

  export type DeepWorkTaskCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    description: number
    priority: number
    completed: number
    originalDate: number
    currentDate: number
    estimatedDuration: number
    focusBlocks: number
    breakDuration: number
    interruptionMode: number
    rollovers: number
    tags: number
    category: number
    createdAt: number
    updatedAt: number
    completedAt: number
    startedAt: number
    actualDurationMin: number
    timeEstimate: number
    aiAnalyzed: number
    aiReasoning: number
    analyzedAt: number
    xpReward: number
    complexity: number
    confidence: number
    contextualBonus: number
    difficulty: number
    learningValue: number
    priorityRank: number
    strategicImportance: number
    timeAccuracy: number
    _all: number
  }


  export type DeepWorkTaskAvgAggregateInputType = {
    estimatedDuration?: true
    focusBlocks?: true
    breakDuration?: true
    rollovers?: true
    actualDurationMin?: true
    xpReward?: true
    complexity?: true
    confidence?: true
    contextualBonus?: true
    difficulty?: true
    learningValue?: true
    priorityRank?: true
    strategicImportance?: true
    timeAccuracy?: true
  }

  export type DeepWorkTaskSumAggregateInputType = {
    estimatedDuration?: true
    focusBlocks?: true
    breakDuration?: true
    rollovers?: true
    actualDurationMin?: true
    xpReward?: true
    complexity?: true
    confidence?: true
    contextualBonus?: true
    difficulty?: true
    learningValue?: true
    priorityRank?: true
    strategicImportance?: true
    timeAccuracy?: true
  }

  export type DeepWorkTaskMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    priority?: true
    completed?: true
    originalDate?: true
    currentDate?: true
    estimatedDuration?: true
    focusBlocks?: true
    breakDuration?: true
    interruptionMode?: true
    rollovers?: true
    category?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
    startedAt?: true
    actualDurationMin?: true
    timeEstimate?: true
    aiAnalyzed?: true
    aiReasoning?: true
    analyzedAt?: true
    xpReward?: true
    complexity?: true
    confidence?: true
    contextualBonus?: true
    difficulty?: true
    learningValue?: true
    priorityRank?: true
    strategicImportance?: true
    timeAccuracy?: true
  }

  export type DeepWorkTaskMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    priority?: true
    completed?: true
    originalDate?: true
    currentDate?: true
    estimatedDuration?: true
    focusBlocks?: true
    breakDuration?: true
    interruptionMode?: true
    rollovers?: true
    category?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
    startedAt?: true
    actualDurationMin?: true
    timeEstimate?: true
    aiAnalyzed?: true
    aiReasoning?: true
    analyzedAt?: true
    xpReward?: true
    complexity?: true
    confidence?: true
    contextualBonus?: true
    difficulty?: true
    learningValue?: true
    priorityRank?: true
    strategicImportance?: true
    timeAccuracy?: true
  }

  export type DeepWorkTaskCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    priority?: true
    completed?: true
    originalDate?: true
    currentDate?: true
    estimatedDuration?: true
    focusBlocks?: true
    breakDuration?: true
    interruptionMode?: true
    rollovers?: true
    tags?: true
    category?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
    startedAt?: true
    actualDurationMin?: true
    timeEstimate?: true
    aiAnalyzed?: true
    aiReasoning?: true
    analyzedAt?: true
    xpReward?: true
    complexity?: true
    confidence?: true
    contextualBonus?: true
    difficulty?: true
    learningValue?: true
    priorityRank?: true
    strategicImportance?: true
    timeAccuracy?: true
    _all?: true
  }

  export type DeepWorkTaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeepWorkTask to aggregate.
     */
    where?: DeepWorkTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeepWorkTasks to fetch.
     */
    orderBy?: DeepWorkTaskOrderByWithRelationInput | DeepWorkTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeepWorkTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeepWorkTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeepWorkTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeepWorkTasks
    **/
    _count?: true | DeepWorkTaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeepWorkTaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeepWorkTaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeepWorkTaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeepWorkTaskMaxAggregateInputType
  }

  export type GetDeepWorkTaskAggregateType<T extends DeepWorkTaskAggregateArgs> = {
        [P in keyof T & keyof AggregateDeepWorkTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeepWorkTask[P]>
      : GetScalarType<T[P], AggregateDeepWorkTask[P]>
  }




  export type DeepWorkTaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeepWorkTaskWhereInput
    orderBy?: DeepWorkTaskOrderByWithAggregationInput | DeepWorkTaskOrderByWithAggregationInput[]
    by: DeepWorkTaskScalarFieldEnum[] | DeepWorkTaskScalarFieldEnum
    having?: DeepWorkTaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeepWorkTaskCountAggregateInputType | true
    _avg?: DeepWorkTaskAvgAggregateInputType
    _sum?: DeepWorkTaskSumAggregateInputType
    _min?: DeepWorkTaskMinAggregateInputType
    _max?: DeepWorkTaskMaxAggregateInputType
  }

  export type DeepWorkTaskGroupByOutputType = {
    id: string
    userId: string
    title: string
    description: string | null
    priority: $Enums.Priority
    completed: boolean
    originalDate: string
    currentDate: string
    estimatedDuration: number | null
    focusBlocks: number
    breakDuration: number
    interruptionMode: boolean
    rollovers: number
    tags: string[]
    category: string | null
    createdAt: Date
    updatedAt: Date
    completedAt: Date | null
    startedAt: Date | null
    actualDurationMin: number | null
    timeEstimate: string | null
    aiAnalyzed: boolean
    aiReasoning: string | null
    analyzedAt: Date | null
    xpReward: number | null
    complexity: number | null
    confidence: number | null
    contextualBonus: number | null
    difficulty: number | null
    learningValue: number | null
    priorityRank: number | null
    strategicImportance: number | null
    timeAccuracy: number | null
    _count: DeepWorkTaskCountAggregateOutputType | null
    _avg: DeepWorkTaskAvgAggregateOutputType | null
    _sum: DeepWorkTaskSumAggregateOutputType | null
    _min: DeepWorkTaskMinAggregateOutputType | null
    _max: DeepWorkTaskMaxAggregateOutputType | null
  }

  type GetDeepWorkTaskGroupByPayload<T extends DeepWorkTaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeepWorkTaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeepWorkTaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeepWorkTaskGroupByOutputType[P]>
            : GetScalarType<T[P], DeepWorkTaskGroupByOutputType[P]>
        }
      >
    >


  export type DeepWorkTaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    priority?: boolean
    completed?: boolean
    originalDate?: boolean
    currentDate?: boolean
    estimatedDuration?: boolean
    focusBlocks?: boolean
    breakDuration?: boolean
    interruptionMode?: boolean
    rollovers?: boolean
    tags?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    startedAt?: boolean
    actualDurationMin?: boolean
    timeEstimate?: boolean
    aiAnalyzed?: boolean
    aiReasoning?: boolean
    analyzedAt?: boolean
    xpReward?: boolean
    complexity?: boolean
    confidence?: boolean
    contextualBonus?: boolean
    difficulty?: boolean
    learningValue?: boolean
    priorityRank?: boolean
    strategicImportance?: boolean
    timeAccuracy?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    subtasks?: boolean | DeepWorkTask$subtasksArgs<ExtArgs>
    _count?: boolean | DeepWorkTaskCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deepWorkTask"]>

  export type DeepWorkTaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    priority?: boolean
    completed?: boolean
    originalDate?: boolean
    currentDate?: boolean
    estimatedDuration?: boolean
    focusBlocks?: boolean
    breakDuration?: boolean
    interruptionMode?: boolean
    rollovers?: boolean
    tags?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    startedAt?: boolean
    actualDurationMin?: boolean
    timeEstimate?: boolean
    aiAnalyzed?: boolean
    aiReasoning?: boolean
    analyzedAt?: boolean
    xpReward?: boolean
    complexity?: boolean
    confidence?: boolean
    contextualBonus?: boolean
    difficulty?: boolean
    learningValue?: boolean
    priorityRank?: boolean
    strategicImportance?: boolean
    timeAccuracy?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deepWorkTask"]>

  export type DeepWorkTaskSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    priority?: boolean
    completed?: boolean
    originalDate?: boolean
    currentDate?: boolean
    estimatedDuration?: boolean
    focusBlocks?: boolean
    breakDuration?: boolean
    interruptionMode?: boolean
    rollovers?: boolean
    tags?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    startedAt?: boolean
    actualDurationMin?: boolean
    timeEstimate?: boolean
    aiAnalyzed?: boolean
    aiReasoning?: boolean
    analyzedAt?: boolean
    xpReward?: boolean
    complexity?: boolean
    confidence?: boolean
    contextualBonus?: boolean
    difficulty?: boolean
    learningValue?: boolean
    priorityRank?: boolean
    strategicImportance?: boolean
    timeAccuracy?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deepWorkTask"]>

  export type DeepWorkTaskSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    priority?: boolean
    completed?: boolean
    originalDate?: boolean
    currentDate?: boolean
    estimatedDuration?: boolean
    focusBlocks?: boolean
    breakDuration?: boolean
    interruptionMode?: boolean
    rollovers?: boolean
    tags?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    startedAt?: boolean
    actualDurationMin?: boolean
    timeEstimate?: boolean
    aiAnalyzed?: boolean
    aiReasoning?: boolean
    analyzedAt?: boolean
    xpReward?: boolean
    complexity?: boolean
    confidence?: boolean
    contextualBonus?: boolean
    difficulty?: boolean
    learningValue?: boolean
    priorityRank?: boolean
    strategicImportance?: boolean
    timeAccuracy?: boolean
  }

  export type DeepWorkTaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "title" | "description" | "priority" | "completed" | "originalDate" | "currentDate" | "estimatedDuration" | "focusBlocks" | "breakDuration" | "interruptionMode" | "rollovers" | "tags" | "category" | "createdAt" | "updatedAt" | "completedAt" | "startedAt" | "actualDurationMin" | "timeEstimate" | "aiAnalyzed" | "aiReasoning" | "analyzedAt" | "xpReward" | "complexity" | "confidence" | "contextualBonus" | "difficulty" | "learningValue" | "priorityRank" | "strategicImportance" | "timeAccuracy", ExtArgs["result"]["deepWorkTask"]>
  export type DeepWorkTaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    subtasks?: boolean | DeepWorkTask$subtasksArgs<ExtArgs>
    _count?: boolean | DeepWorkTaskCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DeepWorkTaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DeepWorkTaskIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DeepWorkTaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeepWorkTask"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      subtasks: Prisma.$DeepWorkSubtaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      description: string | null
      priority: $Enums.Priority
      completed: boolean
      originalDate: string
      currentDate: string
      estimatedDuration: number | null
      focusBlocks: number
      breakDuration: number
      interruptionMode: boolean
      rollovers: number
      tags: string[]
      category: string | null
      createdAt: Date
      updatedAt: Date
      completedAt: Date | null
      startedAt: Date | null
      actualDurationMin: number | null
      timeEstimate: string | null
      aiAnalyzed: boolean
      aiReasoning: string | null
      analyzedAt: Date | null
      xpReward: number | null
      complexity: number | null
      confidence: number | null
      contextualBonus: number | null
      difficulty: number | null
      learningValue: number | null
      priorityRank: number | null
      strategicImportance: number | null
      timeAccuracy: number | null
    }, ExtArgs["result"]["deepWorkTask"]>
    composites: {}
  }

  type DeepWorkTaskGetPayload<S extends boolean | null | undefined | DeepWorkTaskDefaultArgs> = $Result.GetResult<Prisma.$DeepWorkTaskPayload, S>

  type DeepWorkTaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeepWorkTaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeepWorkTaskCountAggregateInputType | true
    }

  export interface DeepWorkTaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeepWorkTask'], meta: { name: 'DeepWorkTask' } }
    /**
     * Find zero or one DeepWorkTask that matches the filter.
     * @param {DeepWorkTaskFindUniqueArgs} args - Arguments to find a DeepWorkTask
     * @example
     * // Get one DeepWorkTask
     * const deepWorkTask = await prisma.deepWorkTask.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeepWorkTaskFindUniqueArgs>(args: SelectSubset<T, DeepWorkTaskFindUniqueArgs<ExtArgs>>): Prisma__DeepWorkTaskClient<$Result.GetResult<Prisma.$DeepWorkTaskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeepWorkTask that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeepWorkTaskFindUniqueOrThrowArgs} args - Arguments to find a DeepWorkTask
     * @example
     * // Get one DeepWorkTask
     * const deepWorkTask = await prisma.deepWorkTask.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeepWorkTaskFindUniqueOrThrowArgs>(args: SelectSubset<T, DeepWorkTaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeepWorkTaskClient<$Result.GetResult<Prisma.$DeepWorkTaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeepWorkTask that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeepWorkTaskFindFirstArgs} args - Arguments to find a DeepWorkTask
     * @example
     * // Get one DeepWorkTask
     * const deepWorkTask = await prisma.deepWorkTask.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeepWorkTaskFindFirstArgs>(args?: SelectSubset<T, DeepWorkTaskFindFirstArgs<ExtArgs>>): Prisma__DeepWorkTaskClient<$Result.GetResult<Prisma.$DeepWorkTaskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeepWorkTask that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeepWorkTaskFindFirstOrThrowArgs} args - Arguments to find a DeepWorkTask
     * @example
     * // Get one DeepWorkTask
     * const deepWorkTask = await prisma.deepWorkTask.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeepWorkTaskFindFirstOrThrowArgs>(args?: SelectSubset<T, DeepWorkTaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeepWorkTaskClient<$Result.GetResult<Prisma.$DeepWorkTaskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeepWorkTasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeepWorkTaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeepWorkTasks
     * const deepWorkTasks = await prisma.deepWorkTask.findMany()
     * 
     * // Get first 10 DeepWorkTasks
     * const deepWorkTasks = await prisma.deepWorkTask.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deepWorkTaskWithIdOnly = await prisma.deepWorkTask.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeepWorkTaskFindManyArgs>(args?: SelectSubset<T, DeepWorkTaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeepWorkTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeepWorkTask.
     * @param {DeepWorkTaskCreateArgs} args - Arguments to create a DeepWorkTask.
     * @example
     * // Create one DeepWorkTask
     * const DeepWorkTask = await prisma.deepWorkTask.create({
     *   data: {
     *     // ... data to create a DeepWorkTask
     *   }
     * })
     * 
     */
    create<T extends DeepWorkTaskCreateArgs>(args: SelectSubset<T, DeepWorkTaskCreateArgs<ExtArgs>>): Prisma__DeepWorkTaskClient<$Result.GetResult<Prisma.$DeepWorkTaskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeepWorkTasks.
     * @param {DeepWorkTaskCreateManyArgs} args - Arguments to create many DeepWorkTasks.
     * @example
     * // Create many DeepWorkTasks
     * const deepWorkTask = await prisma.deepWorkTask.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeepWorkTaskCreateManyArgs>(args?: SelectSubset<T, DeepWorkTaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeepWorkTasks and returns the data saved in the database.
     * @param {DeepWorkTaskCreateManyAndReturnArgs} args - Arguments to create many DeepWorkTasks.
     * @example
     * // Create many DeepWorkTasks
     * const deepWorkTask = await prisma.deepWorkTask.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeepWorkTasks and only return the `id`
     * const deepWorkTaskWithIdOnly = await prisma.deepWorkTask.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeepWorkTaskCreateManyAndReturnArgs>(args?: SelectSubset<T, DeepWorkTaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeepWorkTaskPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DeepWorkTask.
     * @param {DeepWorkTaskDeleteArgs} args - Arguments to delete one DeepWorkTask.
     * @example
     * // Delete one DeepWorkTask
     * const DeepWorkTask = await prisma.deepWorkTask.delete({
     *   where: {
     *     // ... filter to delete one DeepWorkTask
     *   }
     * })
     * 
     */
    delete<T extends DeepWorkTaskDeleteArgs>(args: SelectSubset<T, DeepWorkTaskDeleteArgs<ExtArgs>>): Prisma__DeepWorkTaskClient<$Result.GetResult<Prisma.$DeepWorkTaskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeepWorkTask.
     * @param {DeepWorkTaskUpdateArgs} args - Arguments to update one DeepWorkTask.
     * @example
     * // Update one DeepWorkTask
     * const deepWorkTask = await prisma.deepWorkTask.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeepWorkTaskUpdateArgs>(args: SelectSubset<T, DeepWorkTaskUpdateArgs<ExtArgs>>): Prisma__DeepWorkTaskClient<$Result.GetResult<Prisma.$DeepWorkTaskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeepWorkTasks.
     * @param {DeepWorkTaskDeleteManyArgs} args - Arguments to filter DeepWorkTasks to delete.
     * @example
     * // Delete a few DeepWorkTasks
     * const { count } = await prisma.deepWorkTask.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeepWorkTaskDeleteManyArgs>(args?: SelectSubset<T, DeepWorkTaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeepWorkTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeepWorkTaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeepWorkTasks
     * const deepWorkTask = await prisma.deepWorkTask.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeepWorkTaskUpdateManyArgs>(args: SelectSubset<T, DeepWorkTaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeepWorkTasks and returns the data updated in the database.
     * @param {DeepWorkTaskUpdateManyAndReturnArgs} args - Arguments to update many DeepWorkTasks.
     * @example
     * // Update many DeepWorkTasks
     * const deepWorkTask = await prisma.deepWorkTask.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DeepWorkTasks and only return the `id`
     * const deepWorkTaskWithIdOnly = await prisma.deepWorkTask.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeepWorkTaskUpdateManyAndReturnArgs>(args: SelectSubset<T, DeepWorkTaskUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeepWorkTaskPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DeepWorkTask.
     * @param {DeepWorkTaskUpsertArgs} args - Arguments to update or create a DeepWorkTask.
     * @example
     * // Update or create a DeepWorkTask
     * const deepWorkTask = await prisma.deepWorkTask.upsert({
     *   create: {
     *     // ... data to create a DeepWorkTask
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeepWorkTask we want to update
     *   }
     * })
     */
    upsert<T extends DeepWorkTaskUpsertArgs>(args: SelectSubset<T, DeepWorkTaskUpsertArgs<ExtArgs>>): Prisma__DeepWorkTaskClient<$Result.GetResult<Prisma.$DeepWorkTaskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DeepWorkTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeepWorkTaskCountArgs} args - Arguments to filter DeepWorkTasks to count.
     * @example
     * // Count the number of DeepWorkTasks
     * const count = await prisma.deepWorkTask.count({
     *   where: {
     *     // ... the filter for the DeepWorkTasks we want to count
     *   }
     * })
    **/
    count<T extends DeepWorkTaskCountArgs>(
      args?: Subset<T, DeepWorkTaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeepWorkTaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeepWorkTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeepWorkTaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeepWorkTaskAggregateArgs>(args: Subset<T, DeepWorkTaskAggregateArgs>): Prisma.PrismaPromise<GetDeepWorkTaskAggregateType<T>>

    /**
     * Group by DeepWorkTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeepWorkTaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeepWorkTaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeepWorkTaskGroupByArgs['orderBy'] }
        : { orderBy?: DeepWorkTaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeepWorkTaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeepWorkTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeepWorkTask model
   */
  readonly fields: DeepWorkTaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeepWorkTask.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeepWorkTaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subtasks<T extends DeepWorkTask$subtasksArgs<ExtArgs> = {}>(args?: Subset<T, DeepWorkTask$subtasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeepWorkSubtaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeepWorkTask model
   */
  interface DeepWorkTaskFieldRefs {
    readonly id: FieldRef<"DeepWorkTask", 'String'>
    readonly userId: FieldRef<"DeepWorkTask", 'String'>
    readonly title: FieldRef<"DeepWorkTask", 'String'>
    readonly description: FieldRef<"DeepWorkTask", 'String'>
    readonly priority: FieldRef<"DeepWorkTask", 'Priority'>
    readonly completed: FieldRef<"DeepWorkTask", 'Boolean'>
    readonly originalDate: FieldRef<"DeepWorkTask", 'String'>
    readonly currentDate: FieldRef<"DeepWorkTask", 'String'>
    readonly estimatedDuration: FieldRef<"DeepWorkTask", 'Int'>
    readonly focusBlocks: FieldRef<"DeepWorkTask", 'Int'>
    readonly breakDuration: FieldRef<"DeepWorkTask", 'Int'>
    readonly interruptionMode: FieldRef<"DeepWorkTask", 'Boolean'>
    readonly rollovers: FieldRef<"DeepWorkTask", 'Int'>
    readonly tags: FieldRef<"DeepWorkTask", 'String[]'>
    readonly category: FieldRef<"DeepWorkTask", 'String'>
    readonly createdAt: FieldRef<"DeepWorkTask", 'DateTime'>
    readonly updatedAt: FieldRef<"DeepWorkTask", 'DateTime'>
    readonly completedAt: FieldRef<"DeepWorkTask", 'DateTime'>
    readonly startedAt: FieldRef<"DeepWorkTask", 'DateTime'>
    readonly actualDurationMin: FieldRef<"DeepWorkTask", 'Int'>
    readonly timeEstimate: FieldRef<"DeepWorkTask", 'String'>
    readonly aiAnalyzed: FieldRef<"DeepWorkTask", 'Boolean'>
    readonly aiReasoning: FieldRef<"DeepWorkTask", 'String'>
    readonly analyzedAt: FieldRef<"DeepWorkTask", 'DateTime'>
    readonly xpReward: FieldRef<"DeepWorkTask", 'Int'>
    readonly complexity: FieldRef<"DeepWorkTask", 'Int'>
    readonly confidence: FieldRef<"DeepWorkTask", 'Float'>
    readonly contextualBonus: FieldRef<"DeepWorkTask", 'Float'>
    readonly difficulty: FieldRef<"DeepWorkTask", 'Int'>
    readonly learningValue: FieldRef<"DeepWorkTask", 'Int'>
    readonly priorityRank: FieldRef<"DeepWorkTask", 'Int'>
    readonly strategicImportance: FieldRef<"DeepWorkTask", 'Int'>
    readonly timeAccuracy: FieldRef<"DeepWorkTask", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * DeepWorkTask findUnique
   */
  export type DeepWorkTaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeepWorkTask
     */
    select?: DeepWorkTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeepWorkTask
     */
    omit?: DeepWorkTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeepWorkTaskInclude<ExtArgs> | null
    /**
     * Filter, which DeepWorkTask to fetch.
     */
    where: DeepWorkTaskWhereUniqueInput
  }

  /**
   * DeepWorkTask findUniqueOrThrow
   */
  export type DeepWorkTaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeepWorkTask
     */
    select?: DeepWorkTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeepWorkTask
     */
    omit?: DeepWorkTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeepWorkTaskInclude<ExtArgs> | null
    /**
     * Filter, which DeepWorkTask to fetch.
     */
    where: DeepWorkTaskWhereUniqueInput
  }

  /**
   * DeepWorkTask findFirst
   */
  export type DeepWorkTaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeepWorkTask
     */
    select?: DeepWorkTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeepWorkTask
     */
    omit?: DeepWorkTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeepWorkTaskInclude<ExtArgs> | null
    /**
     * Filter, which DeepWorkTask to fetch.
     */
    where?: DeepWorkTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeepWorkTasks to fetch.
     */
    orderBy?: DeepWorkTaskOrderByWithRelationInput | DeepWorkTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeepWorkTasks.
     */
    cursor?: DeepWorkTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeepWorkTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeepWorkTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeepWorkTasks.
     */
    distinct?: DeepWorkTaskScalarFieldEnum | DeepWorkTaskScalarFieldEnum[]
  }

  /**
   * DeepWorkTask findFirstOrThrow
   */
  export type DeepWorkTaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeepWorkTask
     */
    select?: DeepWorkTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeepWorkTask
     */
    omit?: DeepWorkTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeepWorkTaskInclude<ExtArgs> | null
    /**
     * Filter, which DeepWorkTask to fetch.
     */
    where?: DeepWorkTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeepWorkTasks to fetch.
     */
    orderBy?: DeepWorkTaskOrderByWithRelationInput | DeepWorkTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeepWorkTasks.
     */
    cursor?: DeepWorkTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeepWorkTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeepWorkTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeepWorkTasks.
     */
    distinct?: DeepWorkTaskScalarFieldEnum | DeepWorkTaskScalarFieldEnum[]
  }

  /**
   * DeepWorkTask findMany
   */
  export type DeepWorkTaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeepWorkTask
     */
    select?: DeepWorkTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeepWorkTask
     */
    omit?: DeepWorkTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeepWorkTaskInclude<ExtArgs> | null
    /**
     * Filter, which DeepWorkTasks to fetch.
     */
    where?: DeepWorkTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeepWorkTasks to fetch.
     */
    orderBy?: DeepWorkTaskOrderByWithRelationInput | DeepWorkTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeepWorkTasks.
     */
    cursor?: DeepWorkTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeepWorkTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeepWorkTasks.
     */
    skip?: number
    distinct?: DeepWorkTaskScalarFieldEnum | DeepWorkTaskScalarFieldEnum[]
  }

  /**
   * DeepWorkTask create
   */
  export type DeepWorkTaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeepWorkTask
     */
    select?: DeepWorkTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeepWorkTask
     */
    omit?: DeepWorkTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeepWorkTaskInclude<ExtArgs> | null
    /**
     * The data needed to create a DeepWorkTask.
     */
    data: XOR<DeepWorkTaskCreateInput, DeepWorkTaskUncheckedCreateInput>
  }

  /**
   * DeepWorkTask createMany
   */
  export type DeepWorkTaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeepWorkTasks.
     */
    data: DeepWorkTaskCreateManyInput | DeepWorkTaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeepWorkTask createManyAndReturn
   */
  export type DeepWorkTaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeepWorkTask
     */
    select?: DeepWorkTaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeepWorkTask
     */
    omit?: DeepWorkTaskOmit<ExtArgs> | null
    /**
     * The data used to create many DeepWorkTasks.
     */
    data: DeepWorkTaskCreateManyInput | DeepWorkTaskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeepWorkTaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeepWorkTask update
   */
  export type DeepWorkTaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeepWorkTask
     */
    select?: DeepWorkTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeepWorkTask
     */
    omit?: DeepWorkTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeepWorkTaskInclude<ExtArgs> | null
    /**
     * The data needed to update a DeepWorkTask.
     */
    data: XOR<DeepWorkTaskUpdateInput, DeepWorkTaskUncheckedUpdateInput>
    /**
     * Choose, which DeepWorkTask to update.
     */
    where: DeepWorkTaskWhereUniqueInput
  }

  /**
   * DeepWorkTask updateMany
   */
  export type DeepWorkTaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeepWorkTasks.
     */
    data: XOR<DeepWorkTaskUpdateManyMutationInput, DeepWorkTaskUncheckedUpdateManyInput>
    /**
     * Filter which DeepWorkTasks to update
     */
    where?: DeepWorkTaskWhereInput
    /**
     * Limit how many DeepWorkTasks to update.
     */
    limit?: number
  }

  /**
   * DeepWorkTask updateManyAndReturn
   */
  export type DeepWorkTaskUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeepWorkTask
     */
    select?: DeepWorkTaskSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeepWorkTask
     */
    omit?: DeepWorkTaskOmit<ExtArgs> | null
    /**
     * The data used to update DeepWorkTasks.
     */
    data: XOR<DeepWorkTaskUpdateManyMutationInput, DeepWorkTaskUncheckedUpdateManyInput>
    /**
     * Filter which DeepWorkTasks to update
     */
    where?: DeepWorkTaskWhereInput
    /**
     * Limit how many DeepWorkTasks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeepWorkTaskIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeepWorkTask upsert
   */
  export type DeepWorkTaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeepWorkTask
     */
    select?: DeepWorkTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeepWorkTask
     */
    omit?: DeepWorkTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeepWorkTaskInclude<ExtArgs> | null
    /**
     * The filter to search for the DeepWorkTask to update in case it exists.
     */
    where: DeepWorkTaskWhereUniqueInput
    /**
     * In case the DeepWorkTask found by the `where` argument doesn't exist, create a new DeepWorkTask with this data.
     */
    create: XOR<DeepWorkTaskCreateInput, DeepWorkTaskUncheckedCreateInput>
    /**
     * In case the DeepWorkTask was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeepWorkTaskUpdateInput, DeepWorkTaskUncheckedUpdateInput>
  }

  /**
   * DeepWorkTask delete
   */
  export type DeepWorkTaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeepWorkTask
     */
    select?: DeepWorkTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeepWorkTask
     */
    omit?: DeepWorkTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeepWorkTaskInclude<ExtArgs> | null
    /**
     * Filter which DeepWorkTask to delete.
     */
    where: DeepWorkTaskWhereUniqueInput
  }

  /**
   * DeepWorkTask deleteMany
   */
  export type DeepWorkTaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeepWorkTasks to delete
     */
    where?: DeepWorkTaskWhereInput
    /**
     * Limit how many DeepWorkTasks to delete.
     */
    limit?: number
  }

  /**
   * DeepWorkTask.subtasks
   */
  export type DeepWorkTask$subtasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeepWorkSubtask
     */
    select?: DeepWorkSubtaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeepWorkSubtask
     */
    omit?: DeepWorkSubtaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeepWorkSubtaskInclude<ExtArgs> | null
    where?: DeepWorkSubtaskWhereInput
    orderBy?: DeepWorkSubtaskOrderByWithRelationInput | DeepWorkSubtaskOrderByWithRelationInput[]
    cursor?: DeepWorkSubtaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeepWorkSubtaskScalarFieldEnum | DeepWorkSubtaskScalarFieldEnum[]
  }

  /**
   * DeepWorkTask without action
   */
  export type DeepWorkTaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeepWorkTask
     */
    select?: DeepWorkTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeepWorkTask
     */
    omit?: DeepWorkTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeepWorkTaskInclude<ExtArgs> | null
  }


  /**
   * Model DeepWorkSubtask
   */

  export type AggregateDeepWorkSubtask = {
    _count: DeepWorkSubtaskCountAggregateOutputType | null
    _avg: DeepWorkSubtaskAvgAggregateOutputType | null
    _sum: DeepWorkSubtaskSumAggregateOutputType | null
    _min: DeepWorkSubtaskMinAggregateOutputType | null
    _max: DeepWorkSubtaskMaxAggregateOutputType | null
  }

  export type DeepWorkSubtaskAvgAggregateOutputType = {
    complexityLevel: number | null
    actualDurationMin: number | null
    timeAccuracy: number | null
    xpReward: number | null
    complexity: number | null
    confidence: number | null
    contextualBonus: number | null
    difficulty: number | null
    learningValue: number | null
    priorityRank: number | null
    strategicImportance: number | null
  }

  export type DeepWorkSubtaskSumAggregateOutputType = {
    complexityLevel: number | null
    actualDurationMin: number | null
    timeAccuracy: number | null
    xpReward: number | null
    complexity: number | null
    confidence: number | null
    contextualBonus: number | null
    difficulty: number | null
    learningValue: number | null
    priorityRank: number | null
    strategicImportance: number | null
  }

  export type DeepWorkSubtaskMinAggregateOutputType = {
    id: string | null
    taskId: string | null
    title: string | null
    text: string | null
    completed: boolean | null
    priority: string | null
    dueDate: Date | null
    requiresFocus: boolean | null
    complexityLevel: number | null
    createdAt: Date | null
    updatedAt: Date | null
    completedAt: Date | null
    startedAt: Date | null
    actualDurationMin: number | null
    timeAccuracy: number | null
    aiAnalyzed: boolean | null
    aiReasoning: string | null
    analyzedAt: Date | null
    xpReward: number | null
    complexity: number | null
    confidence: number | null
    contextualBonus: number | null
    difficulty: number | null
    learningValue: number | null
    priorityRank: number | null
    strategicImportance: number | null
  }

  export type DeepWorkSubtaskMaxAggregateOutputType = {
    id: string | null
    taskId: string | null
    title: string | null
    text: string | null
    completed: boolean | null
    priority: string | null
    dueDate: Date | null
    requiresFocus: boolean | null
    complexityLevel: number | null
    createdAt: Date | null
    updatedAt: Date | null
    completedAt: Date | null
    startedAt: Date | null
    actualDurationMin: number | null
    timeAccuracy: number | null
    aiAnalyzed: boolean | null
    aiReasoning: string | null
    analyzedAt: Date | null
    xpReward: number | null
    complexity: number | null
    confidence: number | null
    contextualBonus: number | null
    difficulty: number | null
    learningValue: number | null
    priorityRank: number | null
    strategicImportance: number | null
  }

  export type DeepWorkSubtaskCountAggregateOutputType = {
    id: number
    taskId: number
    title: number
    text: number
    completed: number
    priority: number
    dueDate: number
    requiresFocus: number
    complexityLevel: number
    createdAt: number
    updatedAt: number
    completedAt: number
    startedAt: number
    actualDurationMin: number
    timeAccuracy: number
    aiAnalyzed: number
    aiReasoning: number
    analyzedAt: number
    xpReward: number
    complexity: number
    confidence: number
    contextualBonus: number
    difficulty: number
    learningValue: number
    priorityRank: number
    strategicImportance: number
    _all: number
  }


  export type DeepWorkSubtaskAvgAggregateInputType = {
    complexityLevel?: true
    actualDurationMin?: true
    timeAccuracy?: true
    xpReward?: true
    complexity?: true
    confidence?: true
    contextualBonus?: true
    difficulty?: true
    learningValue?: true
    priorityRank?: true
    strategicImportance?: true
  }

  export type DeepWorkSubtaskSumAggregateInputType = {
    complexityLevel?: true
    actualDurationMin?: true
    timeAccuracy?: true
    xpReward?: true
    complexity?: true
    confidence?: true
    contextualBonus?: true
    difficulty?: true
    learningValue?: true
    priorityRank?: true
    strategicImportance?: true
  }

  export type DeepWorkSubtaskMinAggregateInputType = {
    id?: true
    taskId?: true
    title?: true
    text?: true
    completed?: true
    priority?: true
    dueDate?: true
    requiresFocus?: true
    complexityLevel?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
    startedAt?: true
    actualDurationMin?: true
    timeAccuracy?: true
    aiAnalyzed?: true
    aiReasoning?: true
    analyzedAt?: true
    xpReward?: true
    complexity?: true
    confidence?: true
    contextualBonus?: true
    difficulty?: true
    learningValue?: true
    priorityRank?: true
    strategicImportance?: true
  }

  export type DeepWorkSubtaskMaxAggregateInputType = {
    id?: true
    taskId?: true
    title?: true
    text?: true
    completed?: true
    priority?: true
    dueDate?: true
    requiresFocus?: true
    complexityLevel?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
    startedAt?: true
    actualDurationMin?: true
    timeAccuracy?: true
    aiAnalyzed?: true
    aiReasoning?: true
    analyzedAt?: true
    xpReward?: true
    complexity?: true
    confidence?: true
    contextualBonus?: true
    difficulty?: true
    learningValue?: true
    priorityRank?: true
    strategicImportance?: true
  }

  export type DeepWorkSubtaskCountAggregateInputType = {
    id?: true
    taskId?: true
    title?: true
    text?: true
    completed?: true
    priority?: true
    dueDate?: true
    requiresFocus?: true
    complexityLevel?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
    startedAt?: true
    actualDurationMin?: true
    timeAccuracy?: true
    aiAnalyzed?: true
    aiReasoning?: true
    analyzedAt?: true
    xpReward?: true
    complexity?: true
    confidence?: true
    contextualBonus?: true
    difficulty?: true
    learningValue?: true
    priorityRank?: true
    strategicImportance?: true
    _all?: true
  }

  export type DeepWorkSubtaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeepWorkSubtask to aggregate.
     */
    where?: DeepWorkSubtaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeepWorkSubtasks to fetch.
     */
    orderBy?: DeepWorkSubtaskOrderByWithRelationInput | DeepWorkSubtaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeepWorkSubtaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeepWorkSubtasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeepWorkSubtasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeepWorkSubtasks
    **/
    _count?: true | DeepWorkSubtaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeepWorkSubtaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeepWorkSubtaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeepWorkSubtaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeepWorkSubtaskMaxAggregateInputType
  }

  export type GetDeepWorkSubtaskAggregateType<T extends DeepWorkSubtaskAggregateArgs> = {
        [P in keyof T & keyof AggregateDeepWorkSubtask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeepWorkSubtask[P]>
      : GetScalarType<T[P], AggregateDeepWorkSubtask[P]>
  }




  export type DeepWorkSubtaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeepWorkSubtaskWhereInput
    orderBy?: DeepWorkSubtaskOrderByWithAggregationInput | DeepWorkSubtaskOrderByWithAggregationInput[]
    by: DeepWorkSubtaskScalarFieldEnum[] | DeepWorkSubtaskScalarFieldEnum
    having?: DeepWorkSubtaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeepWorkSubtaskCountAggregateInputType | true
    _avg?: DeepWorkSubtaskAvgAggregateInputType
    _sum?: DeepWorkSubtaskSumAggregateInputType
    _min?: DeepWorkSubtaskMinAggregateInputType
    _max?: DeepWorkSubtaskMaxAggregateInputType
  }

  export type DeepWorkSubtaskGroupByOutputType = {
    id: string
    taskId: string
    title: string
    text: string
    completed: boolean
    priority: string | null
    dueDate: Date | null
    requiresFocus: boolean
    complexityLevel: number | null
    createdAt: Date
    updatedAt: Date
    completedAt: Date | null
    startedAt: Date | null
    actualDurationMin: number | null
    timeAccuracy: number | null
    aiAnalyzed: boolean
    aiReasoning: string | null
    analyzedAt: Date | null
    xpReward: number | null
    complexity: number | null
    confidence: number | null
    contextualBonus: number | null
    difficulty: number | null
    learningValue: number | null
    priorityRank: number | null
    strategicImportance: number | null
    _count: DeepWorkSubtaskCountAggregateOutputType | null
    _avg: DeepWorkSubtaskAvgAggregateOutputType | null
    _sum: DeepWorkSubtaskSumAggregateOutputType | null
    _min: DeepWorkSubtaskMinAggregateOutputType | null
    _max: DeepWorkSubtaskMaxAggregateOutputType | null
  }

  type GetDeepWorkSubtaskGroupByPayload<T extends DeepWorkSubtaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeepWorkSubtaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeepWorkSubtaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeepWorkSubtaskGroupByOutputType[P]>
            : GetScalarType<T[P], DeepWorkSubtaskGroupByOutputType[P]>
        }
      >
    >


  export type DeepWorkSubtaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    title?: boolean
    text?: boolean
    completed?: boolean
    priority?: boolean
    dueDate?: boolean
    requiresFocus?: boolean
    complexityLevel?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    startedAt?: boolean
    actualDurationMin?: boolean
    timeAccuracy?: boolean
    aiAnalyzed?: boolean
    aiReasoning?: boolean
    analyzedAt?: boolean
    xpReward?: boolean
    complexity?: boolean
    confidence?: boolean
    contextualBonus?: boolean
    difficulty?: boolean
    learningValue?: boolean
    priorityRank?: boolean
    strategicImportance?: boolean
    task?: boolean | DeepWorkTaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deepWorkSubtask"]>

  export type DeepWorkSubtaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    title?: boolean
    text?: boolean
    completed?: boolean
    priority?: boolean
    dueDate?: boolean
    requiresFocus?: boolean
    complexityLevel?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    startedAt?: boolean
    actualDurationMin?: boolean
    timeAccuracy?: boolean
    aiAnalyzed?: boolean
    aiReasoning?: boolean
    analyzedAt?: boolean
    xpReward?: boolean
    complexity?: boolean
    confidence?: boolean
    contextualBonus?: boolean
    difficulty?: boolean
    learningValue?: boolean
    priorityRank?: boolean
    strategicImportance?: boolean
    task?: boolean | DeepWorkTaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deepWorkSubtask"]>

  export type DeepWorkSubtaskSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    title?: boolean
    text?: boolean
    completed?: boolean
    priority?: boolean
    dueDate?: boolean
    requiresFocus?: boolean
    complexityLevel?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    startedAt?: boolean
    actualDurationMin?: boolean
    timeAccuracy?: boolean
    aiAnalyzed?: boolean
    aiReasoning?: boolean
    analyzedAt?: boolean
    xpReward?: boolean
    complexity?: boolean
    confidence?: boolean
    contextualBonus?: boolean
    difficulty?: boolean
    learningValue?: boolean
    priorityRank?: boolean
    strategicImportance?: boolean
    task?: boolean | DeepWorkTaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deepWorkSubtask"]>

  export type DeepWorkSubtaskSelectScalar = {
    id?: boolean
    taskId?: boolean
    title?: boolean
    text?: boolean
    completed?: boolean
    priority?: boolean
    dueDate?: boolean
    requiresFocus?: boolean
    complexityLevel?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    startedAt?: boolean
    actualDurationMin?: boolean
    timeAccuracy?: boolean
    aiAnalyzed?: boolean
    aiReasoning?: boolean
    analyzedAt?: boolean
    xpReward?: boolean
    complexity?: boolean
    confidence?: boolean
    contextualBonus?: boolean
    difficulty?: boolean
    learningValue?: boolean
    priorityRank?: boolean
    strategicImportance?: boolean
  }

  export type DeepWorkSubtaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "taskId" | "title" | "text" | "completed" | "priority" | "dueDate" | "requiresFocus" | "complexityLevel" | "createdAt" | "updatedAt" | "completedAt" | "startedAt" | "actualDurationMin" | "timeAccuracy" | "aiAnalyzed" | "aiReasoning" | "analyzedAt" | "xpReward" | "complexity" | "confidence" | "contextualBonus" | "difficulty" | "learningValue" | "priorityRank" | "strategicImportance", ExtArgs["result"]["deepWorkSubtask"]>
  export type DeepWorkSubtaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | DeepWorkTaskDefaultArgs<ExtArgs>
  }
  export type DeepWorkSubtaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | DeepWorkTaskDefaultArgs<ExtArgs>
  }
  export type DeepWorkSubtaskIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | DeepWorkTaskDefaultArgs<ExtArgs>
  }

  export type $DeepWorkSubtaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeepWorkSubtask"
    objects: {
      task: Prisma.$DeepWorkTaskPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      taskId: string
      title: string
      text: string
      completed: boolean
      priority: string | null
      dueDate: Date | null
      requiresFocus: boolean
      complexityLevel: number | null
      createdAt: Date
      updatedAt: Date
      completedAt: Date | null
      startedAt: Date | null
      actualDurationMin: number | null
      timeAccuracy: number | null
      aiAnalyzed: boolean
      aiReasoning: string | null
      analyzedAt: Date | null
      xpReward: number | null
      complexity: number | null
      confidence: number | null
      contextualBonus: number | null
      difficulty: number | null
      learningValue: number | null
      priorityRank: number | null
      strategicImportance: number | null
    }, ExtArgs["result"]["deepWorkSubtask"]>
    composites: {}
  }

  type DeepWorkSubtaskGetPayload<S extends boolean | null | undefined | DeepWorkSubtaskDefaultArgs> = $Result.GetResult<Prisma.$DeepWorkSubtaskPayload, S>

  type DeepWorkSubtaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeepWorkSubtaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeepWorkSubtaskCountAggregateInputType | true
    }

  export interface DeepWorkSubtaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeepWorkSubtask'], meta: { name: 'DeepWorkSubtask' } }
    /**
     * Find zero or one DeepWorkSubtask that matches the filter.
     * @param {DeepWorkSubtaskFindUniqueArgs} args - Arguments to find a DeepWorkSubtask
     * @example
     * // Get one DeepWorkSubtask
     * const deepWorkSubtask = await prisma.deepWorkSubtask.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeepWorkSubtaskFindUniqueArgs>(args: SelectSubset<T, DeepWorkSubtaskFindUniqueArgs<ExtArgs>>): Prisma__DeepWorkSubtaskClient<$Result.GetResult<Prisma.$DeepWorkSubtaskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeepWorkSubtask that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeepWorkSubtaskFindUniqueOrThrowArgs} args - Arguments to find a DeepWorkSubtask
     * @example
     * // Get one DeepWorkSubtask
     * const deepWorkSubtask = await prisma.deepWorkSubtask.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeepWorkSubtaskFindUniqueOrThrowArgs>(args: SelectSubset<T, DeepWorkSubtaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeepWorkSubtaskClient<$Result.GetResult<Prisma.$DeepWorkSubtaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeepWorkSubtask that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeepWorkSubtaskFindFirstArgs} args - Arguments to find a DeepWorkSubtask
     * @example
     * // Get one DeepWorkSubtask
     * const deepWorkSubtask = await prisma.deepWorkSubtask.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeepWorkSubtaskFindFirstArgs>(args?: SelectSubset<T, DeepWorkSubtaskFindFirstArgs<ExtArgs>>): Prisma__DeepWorkSubtaskClient<$Result.GetResult<Prisma.$DeepWorkSubtaskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeepWorkSubtask that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeepWorkSubtaskFindFirstOrThrowArgs} args - Arguments to find a DeepWorkSubtask
     * @example
     * // Get one DeepWorkSubtask
     * const deepWorkSubtask = await prisma.deepWorkSubtask.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeepWorkSubtaskFindFirstOrThrowArgs>(args?: SelectSubset<T, DeepWorkSubtaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeepWorkSubtaskClient<$Result.GetResult<Prisma.$DeepWorkSubtaskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeepWorkSubtasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeepWorkSubtaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeepWorkSubtasks
     * const deepWorkSubtasks = await prisma.deepWorkSubtask.findMany()
     * 
     * // Get first 10 DeepWorkSubtasks
     * const deepWorkSubtasks = await prisma.deepWorkSubtask.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deepWorkSubtaskWithIdOnly = await prisma.deepWorkSubtask.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeepWorkSubtaskFindManyArgs>(args?: SelectSubset<T, DeepWorkSubtaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeepWorkSubtaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeepWorkSubtask.
     * @param {DeepWorkSubtaskCreateArgs} args - Arguments to create a DeepWorkSubtask.
     * @example
     * // Create one DeepWorkSubtask
     * const DeepWorkSubtask = await prisma.deepWorkSubtask.create({
     *   data: {
     *     // ... data to create a DeepWorkSubtask
     *   }
     * })
     * 
     */
    create<T extends DeepWorkSubtaskCreateArgs>(args: SelectSubset<T, DeepWorkSubtaskCreateArgs<ExtArgs>>): Prisma__DeepWorkSubtaskClient<$Result.GetResult<Prisma.$DeepWorkSubtaskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeepWorkSubtasks.
     * @param {DeepWorkSubtaskCreateManyArgs} args - Arguments to create many DeepWorkSubtasks.
     * @example
     * // Create many DeepWorkSubtasks
     * const deepWorkSubtask = await prisma.deepWorkSubtask.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeepWorkSubtaskCreateManyArgs>(args?: SelectSubset<T, DeepWorkSubtaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeepWorkSubtasks and returns the data saved in the database.
     * @param {DeepWorkSubtaskCreateManyAndReturnArgs} args - Arguments to create many DeepWorkSubtasks.
     * @example
     * // Create many DeepWorkSubtasks
     * const deepWorkSubtask = await prisma.deepWorkSubtask.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeepWorkSubtasks and only return the `id`
     * const deepWorkSubtaskWithIdOnly = await prisma.deepWorkSubtask.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeepWorkSubtaskCreateManyAndReturnArgs>(args?: SelectSubset<T, DeepWorkSubtaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeepWorkSubtaskPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DeepWorkSubtask.
     * @param {DeepWorkSubtaskDeleteArgs} args - Arguments to delete one DeepWorkSubtask.
     * @example
     * // Delete one DeepWorkSubtask
     * const DeepWorkSubtask = await prisma.deepWorkSubtask.delete({
     *   where: {
     *     // ... filter to delete one DeepWorkSubtask
     *   }
     * })
     * 
     */
    delete<T extends DeepWorkSubtaskDeleteArgs>(args: SelectSubset<T, DeepWorkSubtaskDeleteArgs<ExtArgs>>): Prisma__DeepWorkSubtaskClient<$Result.GetResult<Prisma.$DeepWorkSubtaskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeepWorkSubtask.
     * @param {DeepWorkSubtaskUpdateArgs} args - Arguments to update one DeepWorkSubtask.
     * @example
     * // Update one DeepWorkSubtask
     * const deepWorkSubtask = await prisma.deepWorkSubtask.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeepWorkSubtaskUpdateArgs>(args: SelectSubset<T, DeepWorkSubtaskUpdateArgs<ExtArgs>>): Prisma__DeepWorkSubtaskClient<$Result.GetResult<Prisma.$DeepWorkSubtaskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeepWorkSubtasks.
     * @param {DeepWorkSubtaskDeleteManyArgs} args - Arguments to filter DeepWorkSubtasks to delete.
     * @example
     * // Delete a few DeepWorkSubtasks
     * const { count } = await prisma.deepWorkSubtask.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeepWorkSubtaskDeleteManyArgs>(args?: SelectSubset<T, DeepWorkSubtaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeepWorkSubtasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeepWorkSubtaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeepWorkSubtasks
     * const deepWorkSubtask = await prisma.deepWorkSubtask.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeepWorkSubtaskUpdateManyArgs>(args: SelectSubset<T, DeepWorkSubtaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeepWorkSubtasks and returns the data updated in the database.
     * @param {DeepWorkSubtaskUpdateManyAndReturnArgs} args - Arguments to update many DeepWorkSubtasks.
     * @example
     * // Update many DeepWorkSubtasks
     * const deepWorkSubtask = await prisma.deepWorkSubtask.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DeepWorkSubtasks and only return the `id`
     * const deepWorkSubtaskWithIdOnly = await prisma.deepWorkSubtask.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeepWorkSubtaskUpdateManyAndReturnArgs>(args: SelectSubset<T, DeepWorkSubtaskUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeepWorkSubtaskPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DeepWorkSubtask.
     * @param {DeepWorkSubtaskUpsertArgs} args - Arguments to update or create a DeepWorkSubtask.
     * @example
     * // Update or create a DeepWorkSubtask
     * const deepWorkSubtask = await prisma.deepWorkSubtask.upsert({
     *   create: {
     *     // ... data to create a DeepWorkSubtask
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeepWorkSubtask we want to update
     *   }
     * })
     */
    upsert<T extends DeepWorkSubtaskUpsertArgs>(args: SelectSubset<T, DeepWorkSubtaskUpsertArgs<ExtArgs>>): Prisma__DeepWorkSubtaskClient<$Result.GetResult<Prisma.$DeepWorkSubtaskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DeepWorkSubtasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeepWorkSubtaskCountArgs} args - Arguments to filter DeepWorkSubtasks to count.
     * @example
     * // Count the number of DeepWorkSubtasks
     * const count = await prisma.deepWorkSubtask.count({
     *   where: {
     *     // ... the filter for the DeepWorkSubtasks we want to count
     *   }
     * })
    **/
    count<T extends DeepWorkSubtaskCountArgs>(
      args?: Subset<T, DeepWorkSubtaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeepWorkSubtaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeepWorkSubtask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeepWorkSubtaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeepWorkSubtaskAggregateArgs>(args: Subset<T, DeepWorkSubtaskAggregateArgs>): Prisma.PrismaPromise<GetDeepWorkSubtaskAggregateType<T>>

    /**
     * Group by DeepWorkSubtask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeepWorkSubtaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeepWorkSubtaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeepWorkSubtaskGroupByArgs['orderBy'] }
        : { orderBy?: DeepWorkSubtaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeepWorkSubtaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeepWorkSubtaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeepWorkSubtask model
   */
  readonly fields: DeepWorkSubtaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeepWorkSubtask.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeepWorkSubtaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task<T extends DeepWorkTaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeepWorkTaskDefaultArgs<ExtArgs>>): Prisma__DeepWorkTaskClient<$Result.GetResult<Prisma.$DeepWorkTaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeepWorkSubtask model
   */
  interface DeepWorkSubtaskFieldRefs {
    readonly id: FieldRef<"DeepWorkSubtask", 'String'>
    readonly taskId: FieldRef<"DeepWorkSubtask", 'String'>
    readonly title: FieldRef<"DeepWorkSubtask", 'String'>
    readonly text: FieldRef<"DeepWorkSubtask", 'String'>
    readonly completed: FieldRef<"DeepWorkSubtask", 'Boolean'>
    readonly priority: FieldRef<"DeepWorkSubtask", 'String'>
    readonly dueDate: FieldRef<"DeepWorkSubtask", 'DateTime'>
    readonly requiresFocus: FieldRef<"DeepWorkSubtask", 'Boolean'>
    readonly complexityLevel: FieldRef<"DeepWorkSubtask", 'Int'>
    readonly createdAt: FieldRef<"DeepWorkSubtask", 'DateTime'>
    readonly updatedAt: FieldRef<"DeepWorkSubtask", 'DateTime'>
    readonly completedAt: FieldRef<"DeepWorkSubtask", 'DateTime'>
    readonly startedAt: FieldRef<"DeepWorkSubtask", 'DateTime'>
    readonly actualDurationMin: FieldRef<"DeepWorkSubtask", 'Int'>
    readonly timeAccuracy: FieldRef<"DeepWorkSubtask", 'Float'>
    readonly aiAnalyzed: FieldRef<"DeepWorkSubtask", 'Boolean'>
    readonly aiReasoning: FieldRef<"DeepWorkSubtask", 'String'>
    readonly analyzedAt: FieldRef<"DeepWorkSubtask", 'DateTime'>
    readonly xpReward: FieldRef<"DeepWorkSubtask", 'Int'>
    readonly complexity: FieldRef<"DeepWorkSubtask", 'Int'>
    readonly confidence: FieldRef<"DeepWorkSubtask", 'Float'>
    readonly contextualBonus: FieldRef<"DeepWorkSubtask", 'Float'>
    readonly difficulty: FieldRef<"DeepWorkSubtask", 'Int'>
    readonly learningValue: FieldRef<"DeepWorkSubtask", 'Int'>
    readonly priorityRank: FieldRef<"DeepWorkSubtask", 'Int'>
    readonly strategicImportance: FieldRef<"DeepWorkSubtask", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * DeepWorkSubtask findUnique
   */
  export type DeepWorkSubtaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeepWorkSubtask
     */
    select?: DeepWorkSubtaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeepWorkSubtask
     */
    omit?: DeepWorkSubtaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeepWorkSubtaskInclude<ExtArgs> | null
    /**
     * Filter, which DeepWorkSubtask to fetch.
     */
    where: DeepWorkSubtaskWhereUniqueInput
  }

  /**
   * DeepWorkSubtask findUniqueOrThrow
   */
  export type DeepWorkSubtaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeepWorkSubtask
     */
    select?: DeepWorkSubtaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeepWorkSubtask
     */
    omit?: DeepWorkSubtaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeepWorkSubtaskInclude<ExtArgs> | null
    /**
     * Filter, which DeepWorkSubtask to fetch.
     */
    where: DeepWorkSubtaskWhereUniqueInput
  }

  /**
   * DeepWorkSubtask findFirst
   */
  export type DeepWorkSubtaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeepWorkSubtask
     */
    select?: DeepWorkSubtaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeepWorkSubtask
     */
    omit?: DeepWorkSubtaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeepWorkSubtaskInclude<ExtArgs> | null
    /**
     * Filter, which DeepWorkSubtask to fetch.
     */
    where?: DeepWorkSubtaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeepWorkSubtasks to fetch.
     */
    orderBy?: DeepWorkSubtaskOrderByWithRelationInput | DeepWorkSubtaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeepWorkSubtasks.
     */
    cursor?: DeepWorkSubtaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeepWorkSubtasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeepWorkSubtasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeepWorkSubtasks.
     */
    distinct?: DeepWorkSubtaskScalarFieldEnum | DeepWorkSubtaskScalarFieldEnum[]
  }

  /**
   * DeepWorkSubtask findFirstOrThrow
   */
  export type DeepWorkSubtaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeepWorkSubtask
     */
    select?: DeepWorkSubtaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeepWorkSubtask
     */
    omit?: DeepWorkSubtaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeepWorkSubtaskInclude<ExtArgs> | null
    /**
     * Filter, which DeepWorkSubtask to fetch.
     */
    where?: DeepWorkSubtaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeepWorkSubtasks to fetch.
     */
    orderBy?: DeepWorkSubtaskOrderByWithRelationInput | DeepWorkSubtaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeepWorkSubtasks.
     */
    cursor?: DeepWorkSubtaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeepWorkSubtasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeepWorkSubtasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeepWorkSubtasks.
     */
    distinct?: DeepWorkSubtaskScalarFieldEnum | DeepWorkSubtaskScalarFieldEnum[]
  }

  /**
   * DeepWorkSubtask findMany
   */
  export type DeepWorkSubtaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeepWorkSubtask
     */
    select?: DeepWorkSubtaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeepWorkSubtask
     */
    omit?: DeepWorkSubtaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeepWorkSubtaskInclude<ExtArgs> | null
    /**
     * Filter, which DeepWorkSubtasks to fetch.
     */
    where?: DeepWorkSubtaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeepWorkSubtasks to fetch.
     */
    orderBy?: DeepWorkSubtaskOrderByWithRelationInput | DeepWorkSubtaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeepWorkSubtasks.
     */
    cursor?: DeepWorkSubtaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeepWorkSubtasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeepWorkSubtasks.
     */
    skip?: number
    distinct?: DeepWorkSubtaskScalarFieldEnum | DeepWorkSubtaskScalarFieldEnum[]
  }

  /**
   * DeepWorkSubtask create
   */
  export type DeepWorkSubtaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeepWorkSubtask
     */
    select?: DeepWorkSubtaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeepWorkSubtask
     */
    omit?: DeepWorkSubtaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeepWorkSubtaskInclude<ExtArgs> | null
    /**
     * The data needed to create a DeepWorkSubtask.
     */
    data: XOR<DeepWorkSubtaskCreateInput, DeepWorkSubtaskUncheckedCreateInput>
  }

  /**
   * DeepWorkSubtask createMany
   */
  export type DeepWorkSubtaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeepWorkSubtasks.
     */
    data: DeepWorkSubtaskCreateManyInput | DeepWorkSubtaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeepWorkSubtask createManyAndReturn
   */
  export type DeepWorkSubtaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeepWorkSubtask
     */
    select?: DeepWorkSubtaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeepWorkSubtask
     */
    omit?: DeepWorkSubtaskOmit<ExtArgs> | null
    /**
     * The data used to create many DeepWorkSubtasks.
     */
    data: DeepWorkSubtaskCreateManyInput | DeepWorkSubtaskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeepWorkSubtaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeepWorkSubtask update
   */
  export type DeepWorkSubtaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeepWorkSubtask
     */
    select?: DeepWorkSubtaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeepWorkSubtask
     */
    omit?: DeepWorkSubtaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeepWorkSubtaskInclude<ExtArgs> | null
    /**
     * The data needed to update a DeepWorkSubtask.
     */
    data: XOR<DeepWorkSubtaskUpdateInput, DeepWorkSubtaskUncheckedUpdateInput>
    /**
     * Choose, which DeepWorkSubtask to update.
     */
    where: DeepWorkSubtaskWhereUniqueInput
  }

  /**
   * DeepWorkSubtask updateMany
   */
  export type DeepWorkSubtaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeepWorkSubtasks.
     */
    data: XOR<DeepWorkSubtaskUpdateManyMutationInput, DeepWorkSubtaskUncheckedUpdateManyInput>
    /**
     * Filter which DeepWorkSubtasks to update
     */
    where?: DeepWorkSubtaskWhereInput
    /**
     * Limit how many DeepWorkSubtasks to update.
     */
    limit?: number
  }

  /**
   * DeepWorkSubtask updateManyAndReturn
   */
  export type DeepWorkSubtaskUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeepWorkSubtask
     */
    select?: DeepWorkSubtaskSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeepWorkSubtask
     */
    omit?: DeepWorkSubtaskOmit<ExtArgs> | null
    /**
     * The data used to update DeepWorkSubtasks.
     */
    data: XOR<DeepWorkSubtaskUpdateManyMutationInput, DeepWorkSubtaskUncheckedUpdateManyInput>
    /**
     * Filter which DeepWorkSubtasks to update
     */
    where?: DeepWorkSubtaskWhereInput
    /**
     * Limit how many DeepWorkSubtasks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeepWorkSubtaskIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeepWorkSubtask upsert
   */
  export type DeepWorkSubtaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeepWorkSubtask
     */
    select?: DeepWorkSubtaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeepWorkSubtask
     */
    omit?: DeepWorkSubtaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeepWorkSubtaskInclude<ExtArgs> | null
    /**
     * The filter to search for the DeepWorkSubtask to update in case it exists.
     */
    where: DeepWorkSubtaskWhereUniqueInput
    /**
     * In case the DeepWorkSubtask found by the `where` argument doesn't exist, create a new DeepWorkSubtask with this data.
     */
    create: XOR<DeepWorkSubtaskCreateInput, DeepWorkSubtaskUncheckedCreateInput>
    /**
     * In case the DeepWorkSubtask was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeepWorkSubtaskUpdateInput, DeepWorkSubtaskUncheckedUpdateInput>
  }

  /**
   * DeepWorkSubtask delete
   */
  export type DeepWorkSubtaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeepWorkSubtask
     */
    select?: DeepWorkSubtaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeepWorkSubtask
     */
    omit?: DeepWorkSubtaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeepWorkSubtaskInclude<ExtArgs> | null
    /**
     * Filter which DeepWorkSubtask to delete.
     */
    where: DeepWorkSubtaskWhereUniqueInput
  }

  /**
   * DeepWorkSubtask deleteMany
   */
  export type DeepWorkSubtaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeepWorkSubtasks to delete
     */
    where?: DeepWorkSubtaskWhereInput
    /**
     * Limit how many DeepWorkSubtasks to delete.
     */
    limit?: number
  }

  /**
   * DeepWorkSubtask without action
   */
  export type DeepWorkSubtaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeepWorkSubtask
     */
    select?: DeepWorkSubtaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeepWorkSubtask
     */
    omit?: DeepWorkSubtaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeepWorkSubtaskInclude<ExtArgs> | null
  }


  /**
   * Model AutomationTask
   */

  export type AggregateAutomationTask = {
    _count: AutomationTaskCountAggregateOutputType | null
    _avg: AutomationTaskAvgAggregateOutputType | null
    _sum: AutomationTaskSumAggregateOutputType | null
    _min: AutomationTaskMinAggregateOutputType | null
    _max: AutomationTaskMaxAggregateOutputType | null
  }

  export type AutomationTaskAvgAggregateOutputType = {
    estimatedTokens: number | null
    actualTokens: number | null
    executionTimeMs: number | null
  }

  export type AutomationTaskSumAggregateOutputType = {
    estimatedTokens: number | null
    actualTokens: number | null
    executionTimeMs: number | null
  }

  export type AutomationTaskMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    description: string | null
    category: $Enums.AutomationCategory | null
    priority: $Enums.Priority | null
    status: $Enums.AutomationStatus | null
    prompt: string | null
    estimatedTokens: number | null
    actualTokens: number | null
    executionTimeMs: number | null
    result: string | null
    error: string | null
    createdAt: Date | null
    updatedAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
  }

  export type AutomationTaskMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    description: string | null
    category: $Enums.AutomationCategory | null
    priority: $Enums.Priority | null
    status: $Enums.AutomationStatus | null
    prompt: string | null
    estimatedTokens: number | null
    actualTokens: number | null
    executionTimeMs: number | null
    result: string | null
    error: string | null
    createdAt: Date | null
    updatedAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
  }

  export type AutomationTaskCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    description: number
    category: number
    priority: number
    status: number
    prompt: number
    allowedTools: number
    estimatedTokens: number
    actualTokens: number
    executionTimeMs: number
    result: number
    error: number
    metadata: number
    createdAt: number
    updatedAt: number
    startedAt: number
    completedAt: number
    _all: number
  }


  export type AutomationTaskAvgAggregateInputType = {
    estimatedTokens?: true
    actualTokens?: true
    executionTimeMs?: true
  }

  export type AutomationTaskSumAggregateInputType = {
    estimatedTokens?: true
    actualTokens?: true
    executionTimeMs?: true
  }

  export type AutomationTaskMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    description?: true
    category?: true
    priority?: true
    status?: true
    prompt?: true
    estimatedTokens?: true
    actualTokens?: true
    executionTimeMs?: true
    result?: true
    error?: true
    createdAt?: true
    updatedAt?: true
    startedAt?: true
    completedAt?: true
  }

  export type AutomationTaskMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    description?: true
    category?: true
    priority?: true
    status?: true
    prompt?: true
    estimatedTokens?: true
    actualTokens?: true
    executionTimeMs?: true
    result?: true
    error?: true
    createdAt?: true
    updatedAt?: true
    startedAt?: true
    completedAt?: true
  }

  export type AutomationTaskCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    description?: true
    category?: true
    priority?: true
    status?: true
    prompt?: true
    allowedTools?: true
    estimatedTokens?: true
    actualTokens?: true
    executionTimeMs?: true
    result?: true
    error?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    startedAt?: true
    completedAt?: true
    _all?: true
  }

  export type AutomationTaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AutomationTask to aggregate.
     */
    where?: AutomationTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutomationTasks to fetch.
     */
    orderBy?: AutomationTaskOrderByWithRelationInput | AutomationTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AutomationTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutomationTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutomationTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AutomationTasks
    **/
    _count?: true | AutomationTaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AutomationTaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AutomationTaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AutomationTaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AutomationTaskMaxAggregateInputType
  }

  export type GetAutomationTaskAggregateType<T extends AutomationTaskAggregateArgs> = {
        [P in keyof T & keyof AggregateAutomationTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAutomationTask[P]>
      : GetScalarType<T[P], AggregateAutomationTask[P]>
  }




  export type AutomationTaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutomationTaskWhereInput
    orderBy?: AutomationTaskOrderByWithAggregationInput | AutomationTaskOrderByWithAggregationInput[]
    by: AutomationTaskScalarFieldEnum[] | AutomationTaskScalarFieldEnum
    having?: AutomationTaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AutomationTaskCountAggregateInputType | true
    _avg?: AutomationTaskAvgAggregateInputType
    _sum?: AutomationTaskSumAggregateInputType
    _min?: AutomationTaskMinAggregateInputType
    _max?: AutomationTaskMaxAggregateInputType
  }

  export type AutomationTaskGroupByOutputType = {
    id: string
    userId: string
    name: string
    description: string | null
    category: $Enums.AutomationCategory
    priority: $Enums.Priority
    status: $Enums.AutomationStatus
    prompt: string
    allowedTools: JsonValue
    estimatedTokens: number
    actualTokens: number | null
    executionTimeMs: number | null
    result: string | null
    error: string | null
    metadata: JsonValue
    createdAt: Date
    updatedAt: Date
    startedAt: Date | null
    completedAt: Date | null
    _count: AutomationTaskCountAggregateOutputType | null
    _avg: AutomationTaskAvgAggregateOutputType | null
    _sum: AutomationTaskSumAggregateOutputType | null
    _min: AutomationTaskMinAggregateOutputType | null
    _max: AutomationTaskMaxAggregateOutputType | null
  }

  type GetAutomationTaskGroupByPayload<T extends AutomationTaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AutomationTaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AutomationTaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AutomationTaskGroupByOutputType[P]>
            : GetScalarType<T[P], AutomationTaskGroupByOutputType[P]>
        }
      >
    >


  export type AutomationTaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    priority?: boolean
    status?: boolean
    prompt?: boolean
    allowedTools?: boolean
    estimatedTokens?: boolean
    actualTokens?: boolean
    executionTimeMs?: boolean
    result?: boolean
    error?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["automationTask"]>

  export type AutomationTaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    priority?: boolean
    status?: boolean
    prompt?: boolean
    allowedTools?: boolean
    estimatedTokens?: boolean
    actualTokens?: boolean
    executionTimeMs?: boolean
    result?: boolean
    error?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["automationTask"]>

  export type AutomationTaskSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    priority?: boolean
    status?: boolean
    prompt?: boolean
    allowedTools?: boolean
    estimatedTokens?: boolean
    actualTokens?: boolean
    executionTimeMs?: boolean
    result?: boolean
    error?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["automationTask"]>

  export type AutomationTaskSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    priority?: boolean
    status?: boolean
    prompt?: boolean
    allowedTools?: boolean
    estimatedTokens?: boolean
    actualTokens?: boolean
    executionTimeMs?: boolean
    result?: boolean
    error?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
  }

  export type AutomationTaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "name" | "description" | "category" | "priority" | "status" | "prompt" | "allowedTools" | "estimatedTokens" | "actualTokens" | "executionTimeMs" | "result" | "error" | "metadata" | "createdAt" | "updatedAt" | "startedAt" | "completedAt", ExtArgs["result"]["automationTask"]>
  export type AutomationTaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AutomationTaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AutomationTaskIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AutomationTaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AutomationTask"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      description: string | null
      category: $Enums.AutomationCategory
      priority: $Enums.Priority
      status: $Enums.AutomationStatus
      prompt: string
      allowedTools: Prisma.JsonValue
      estimatedTokens: number
      actualTokens: number | null
      executionTimeMs: number | null
      result: string | null
      error: string | null
      metadata: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
      startedAt: Date | null
      completedAt: Date | null
    }, ExtArgs["result"]["automationTask"]>
    composites: {}
  }

  type AutomationTaskGetPayload<S extends boolean | null | undefined | AutomationTaskDefaultArgs> = $Result.GetResult<Prisma.$AutomationTaskPayload, S>

  type AutomationTaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AutomationTaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AutomationTaskCountAggregateInputType | true
    }

  export interface AutomationTaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AutomationTask'], meta: { name: 'AutomationTask' } }
    /**
     * Find zero or one AutomationTask that matches the filter.
     * @param {AutomationTaskFindUniqueArgs} args - Arguments to find a AutomationTask
     * @example
     * // Get one AutomationTask
     * const automationTask = await prisma.automationTask.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AutomationTaskFindUniqueArgs>(args: SelectSubset<T, AutomationTaskFindUniqueArgs<ExtArgs>>): Prisma__AutomationTaskClient<$Result.GetResult<Prisma.$AutomationTaskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AutomationTask that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AutomationTaskFindUniqueOrThrowArgs} args - Arguments to find a AutomationTask
     * @example
     * // Get one AutomationTask
     * const automationTask = await prisma.automationTask.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AutomationTaskFindUniqueOrThrowArgs>(args: SelectSubset<T, AutomationTaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AutomationTaskClient<$Result.GetResult<Prisma.$AutomationTaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AutomationTask that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationTaskFindFirstArgs} args - Arguments to find a AutomationTask
     * @example
     * // Get one AutomationTask
     * const automationTask = await prisma.automationTask.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AutomationTaskFindFirstArgs>(args?: SelectSubset<T, AutomationTaskFindFirstArgs<ExtArgs>>): Prisma__AutomationTaskClient<$Result.GetResult<Prisma.$AutomationTaskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AutomationTask that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationTaskFindFirstOrThrowArgs} args - Arguments to find a AutomationTask
     * @example
     * // Get one AutomationTask
     * const automationTask = await prisma.automationTask.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AutomationTaskFindFirstOrThrowArgs>(args?: SelectSubset<T, AutomationTaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__AutomationTaskClient<$Result.GetResult<Prisma.$AutomationTaskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AutomationTasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationTaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AutomationTasks
     * const automationTasks = await prisma.automationTask.findMany()
     * 
     * // Get first 10 AutomationTasks
     * const automationTasks = await prisma.automationTask.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const automationTaskWithIdOnly = await prisma.automationTask.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AutomationTaskFindManyArgs>(args?: SelectSubset<T, AutomationTaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AutomationTask.
     * @param {AutomationTaskCreateArgs} args - Arguments to create a AutomationTask.
     * @example
     * // Create one AutomationTask
     * const AutomationTask = await prisma.automationTask.create({
     *   data: {
     *     // ... data to create a AutomationTask
     *   }
     * })
     * 
     */
    create<T extends AutomationTaskCreateArgs>(args: SelectSubset<T, AutomationTaskCreateArgs<ExtArgs>>): Prisma__AutomationTaskClient<$Result.GetResult<Prisma.$AutomationTaskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AutomationTasks.
     * @param {AutomationTaskCreateManyArgs} args - Arguments to create many AutomationTasks.
     * @example
     * // Create many AutomationTasks
     * const automationTask = await prisma.automationTask.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AutomationTaskCreateManyArgs>(args?: SelectSubset<T, AutomationTaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AutomationTasks and returns the data saved in the database.
     * @param {AutomationTaskCreateManyAndReturnArgs} args - Arguments to create many AutomationTasks.
     * @example
     * // Create many AutomationTasks
     * const automationTask = await prisma.automationTask.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AutomationTasks and only return the `id`
     * const automationTaskWithIdOnly = await prisma.automationTask.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AutomationTaskCreateManyAndReturnArgs>(args?: SelectSubset<T, AutomationTaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationTaskPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AutomationTask.
     * @param {AutomationTaskDeleteArgs} args - Arguments to delete one AutomationTask.
     * @example
     * // Delete one AutomationTask
     * const AutomationTask = await prisma.automationTask.delete({
     *   where: {
     *     // ... filter to delete one AutomationTask
     *   }
     * })
     * 
     */
    delete<T extends AutomationTaskDeleteArgs>(args: SelectSubset<T, AutomationTaskDeleteArgs<ExtArgs>>): Prisma__AutomationTaskClient<$Result.GetResult<Prisma.$AutomationTaskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AutomationTask.
     * @param {AutomationTaskUpdateArgs} args - Arguments to update one AutomationTask.
     * @example
     * // Update one AutomationTask
     * const automationTask = await prisma.automationTask.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AutomationTaskUpdateArgs>(args: SelectSubset<T, AutomationTaskUpdateArgs<ExtArgs>>): Prisma__AutomationTaskClient<$Result.GetResult<Prisma.$AutomationTaskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AutomationTasks.
     * @param {AutomationTaskDeleteManyArgs} args - Arguments to filter AutomationTasks to delete.
     * @example
     * // Delete a few AutomationTasks
     * const { count } = await prisma.automationTask.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AutomationTaskDeleteManyArgs>(args?: SelectSubset<T, AutomationTaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AutomationTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationTaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AutomationTasks
     * const automationTask = await prisma.automationTask.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AutomationTaskUpdateManyArgs>(args: SelectSubset<T, AutomationTaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AutomationTasks and returns the data updated in the database.
     * @param {AutomationTaskUpdateManyAndReturnArgs} args - Arguments to update many AutomationTasks.
     * @example
     * // Update many AutomationTasks
     * const automationTask = await prisma.automationTask.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AutomationTasks and only return the `id`
     * const automationTaskWithIdOnly = await prisma.automationTask.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AutomationTaskUpdateManyAndReturnArgs>(args: SelectSubset<T, AutomationTaskUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationTaskPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AutomationTask.
     * @param {AutomationTaskUpsertArgs} args - Arguments to update or create a AutomationTask.
     * @example
     * // Update or create a AutomationTask
     * const automationTask = await prisma.automationTask.upsert({
     *   create: {
     *     // ... data to create a AutomationTask
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AutomationTask we want to update
     *   }
     * })
     */
    upsert<T extends AutomationTaskUpsertArgs>(args: SelectSubset<T, AutomationTaskUpsertArgs<ExtArgs>>): Prisma__AutomationTaskClient<$Result.GetResult<Prisma.$AutomationTaskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AutomationTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationTaskCountArgs} args - Arguments to filter AutomationTasks to count.
     * @example
     * // Count the number of AutomationTasks
     * const count = await prisma.automationTask.count({
     *   where: {
     *     // ... the filter for the AutomationTasks we want to count
     *   }
     * })
    **/
    count<T extends AutomationTaskCountArgs>(
      args?: Subset<T, AutomationTaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AutomationTaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AutomationTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationTaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AutomationTaskAggregateArgs>(args: Subset<T, AutomationTaskAggregateArgs>): Prisma.PrismaPromise<GetAutomationTaskAggregateType<T>>

    /**
     * Group by AutomationTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationTaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AutomationTaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AutomationTaskGroupByArgs['orderBy'] }
        : { orderBy?: AutomationTaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AutomationTaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAutomationTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AutomationTask model
   */
  readonly fields: AutomationTaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AutomationTask.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AutomationTaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AutomationTask model
   */
  interface AutomationTaskFieldRefs {
    readonly id: FieldRef<"AutomationTask", 'String'>
    readonly userId: FieldRef<"AutomationTask", 'String'>
    readonly name: FieldRef<"AutomationTask", 'String'>
    readonly description: FieldRef<"AutomationTask", 'String'>
    readonly category: FieldRef<"AutomationTask", 'AutomationCategory'>
    readonly priority: FieldRef<"AutomationTask", 'Priority'>
    readonly status: FieldRef<"AutomationTask", 'AutomationStatus'>
    readonly prompt: FieldRef<"AutomationTask", 'String'>
    readonly allowedTools: FieldRef<"AutomationTask", 'Json'>
    readonly estimatedTokens: FieldRef<"AutomationTask", 'Int'>
    readonly actualTokens: FieldRef<"AutomationTask", 'Int'>
    readonly executionTimeMs: FieldRef<"AutomationTask", 'Int'>
    readonly result: FieldRef<"AutomationTask", 'String'>
    readonly error: FieldRef<"AutomationTask", 'String'>
    readonly metadata: FieldRef<"AutomationTask", 'Json'>
    readonly createdAt: FieldRef<"AutomationTask", 'DateTime'>
    readonly updatedAt: FieldRef<"AutomationTask", 'DateTime'>
    readonly startedAt: FieldRef<"AutomationTask", 'DateTime'>
    readonly completedAt: FieldRef<"AutomationTask", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AutomationTask findUnique
   */
  export type AutomationTaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationTask
     */
    select?: AutomationTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationTask
     */
    omit?: AutomationTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationTaskInclude<ExtArgs> | null
    /**
     * Filter, which AutomationTask to fetch.
     */
    where: AutomationTaskWhereUniqueInput
  }

  /**
   * AutomationTask findUniqueOrThrow
   */
  export type AutomationTaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationTask
     */
    select?: AutomationTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationTask
     */
    omit?: AutomationTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationTaskInclude<ExtArgs> | null
    /**
     * Filter, which AutomationTask to fetch.
     */
    where: AutomationTaskWhereUniqueInput
  }

  /**
   * AutomationTask findFirst
   */
  export type AutomationTaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationTask
     */
    select?: AutomationTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationTask
     */
    omit?: AutomationTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationTaskInclude<ExtArgs> | null
    /**
     * Filter, which AutomationTask to fetch.
     */
    where?: AutomationTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutomationTasks to fetch.
     */
    orderBy?: AutomationTaskOrderByWithRelationInput | AutomationTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AutomationTasks.
     */
    cursor?: AutomationTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutomationTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutomationTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AutomationTasks.
     */
    distinct?: AutomationTaskScalarFieldEnum | AutomationTaskScalarFieldEnum[]
  }

  /**
   * AutomationTask findFirstOrThrow
   */
  export type AutomationTaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationTask
     */
    select?: AutomationTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationTask
     */
    omit?: AutomationTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationTaskInclude<ExtArgs> | null
    /**
     * Filter, which AutomationTask to fetch.
     */
    where?: AutomationTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutomationTasks to fetch.
     */
    orderBy?: AutomationTaskOrderByWithRelationInput | AutomationTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AutomationTasks.
     */
    cursor?: AutomationTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutomationTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutomationTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AutomationTasks.
     */
    distinct?: AutomationTaskScalarFieldEnum | AutomationTaskScalarFieldEnum[]
  }

  /**
   * AutomationTask findMany
   */
  export type AutomationTaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationTask
     */
    select?: AutomationTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationTask
     */
    omit?: AutomationTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationTaskInclude<ExtArgs> | null
    /**
     * Filter, which AutomationTasks to fetch.
     */
    where?: AutomationTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutomationTasks to fetch.
     */
    orderBy?: AutomationTaskOrderByWithRelationInput | AutomationTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AutomationTasks.
     */
    cursor?: AutomationTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutomationTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutomationTasks.
     */
    skip?: number
    distinct?: AutomationTaskScalarFieldEnum | AutomationTaskScalarFieldEnum[]
  }

  /**
   * AutomationTask create
   */
  export type AutomationTaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationTask
     */
    select?: AutomationTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationTask
     */
    omit?: AutomationTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationTaskInclude<ExtArgs> | null
    /**
     * The data needed to create a AutomationTask.
     */
    data: XOR<AutomationTaskCreateInput, AutomationTaskUncheckedCreateInput>
  }

  /**
   * AutomationTask createMany
   */
  export type AutomationTaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AutomationTasks.
     */
    data: AutomationTaskCreateManyInput | AutomationTaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AutomationTask createManyAndReturn
   */
  export type AutomationTaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationTask
     */
    select?: AutomationTaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationTask
     */
    omit?: AutomationTaskOmit<ExtArgs> | null
    /**
     * The data used to create many AutomationTasks.
     */
    data: AutomationTaskCreateManyInput | AutomationTaskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationTaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AutomationTask update
   */
  export type AutomationTaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationTask
     */
    select?: AutomationTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationTask
     */
    omit?: AutomationTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationTaskInclude<ExtArgs> | null
    /**
     * The data needed to update a AutomationTask.
     */
    data: XOR<AutomationTaskUpdateInput, AutomationTaskUncheckedUpdateInput>
    /**
     * Choose, which AutomationTask to update.
     */
    where: AutomationTaskWhereUniqueInput
  }

  /**
   * AutomationTask updateMany
   */
  export type AutomationTaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AutomationTasks.
     */
    data: XOR<AutomationTaskUpdateManyMutationInput, AutomationTaskUncheckedUpdateManyInput>
    /**
     * Filter which AutomationTasks to update
     */
    where?: AutomationTaskWhereInput
    /**
     * Limit how many AutomationTasks to update.
     */
    limit?: number
  }

  /**
   * AutomationTask updateManyAndReturn
   */
  export type AutomationTaskUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationTask
     */
    select?: AutomationTaskSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationTask
     */
    omit?: AutomationTaskOmit<ExtArgs> | null
    /**
     * The data used to update AutomationTasks.
     */
    data: XOR<AutomationTaskUpdateManyMutationInput, AutomationTaskUncheckedUpdateManyInput>
    /**
     * Filter which AutomationTasks to update
     */
    where?: AutomationTaskWhereInput
    /**
     * Limit how many AutomationTasks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationTaskIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AutomationTask upsert
   */
  export type AutomationTaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationTask
     */
    select?: AutomationTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationTask
     */
    omit?: AutomationTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationTaskInclude<ExtArgs> | null
    /**
     * The filter to search for the AutomationTask to update in case it exists.
     */
    where: AutomationTaskWhereUniqueInput
    /**
     * In case the AutomationTask found by the `where` argument doesn't exist, create a new AutomationTask with this data.
     */
    create: XOR<AutomationTaskCreateInput, AutomationTaskUncheckedCreateInput>
    /**
     * In case the AutomationTask was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AutomationTaskUpdateInput, AutomationTaskUncheckedUpdateInput>
  }

  /**
   * AutomationTask delete
   */
  export type AutomationTaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationTask
     */
    select?: AutomationTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationTask
     */
    omit?: AutomationTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationTaskInclude<ExtArgs> | null
    /**
     * Filter which AutomationTask to delete.
     */
    where: AutomationTaskWhereUniqueInput
  }

  /**
   * AutomationTask deleteMany
   */
  export type AutomationTaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AutomationTasks to delete
     */
    where?: AutomationTaskWhereInput
    /**
     * Limit how many AutomationTasks to delete.
     */
    limit?: number
  }

  /**
   * AutomationTask without action
   */
  export type AutomationTaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationTask
     */
    select?: AutomationTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationTask
     */
    omit?: AutomationTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationTaskInclude<ExtArgs> | null
  }


  /**
   * Model DailyHabits
   */

  export type AggregateDailyHabits = {
    _count: DailyHabitsCountAggregateOutputType | null
    _avg: DailyHabitsAvgAggregateOutputType | null
    _sum: DailyHabitsSumAggregateOutputType | null
    _min: DailyHabitsMinAggregateOutputType | null
    _max: DailyHabitsMaxAggregateOutputType | null
  }

  export type DailyHabitsAvgAggregateOutputType = {
    screenTimeMinutes: number | null
    bullshitContentMinutes: number | null
    deepWorkHours: number | null
    lightWorkHours: number | null
  }

  export type DailyHabitsSumAggregateOutputType = {
    screenTimeMinutes: number | null
    bullshitContentMinutes: number | null
    deepWorkHours: number | null
    lightWorkHours: number | null
  }

  export type DailyHabitsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    date: string | null
    screenTimeMinutes: number | null
    bullshitContentMinutes: number | null
    noWeed: boolean | null
    noScrolling: boolean | null
    deepWorkHours: number | null
    lightWorkHours: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DailyHabitsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    date: string | null
    screenTimeMinutes: number | null
    bullshitContentMinutes: number | null
    noWeed: boolean | null
    noScrolling: boolean | null
    deepWorkHours: number | null
    lightWorkHours: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DailyHabitsCountAggregateOutputType = {
    id: number
    userId: number
    date: number
    screenTimeMinutes: number
    bullshitContentMinutes: number
    noWeed: number
    noScrolling: number
    deepWorkHours: number
    lightWorkHours: number
    habitsData: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DailyHabitsAvgAggregateInputType = {
    screenTimeMinutes?: true
    bullshitContentMinutes?: true
    deepWorkHours?: true
    lightWorkHours?: true
  }

  export type DailyHabitsSumAggregateInputType = {
    screenTimeMinutes?: true
    bullshitContentMinutes?: true
    deepWorkHours?: true
    lightWorkHours?: true
  }

  export type DailyHabitsMinAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    screenTimeMinutes?: true
    bullshitContentMinutes?: true
    noWeed?: true
    noScrolling?: true
    deepWorkHours?: true
    lightWorkHours?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DailyHabitsMaxAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    screenTimeMinutes?: true
    bullshitContentMinutes?: true
    noWeed?: true
    noScrolling?: true
    deepWorkHours?: true
    lightWorkHours?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DailyHabitsCountAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    screenTimeMinutes?: true
    bullshitContentMinutes?: true
    noWeed?: true
    noScrolling?: true
    deepWorkHours?: true
    lightWorkHours?: true
    habitsData?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DailyHabitsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyHabits to aggregate.
     */
    where?: DailyHabitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyHabits to fetch.
     */
    orderBy?: DailyHabitsOrderByWithRelationInput | DailyHabitsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DailyHabitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyHabits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyHabits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DailyHabits
    **/
    _count?: true | DailyHabitsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DailyHabitsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DailyHabitsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DailyHabitsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DailyHabitsMaxAggregateInputType
  }

  export type GetDailyHabitsAggregateType<T extends DailyHabitsAggregateArgs> = {
        [P in keyof T & keyof AggregateDailyHabits]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDailyHabits[P]>
      : GetScalarType<T[P], AggregateDailyHabits[P]>
  }




  export type DailyHabitsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyHabitsWhereInput
    orderBy?: DailyHabitsOrderByWithAggregationInput | DailyHabitsOrderByWithAggregationInput[]
    by: DailyHabitsScalarFieldEnum[] | DailyHabitsScalarFieldEnum
    having?: DailyHabitsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DailyHabitsCountAggregateInputType | true
    _avg?: DailyHabitsAvgAggregateInputType
    _sum?: DailyHabitsSumAggregateInputType
    _min?: DailyHabitsMinAggregateInputType
    _max?: DailyHabitsMaxAggregateInputType
  }

  export type DailyHabitsGroupByOutputType = {
    id: string
    userId: string
    date: string
    screenTimeMinutes: number
    bullshitContentMinutes: number
    noWeed: boolean
    noScrolling: boolean
    deepWorkHours: number
    lightWorkHours: number
    habitsData: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: DailyHabitsCountAggregateOutputType | null
    _avg: DailyHabitsAvgAggregateOutputType | null
    _sum: DailyHabitsSumAggregateOutputType | null
    _min: DailyHabitsMinAggregateOutputType | null
    _max: DailyHabitsMaxAggregateOutputType | null
  }

  type GetDailyHabitsGroupByPayload<T extends DailyHabitsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DailyHabitsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DailyHabitsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DailyHabitsGroupByOutputType[P]>
            : GetScalarType<T[P], DailyHabitsGroupByOutputType[P]>
        }
      >
    >


  export type DailyHabitsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    screenTimeMinutes?: boolean
    bullshitContentMinutes?: boolean
    noWeed?: boolean
    noScrolling?: boolean
    deepWorkHours?: boolean
    lightWorkHours?: boolean
    habitsData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailyHabits"]>

  export type DailyHabitsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    screenTimeMinutes?: boolean
    bullshitContentMinutes?: boolean
    noWeed?: boolean
    noScrolling?: boolean
    deepWorkHours?: boolean
    lightWorkHours?: boolean
    habitsData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailyHabits"]>

  export type DailyHabitsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    screenTimeMinutes?: boolean
    bullshitContentMinutes?: boolean
    noWeed?: boolean
    noScrolling?: boolean
    deepWorkHours?: boolean
    lightWorkHours?: boolean
    habitsData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailyHabits"]>

  export type DailyHabitsSelectScalar = {
    id?: boolean
    userId?: boolean
    date?: boolean
    screenTimeMinutes?: boolean
    bullshitContentMinutes?: boolean
    noWeed?: boolean
    noScrolling?: boolean
    deepWorkHours?: boolean
    lightWorkHours?: boolean
    habitsData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DailyHabitsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "date" | "screenTimeMinutes" | "bullshitContentMinutes" | "noWeed" | "noScrolling" | "deepWorkHours" | "lightWorkHours" | "habitsData" | "createdAt" | "updatedAt", ExtArgs["result"]["dailyHabits"]>
  export type DailyHabitsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DailyHabitsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DailyHabitsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DailyHabitsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DailyHabits"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      date: string
      screenTimeMinutes: number
      bullshitContentMinutes: number
      noWeed: boolean
      noScrolling: boolean
      deepWorkHours: number
      lightWorkHours: number
      habitsData: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dailyHabits"]>
    composites: {}
  }

  type DailyHabitsGetPayload<S extends boolean | null | undefined | DailyHabitsDefaultArgs> = $Result.GetResult<Prisma.$DailyHabitsPayload, S>

  type DailyHabitsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DailyHabitsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DailyHabitsCountAggregateInputType | true
    }

  export interface DailyHabitsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DailyHabits'], meta: { name: 'DailyHabits' } }
    /**
     * Find zero or one DailyHabits that matches the filter.
     * @param {DailyHabitsFindUniqueArgs} args - Arguments to find a DailyHabits
     * @example
     * // Get one DailyHabits
     * const dailyHabits = await prisma.dailyHabits.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DailyHabitsFindUniqueArgs>(args: SelectSubset<T, DailyHabitsFindUniqueArgs<ExtArgs>>): Prisma__DailyHabitsClient<$Result.GetResult<Prisma.$DailyHabitsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DailyHabits that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DailyHabitsFindUniqueOrThrowArgs} args - Arguments to find a DailyHabits
     * @example
     * // Get one DailyHabits
     * const dailyHabits = await prisma.dailyHabits.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DailyHabitsFindUniqueOrThrowArgs>(args: SelectSubset<T, DailyHabitsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DailyHabitsClient<$Result.GetResult<Prisma.$DailyHabitsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DailyHabits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyHabitsFindFirstArgs} args - Arguments to find a DailyHabits
     * @example
     * // Get one DailyHabits
     * const dailyHabits = await prisma.dailyHabits.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DailyHabitsFindFirstArgs>(args?: SelectSubset<T, DailyHabitsFindFirstArgs<ExtArgs>>): Prisma__DailyHabitsClient<$Result.GetResult<Prisma.$DailyHabitsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DailyHabits that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyHabitsFindFirstOrThrowArgs} args - Arguments to find a DailyHabits
     * @example
     * // Get one DailyHabits
     * const dailyHabits = await prisma.dailyHabits.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DailyHabitsFindFirstOrThrowArgs>(args?: SelectSubset<T, DailyHabitsFindFirstOrThrowArgs<ExtArgs>>): Prisma__DailyHabitsClient<$Result.GetResult<Prisma.$DailyHabitsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DailyHabits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyHabitsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DailyHabits
     * const dailyHabits = await prisma.dailyHabits.findMany()
     * 
     * // Get first 10 DailyHabits
     * const dailyHabits = await prisma.dailyHabits.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dailyHabitsWithIdOnly = await prisma.dailyHabits.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DailyHabitsFindManyArgs>(args?: SelectSubset<T, DailyHabitsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyHabitsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DailyHabits.
     * @param {DailyHabitsCreateArgs} args - Arguments to create a DailyHabits.
     * @example
     * // Create one DailyHabits
     * const DailyHabits = await prisma.dailyHabits.create({
     *   data: {
     *     // ... data to create a DailyHabits
     *   }
     * })
     * 
     */
    create<T extends DailyHabitsCreateArgs>(args: SelectSubset<T, DailyHabitsCreateArgs<ExtArgs>>): Prisma__DailyHabitsClient<$Result.GetResult<Prisma.$DailyHabitsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DailyHabits.
     * @param {DailyHabitsCreateManyArgs} args - Arguments to create many DailyHabits.
     * @example
     * // Create many DailyHabits
     * const dailyHabits = await prisma.dailyHabits.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DailyHabitsCreateManyArgs>(args?: SelectSubset<T, DailyHabitsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DailyHabits and returns the data saved in the database.
     * @param {DailyHabitsCreateManyAndReturnArgs} args - Arguments to create many DailyHabits.
     * @example
     * // Create many DailyHabits
     * const dailyHabits = await prisma.dailyHabits.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DailyHabits and only return the `id`
     * const dailyHabitsWithIdOnly = await prisma.dailyHabits.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DailyHabitsCreateManyAndReturnArgs>(args?: SelectSubset<T, DailyHabitsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyHabitsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DailyHabits.
     * @param {DailyHabitsDeleteArgs} args - Arguments to delete one DailyHabits.
     * @example
     * // Delete one DailyHabits
     * const DailyHabits = await prisma.dailyHabits.delete({
     *   where: {
     *     // ... filter to delete one DailyHabits
     *   }
     * })
     * 
     */
    delete<T extends DailyHabitsDeleteArgs>(args: SelectSubset<T, DailyHabitsDeleteArgs<ExtArgs>>): Prisma__DailyHabitsClient<$Result.GetResult<Prisma.$DailyHabitsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DailyHabits.
     * @param {DailyHabitsUpdateArgs} args - Arguments to update one DailyHabits.
     * @example
     * // Update one DailyHabits
     * const dailyHabits = await prisma.dailyHabits.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DailyHabitsUpdateArgs>(args: SelectSubset<T, DailyHabitsUpdateArgs<ExtArgs>>): Prisma__DailyHabitsClient<$Result.GetResult<Prisma.$DailyHabitsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DailyHabits.
     * @param {DailyHabitsDeleteManyArgs} args - Arguments to filter DailyHabits to delete.
     * @example
     * // Delete a few DailyHabits
     * const { count } = await prisma.dailyHabits.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DailyHabitsDeleteManyArgs>(args?: SelectSubset<T, DailyHabitsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyHabits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyHabitsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DailyHabits
     * const dailyHabits = await prisma.dailyHabits.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DailyHabitsUpdateManyArgs>(args: SelectSubset<T, DailyHabitsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyHabits and returns the data updated in the database.
     * @param {DailyHabitsUpdateManyAndReturnArgs} args - Arguments to update many DailyHabits.
     * @example
     * // Update many DailyHabits
     * const dailyHabits = await prisma.dailyHabits.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DailyHabits and only return the `id`
     * const dailyHabitsWithIdOnly = await prisma.dailyHabits.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DailyHabitsUpdateManyAndReturnArgs>(args: SelectSubset<T, DailyHabitsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyHabitsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DailyHabits.
     * @param {DailyHabitsUpsertArgs} args - Arguments to update or create a DailyHabits.
     * @example
     * // Update or create a DailyHabits
     * const dailyHabits = await prisma.dailyHabits.upsert({
     *   create: {
     *     // ... data to create a DailyHabits
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DailyHabits we want to update
     *   }
     * })
     */
    upsert<T extends DailyHabitsUpsertArgs>(args: SelectSubset<T, DailyHabitsUpsertArgs<ExtArgs>>): Prisma__DailyHabitsClient<$Result.GetResult<Prisma.$DailyHabitsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DailyHabits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyHabitsCountArgs} args - Arguments to filter DailyHabits to count.
     * @example
     * // Count the number of DailyHabits
     * const count = await prisma.dailyHabits.count({
     *   where: {
     *     // ... the filter for the DailyHabits we want to count
     *   }
     * })
    **/
    count<T extends DailyHabitsCountArgs>(
      args?: Subset<T, DailyHabitsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DailyHabitsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DailyHabits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyHabitsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DailyHabitsAggregateArgs>(args: Subset<T, DailyHabitsAggregateArgs>): Prisma.PrismaPromise<GetDailyHabitsAggregateType<T>>

    /**
     * Group by DailyHabits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyHabitsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DailyHabitsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DailyHabitsGroupByArgs['orderBy'] }
        : { orderBy?: DailyHabitsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DailyHabitsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDailyHabitsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DailyHabits model
   */
  readonly fields: DailyHabitsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DailyHabits.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DailyHabitsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DailyHabits model
   */
  interface DailyHabitsFieldRefs {
    readonly id: FieldRef<"DailyHabits", 'String'>
    readonly userId: FieldRef<"DailyHabits", 'String'>
    readonly date: FieldRef<"DailyHabits", 'String'>
    readonly screenTimeMinutes: FieldRef<"DailyHabits", 'Int'>
    readonly bullshitContentMinutes: FieldRef<"DailyHabits", 'Int'>
    readonly noWeed: FieldRef<"DailyHabits", 'Boolean'>
    readonly noScrolling: FieldRef<"DailyHabits", 'Boolean'>
    readonly deepWorkHours: FieldRef<"DailyHabits", 'Float'>
    readonly lightWorkHours: FieldRef<"DailyHabits", 'Float'>
    readonly habitsData: FieldRef<"DailyHabits", 'Json'>
    readonly createdAt: FieldRef<"DailyHabits", 'DateTime'>
    readonly updatedAt: FieldRef<"DailyHabits", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DailyHabits findUnique
   */
  export type DailyHabitsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyHabits
     */
    select?: DailyHabitsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyHabits
     */
    omit?: DailyHabitsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyHabitsInclude<ExtArgs> | null
    /**
     * Filter, which DailyHabits to fetch.
     */
    where: DailyHabitsWhereUniqueInput
  }

  /**
   * DailyHabits findUniqueOrThrow
   */
  export type DailyHabitsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyHabits
     */
    select?: DailyHabitsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyHabits
     */
    omit?: DailyHabitsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyHabitsInclude<ExtArgs> | null
    /**
     * Filter, which DailyHabits to fetch.
     */
    where: DailyHabitsWhereUniqueInput
  }

  /**
   * DailyHabits findFirst
   */
  export type DailyHabitsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyHabits
     */
    select?: DailyHabitsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyHabits
     */
    omit?: DailyHabitsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyHabitsInclude<ExtArgs> | null
    /**
     * Filter, which DailyHabits to fetch.
     */
    where?: DailyHabitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyHabits to fetch.
     */
    orderBy?: DailyHabitsOrderByWithRelationInput | DailyHabitsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyHabits.
     */
    cursor?: DailyHabitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyHabits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyHabits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyHabits.
     */
    distinct?: DailyHabitsScalarFieldEnum | DailyHabitsScalarFieldEnum[]
  }

  /**
   * DailyHabits findFirstOrThrow
   */
  export type DailyHabitsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyHabits
     */
    select?: DailyHabitsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyHabits
     */
    omit?: DailyHabitsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyHabitsInclude<ExtArgs> | null
    /**
     * Filter, which DailyHabits to fetch.
     */
    where?: DailyHabitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyHabits to fetch.
     */
    orderBy?: DailyHabitsOrderByWithRelationInput | DailyHabitsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyHabits.
     */
    cursor?: DailyHabitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyHabits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyHabits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyHabits.
     */
    distinct?: DailyHabitsScalarFieldEnum | DailyHabitsScalarFieldEnum[]
  }

  /**
   * DailyHabits findMany
   */
  export type DailyHabitsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyHabits
     */
    select?: DailyHabitsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyHabits
     */
    omit?: DailyHabitsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyHabitsInclude<ExtArgs> | null
    /**
     * Filter, which DailyHabits to fetch.
     */
    where?: DailyHabitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyHabits to fetch.
     */
    orderBy?: DailyHabitsOrderByWithRelationInput | DailyHabitsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DailyHabits.
     */
    cursor?: DailyHabitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyHabits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyHabits.
     */
    skip?: number
    distinct?: DailyHabitsScalarFieldEnum | DailyHabitsScalarFieldEnum[]
  }

  /**
   * DailyHabits create
   */
  export type DailyHabitsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyHabits
     */
    select?: DailyHabitsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyHabits
     */
    omit?: DailyHabitsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyHabitsInclude<ExtArgs> | null
    /**
     * The data needed to create a DailyHabits.
     */
    data: XOR<DailyHabitsCreateInput, DailyHabitsUncheckedCreateInput>
  }

  /**
   * DailyHabits createMany
   */
  export type DailyHabitsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DailyHabits.
     */
    data: DailyHabitsCreateManyInput | DailyHabitsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DailyHabits createManyAndReturn
   */
  export type DailyHabitsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyHabits
     */
    select?: DailyHabitsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DailyHabits
     */
    omit?: DailyHabitsOmit<ExtArgs> | null
    /**
     * The data used to create many DailyHabits.
     */
    data: DailyHabitsCreateManyInput | DailyHabitsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyHabitsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DailyHabits update
   */
  export type DailyHabitsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyHabits
     */
    select?: DailyHabitsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyHabits
     */
    omit?: DailyHabitsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyHabitsInclude<ExtArgs> | null
    /**
     * The data needed to update a DailyHabits.
     */
    data: XOR<DailyHabitsUpdateInput, DailyHabitsUncheckedUpdateInput>
    /**
     * Choose, which DailyHabits to update.
     */
    where: DailyHabitsWhereUniqueInput
  }

  /**
   * DailyHabits updateMany
   */
  export type DailyHabitsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DailyHabits.
     */
    data: XOR<DailyHabitsUpdateManyMutationInput, DailyHabitsUncheckedUpdateManyInput>
    /**
     * Filter which DailyHabits to update
     */
    where?: DailyHabitsWhereInput
    /**
     * Limit how many DailyHabits to update.
     */
    limit?: number
  }

  /**
   * DailyHabits updateManyAndReturn
   */
  export type DailyHabitsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyHabits
     */
    select?: DailyHabitsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DailyHabits
     */
    omit?: DailyHabitsOmit<ExtArgs> | null
    /**
     * The data used to update DailyHabits.
     */
    data: XOR<DailyHabitsUpdateManyMutationInput, DailyHabitsUncheckedUpdateManyInput>
    /**
     * Filter which DailyHabits to update
     */
    where?: DailyHabitsWhereInput
    /**
     * Limit how many DailyHabits to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyHabitsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DailyHabits upsert
   */
  export type DailyHabitsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyHabits
     */
    select?: DailyHabitsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyHabits
     */
    omit?: DailyHabitsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyHabitsInclude<ExtArgs> | null
    /**
     * The filter to search for the DailyHabits to update in case it exists.
     */
    where: DailyHabitsWhereUniqueInput
    /**
     * In case the DailyHabits found by the `where` argument doesn't exist, create a new DailyHabits with this data.
     */
    create: XOR<DailyHabitsCreateInput, DailyHabitsUncheckedCreateInput>
    /**
     * In case the DailyHabits was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DailyHabitsUpdateInput, DailyHabitsUncheckedUpdateInput>
  }

  /**
   * DailyHabits delete
   */
  export type DailyHabitsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyHabits
     */
    select?: DailyHabitsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyHabits
     */
    omit?: DailyHabitsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyHabitsInclude<ExtArgs> | null
    /**
     * Filter which DailyHabits to delete.
     */
    where: DailyHabitsWhereUniqueInput
  }

  /**
   * DailyHabits deleteMany
   */
  export type DailyHabitsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyHabits to delete
     */
    where?: DailyHabitsWhereInput
    /**
     * Limit how many DailyHabits to delete.
     */
    limit?: number
  }

  /**
   * DailyHabits without action
   */
  export type DailyHabitsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyHabits
     */
    select?: DailyHabitsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyHabits
     */
    omit?: DailyHabitsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyHabitsInclude<ExtArgs> | null
  }


  /**
   * Model DailyHealth
   */

  export type AggregateDailyHealth = {
    _count: DailyHealthCountAggregateOutputType | null
    _avg: DailyHealthAvgAggregateOutputType | null
    _sum: DailyHealthSumAggregateOutputType | null
    _min: DailyHealthMinAggregateOutputType | null
    _max: DailyHealthMaxAggregateOutputType | null
  }

  export type DailyHealthAvgAggregateOutputType = {
    waterIntakeMl: number | null
    milkIntakeMl: number | null
    sleepHours: number | null
    energyLevel: number | null
    moodLevel: number | null
  }

  export type DailyHealthSumAggregateOutputType = {
    waterIntakeMl: number | null
    milkIntakeMl: number | null
    sleepHours: number | null
    energyLevel: number | null
    moodLevel: number | null
  }

  export type DailyHealthMinAggregateOutputType = {
    id: string | null
    userId: string | null
    date: string | null
    waterIntakeMl: number | null
    milkIntakeMl: number | null
    sleepHours: number | null
    energyLevel: number | null
    moodLevel: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DailyHealthMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    date: string | null
    waterIntakeMl: number | null
    milkIntakeMl: number | null
    sleepHours: number | null
    energyLevel: number | null
    moodLevel: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DailyHealthCountAggregateOutputType = {
    id: number
    userId: number
    date: number
    healthChecklist: number
    meals: number
    macros: number
    waterIntakeMl: number
    milkIntakeMl: number
    sleepHours: number
    energyLevel: number
    moodLevel: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DailyHealthAvgAggregateInputType = {
    waterIntakeMl?: true
    milkIntakeMl?: true
    sleepHours?: true
    energyLevel?: true
    moodLevel?: true
  }

  export type DailyHealthSumAggregateInputType = {
    waterIntakeMl?: true
    milkIntakeMl?: true
    sleepHours?: true
    energyLevel?: true
    moodLevel?: true
  }

  export type DailyHealthMinAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    waterIntakeMl?: true
    milkIntakeMl?: true
    sleepHours?: true
    energyLevel?: true
    moodLevel?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DailyHealthMaxAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    waterIntakeMl?: true
    milkIntakeMl?: true
    sleepHours?: true
    energyLevel?: true
    moodLevel?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DailyHealthCountAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    healthChecklist?: true
    meals?: true
    macros?: true
    waterIntakeMl?: true
    milkIntakeMl?: true
    sleepHours?: true
    energyLevel?: true
    moodLevel?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DailyHealthAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyHealth to aggregate.
     */
    where?: DailyHealthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyHealths to fetch.
     */
    orderBy?: DailyHealthOrderByWithRelationInput | DailyHealthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DailyHealthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyHealths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyHealths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DailyHealths
    **/
    _count?: true | DailyHealthCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DailyHealthAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DailyHealthSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DailyHealthMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DailyHealthMaxAggregateInputType
  }

  export type GetDailyHealthAggregateType<T extends DailyHealthAggregateArgs> = {
        [P in keyof T & keyof AggregateDailyHealth]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDailyHealth[P]>
      : GetScalarType<T[P], AggregateDailyHealth[P]>
  }




  export type DailyHealthGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyHealthWhereInput
    orderBy?: DailyHealthOrderByWithAggregationInput | DailyHealthOrderByWithAggregationInput[]
    by: DailyHealthScalarFieldEnum[] | DailyHealthScalarFieldEnum
    having?: DailyHealthScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DailyHealthCountAggregateInputType | true
    _avg?: DailyHealthAvgAggregateInputType
    _sum?: DailyHealthSumAggregateInputType
    _min?: DailyHealthMinAggregateInputType
    _max?: DailyHealthMaxAggregateInputType
  }

  export type DailyHealthGroupByOutputType = {
    id: string
    userId: string
    date: string
    healthChecklist: JsonValue
    meals: JsonValue
    macros: JsonValue
    waterIntakeMl: number
    milkIntakeMl: number
    sleepHours: number
    energyLevel: number | null
    moodLevel: number | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: DailyHealthCountAggregateOutputType | null
    _avg: DailyHealthAvgAggregateOutputType | null
    _sum: DailyHealthSumAggregateOutputType | null
    _min: DailyHealthMinAggregateOutputType | null
    _max: DailyHealthMaxAggregateOutputType | null
  }

  type GetDailyHealthGroupByPayload<T extends DailyHealthGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DailyHealthGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DailyHealthGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DailyHealthGroupByOutputType[P]>
            : GetScalarType<T[P], DailyHealthGroupByOutputType[P]>
        }
      >
    >


  export type DailyHealthSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    healthChecklist?: boolean
    meals?: boolean
    macros?: boolean
    waterIntakeMl?: boolean
    milkIntakeMl?: boolean
    sleepHours?: boolean
    energyLevel?: boolean
    moodLevel?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailyHealth"]>

  export type DailyHealthSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    healthChecklist?: boolean
    meals?: boolean
    macros?: boolean
    waterIntakeMl?: boolean
    milkIntakeMl?: boolean
    sleepHours?: boolean
    energyLevel?: boolean
    moodLevel?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailyHealth"]>

  export type DailyHealthSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    healthChecklist?: boolean
    meals?: boolean
    macros?: boolean
    waterIntakeMl?: boolean
    milkIntakeMl?: boolean
    sleepHours?: boolean
    energyLevel?: boolean
    moodLevel?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailyHealth"]>

  export type DailyHealthSelectScalar = {
    id?: boolean
    userId?: boolean
    date?: boolean
    healthChecklist?: boolean
    meals?: boolean
    macros?: boolean
    waterIntakeMl?: boolean
    milkIntakeMl?: boolean
    sleepHours?: boolean
    energyLevel?: boolean
    moodLevel?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DailyHealthOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "date" | "healthChecklist" | "meals" | "macros" | "waterIntakeMl" | "milkIntakeMl" | "sleepHours" | "energyLevel" | "moodLevel" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["dailyHealth"]>
  export type DailyHealthInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DailyHealthIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DailyHealthIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DailyHealthPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DailyHealth"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      date: string
      healthChecklist: Prisma.JsonValue
      meals: Prisma.JsonValue
      macros: Prisma.JsonValue
      waterIntakeMl: number
      milkIntakeMl: number
      sleepHours: number
      energyLevel: number | null
      moodLevel: number | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dailyHealth"]>
    composites: {}
  }

  type DailyHealthGetPayload<S extends boolean | null | undefined | DailyHealthDefaultArgs> = $Result.GetResult<Prisma.$DailyHealthPayload, S>

  type DailyHealthCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DailyHealthFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DailyHealthCountAggregateInputType | true
    }

  export interface DailyHealthDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DailyHealth'], meta: { name: 'DailyHealth' } }
    /**
     * Find zero or one DailyHealth that matches the filter.
     * @param {DailyHealthFindUniqueArgs} args - Arguments to find a DailyHealth
     * @example
     * // Get one DailyHealth
     * const dailyHealth = await prisma.dailyHealth.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DailyHealthFindUniqueArgs>(args: SelectSubset<T, DailyHealthFindUniqueArgs<ExtArgs>>): Prisma__DailyHealthClient<$Result.GetResult<Prisma.$DailyHealthPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DailyHealth that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DailyHealthFindUniqueOrThrowArgs} args - Arguments to find a DailyHealth
     * @example
     * // Get one DailyHealth
     * const dailyHealth = await prisma.dailyHealth.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DailyHealthFindUniqueOrThrowArgs>(args: SelectSubset<T, DailyHealthFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DailyHealthClient<$Result.GetResult<Prisma.$DailyHealthPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DailyHealth that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyHealthFindFirstArgs} args - Arguments to find a DailyHealth
     * @example
     * // Get one DailyHealth
     * const dailyHealth = await prisma.dailyHealth.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DailyHealthFindFirstArgs>(args?: SelectSubset<T, DailyHealthFindFirstArgs<ExtArgs>>): Prisma__DailyHealthClient<$Result.GetResult<Prisma.$DailyHealthPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DailyHealth that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyHealthFindFirstOrThrowArgs} args - Arguments to find a DailyHealth
     * @example
     * // Get one DailyHealth
     * const dailyHealth = await prisma.dailyHealth.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DailyHealthFindFirstOrThrowArgs>(args?: SelectSubset<T, DailyHealthFindFirstOrThrowArgs<ExtArgs>>): Prisma__DailyHealthClient<$Result.GetResult<Prisma.$DailyHealthPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DailyHealths that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyHealthFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DailyHealths
     * const dailyHealths = await prisma.dailyHealth.findMany()
     * 
     * // Get first 10 DailyHealths
     * const dailyHealths = await prisma.dailyHealth.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dailyHealthWithIdOnly = await prisma.dailyHealth.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DailyHealthFindManyArgs>(args?: SelectSubset<T, DailyHealthFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyHealthPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DailyHealth.
     * @param {DailyHealthCreateArgs} args - Arguments to create a DailyHealth.
     * @example
     * // Create one DailyHealth
     * const DailyHealth = await prisma.dailyHealth.create({
     *   data: {
     *     // ... data to create a DailyHealth
     *   }
     * })
     * 
     */
    create<T extends DailyHealthCreateArgs>(args: SelectSubset<T, DailyHealthCreateArgs<ExtArgs>>): Prisma__DailyHealthClient<$Result.GetResult<Prisma.$DailyHealthPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DailyHealths.
     * @param {DailyHealthCreateManyArgs} args - Arguments to create many DailyHealths.
     * @example
     * // Create many DailyHealths
     * const dailyHealth = await prisma.dailyHealth.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DailyHealthCreateManyArgs>(args?: SelectSubset<T, DailyHealthCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DailyHealths and returns the data saved in the database.
     * @param {DailyHealthCreateManyAndReturnArgs} args - Arguments to create many DailyHealths.
     * @example
     * // Create many DailyHealths
     * const dailyHealth = await prisma.dailyHealth.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DailyHealths and only return the `id`
     * const dailyHealthWithIdOnly = await prisma.dailyHealth.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DailyHealthCreateManyAndReturnArgs>(args?: SelectSubset<T, DailyHealthCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyHealthPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DailyHealth.
     * @param {DailyHealthDeleteArgs} args - Arguments to delete one DailyHealth.
     * @example
     * // Delete one DailyHealth
     * const DailyHealth = await prisma.dailyHealth.delete({
     *   where: {
     *     // ... filter to delete one DailyHealth
     *   }
     * })
     * 
     */
    delete<T extends DailyHealthDeleteArgs>(args: SelectSubset<T, DailyHealthDeleteArgs<ExtArgs>>): Prisma__DailyHealthClient<$Result.GetResult<Prisma.$DailyHealthPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DailyHealth.
     * @param {DailyHealthUpdateArgs} args - Arguments to update one DailyHealth.
     * @example
     * // Update one DailyHealth
     * const dailyHealth = await prisma.dailyHealth.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DailyHealthUpdateArgs>(args: SelectSubset<T, DailyHealthUpdateArgs<ExtArgs>>): Prisma__DailyHealthClient<$Result.GetResult<Prisma.$DailyHealthPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DailyHealths.
     * @param {DailyHealthDeleteManyArgs} args - Arguments to filter DailyHealths to delete.
     * @example
     * // Delete a few DailyHealths
     * const { count } = await prisma.dailyHealth.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DailyHealthDeleteManyArgs>(args?: SelectSubset<T, DailyHealthDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyHealths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyHealthUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DailyHealths
     * const dailyHealth = await prisma.dailyHealth.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DailyHealthUpdateManyArgs>(args: SelectSubset<T, DailyHealthUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyHealths and returns the data updated in the database.
     * @param {DailyHealthUpdateManyAndReturnArgs} args - Arguments to update many DailyHealths.
     * @example
     * // Update many DailyHealths
     * const dailyHealth = await prisma.dailyHealth.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DailyHealths and only return the `id`
     * const dailyHealthWithIdOnly = await prisma.dailyHealth.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DailyHealthUpdateManyAndReturnArgs>(args: SelectSubset<T, DailyHealthUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyHealthPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DailyHealth.
     * @param {DailyHealthUpsertArgs} args - Arguments to update or create a DailyHealth.
     * @example
     * // Update or create a DailyHealth
     * const dailyHealth = await prisma.dailyHealth.upsert({
     *   create: {
     *     // ... data to create a DailyHealth
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DailyHealth we want to update
     *   }
     * })
     */
    upsert<T extends DailyHealthUpsertArgs>(args: SelectSubset<T, DailyHealthUpsertArgs<ExtArgs>>): Prisma__DailyHealthClient<$Result.GetResult<Prisma.$DailyHealthPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DailyHealths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyHealthCountArgs} args - Arguments to filter DailyHealths to count.
     * @example
     * // Count the number of DailyHealths
     * const count = await prisma.dailyHealth.count({
     *   where: {
     *     // ... the filter for the DailyHealths we want to count
     *   }
     * })
    **/
    count<T extends DailyHealthCountArgs>(
      args?: Subset<T, DailyHealthCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DailyHealthCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DailyHealth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyHealthAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DailyHealthAggregateArgs>(args: Subset<T, DailyHealthAggregateArgs>): Prisma.PrismaPromise<GetDailyHealthAggregateType<T>>

    /**
     * Group by DailyHealth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyHealthGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DailyHealthGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DailyHealthGroupByArgs['orderBy'] }
        : { orderBy?: DailyHealthGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DailyHealthGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDailyHealthGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DailyHealth model
   */
  readonly fields: DailyHealthFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DailyHealth.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DailyHealthClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DailyHealth model
   */
  interface DailyHealthFieldRefs {
    readonly id: FieldRef<"DailyHealth", 'String'>
    readonly userId: FieldRef<"DailyHealth", 'String'>
    readonly date: FieldRef<"DailyHealth", 'String'>
    readonly healthChecklist: FieldRef<"DailyHealth", 'Json'>
    readonly meals: FieldRef<"DailyHealth", 'Json'>
    readonly macros: FieldRef<"DailyHealth", 'Json'>
    readonly waterIntakeMl: FieldRef<"DailyHealth", 'Int'>
    readonly milkIntakeMl: FieldRef<"DailyHealth", 'Int'>
    readonly sleepHours: FieldRef<"DailyHealth", 'Float'>
    readonly energyLevel: FieldRef<"DailyHealth", 'Int'>
    readonly moodLevel: FieldRef<"DailyHealth", 'Int'>
    readonly notes: FieldRef<"DailyHealth", 'String'>
    readonly createdAt: FieldRef<"DailyHealth", 'DateTime'>
    readonly updatedAt: FieldRef<"DailyHealth", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DailyHealth findUnique
   */
  export type DailyHealthFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyHealth
     */
    select?: DailyHealthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyHealth
     */
    omit?: DailyHealthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyHealthInclude<ExtArgs> | null
    /**
     * Filter, which DailyHealth to fetch.
     */
    where: DailyHealthWhereUniqueInput
  }

  /**
   * DailyHealth findUniqueOrThrow
   */
  export type DailyHealthFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyHealth
     */
    select?: DailyHealthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyHealth
     */
    omit?: DailyHealthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyHealthInclude<ExtArgs> | null
    /**
     * Filter, which DailyHealth to fetch.
     */
    where: DailyHealthWhereUniqueInput
  }

  /**
   * DailyHealth findFirst
   */
  export type DailyHealthFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyHealth
     */
    select?: DailyHealthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyHealth
     */
    omit?: DailyHealthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyHealthInclude<ExtArgs> | null
    /**
     * Filter, which DailyHealth to fetch.
     */
    where?: DailyHealthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyHealths to fetch.
     */
    orderBy?: DailyHealthOrderByWithRelationInput | DailyHealthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyHealths.
     */
    cursor?: DailyHealthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyHealths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyHealths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyHealths.
     */
    distinct?: DailyHealthScalarFieldEnum | DailyHealthScalarFieldEnum[]
  }

  /**
   * DailyHealth findFirstOrThrow
   */
  export type DailyHealthFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyHealth
     */
    select?: DailyHealthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyHealth
     */
    omit?: DailyHealthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyHealthInclude<ExtArgs> | null
    /**
     * Filter, which DailyHealth to fetch.
     */
    where?: DailyHealthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyHealths to fetch.
     */
    orderBy?: DailyHealthOrderByWithRelationInput | DailyHealthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyHealths.
     */
    cursor?: DailyHealthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyHealths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyHealths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyHealths.
     */
    distinct?: DailyHealthScalarFieldEnum | DailyHealthScalarFieldEnum[]
  }

  /**
   * DailyHealth findMany
   */
  export type DailyHealthFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyHealth
     */
    select?: DailyHealthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyHealth
     */
    omit?: DailyHealthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyHealthInclude<ExtArgs> | null
    /**
     * Filter, which DailyHealths to fetch.
     */
    where?: DailyHealthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyHealths to fetch.
     */
    orderBy?: DailyHealthOrderByWithRelationInput | DailyHealthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DailyHealths.
     */
    cursor?: DailyHealthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyHealths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyHealths.
     */
    skip?: number
    distinct?: DailyHealthScalarFieldEnum | DailyHealthScalarFieldEnum[]
  }

  /**
   * DailyHealth create
   */
  export type DailyHealthCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyHealth
     */
    select?: DailyHealthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyHealth
     */
    omit?: DailyHealthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyHealthInclude<ExtArgs> | null
    /**
     * The data needed to create a DailyHealth.
     */
    data: XOR<DailyHealthCreateInput, DailyHealthUncheckedCreateInput>
  }

  /**
   * DailyHealth createMany
   */
  export type DailyHealthCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DailyHealths.
     */
    data: DailyHealthCreateManyInput | DailyHealthCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DailyHealth createManyAndReturn
   */
  export type DailyHealthCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyHealth
     */
    select?: DailyHealthSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DailyHealth
     */
    omit?: DailyHealthOmit<ExtArgs> | null
    /**
     * The data used to create many DailyHealths.
     */
    data: DailyHealthCreateManyInput | DailyHealthCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyHealthIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DailyHealth update
   */
  export type DailyHealthUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyHealth
     */
    select?: DailyHealthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyHealth
     */
    omit?: DailyHealthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyHealthInclude<ExtArgs> | null
    /**
     * The data needed to update a DailyHealth.
     */
    data: XOR<DailyHealthUpdateInput, DailyHealthUncheckedUpdateInput>
    /**
     * Choose, which DailyHealth to update.
     */
    where: DailyHealthWhereUniqueInput
  }

  /**
   * DailyHealth updateMany
   */
  export type DailyHealthUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DailyHealths.
     */
    data: XOR<DailyHealthUpdateManyMutationInput, DailyHealthUncheckedUpdateManyInput>
    /**
     * Filter which DailyHealths to update
     */
    where?: DailyHealthWhereInput
    /**
     * Limit how many DailyHealths to update.
     */
    limit?: number
  }

  /**
   * DailyHealth updateManyAndReturn
   */
  export type DailyHealthUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyHealth
     */
    select?: DailyHealthSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DailyHealth
     */
    omit?: DailyHealthOmit<ExtArgs> | null
    /**
     * The data used to update DailyHealths.
     */
    data: XOR<DailyHealthUpdateManyMutationInput, DailyHealthUncheckedUpdateManyInput>
    /**
     * Filter which DailyHealths to update
     */
    where?: DailyHealthWhereInput
    /**
     * Limit how many DailyHealths to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyHealthIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DailyHealth upsert
   */
  export type DailyHealthUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyHealth
     */
    select?: DailyHealthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyHealth
     */
    omit?: DailyHealthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyHealthInclude<ExtArgs> | null
    /**
     * The filter to search for the DailyHealth to update in case it exists.
     */
    where: DailyHealthWhereUniqueInput
    /**
     * In case the DailyHealth found by the `where` argument doesn't exist, create a new DailyHealth with this data.
     */
    create: XOR<DailyHealthCreateInput, DailyHealthUncheckedCreateInput>
    /**
     * In case the DailyHealth was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DailyHealthUpdateInput, DailyHealthUncheckedUpdateInput>
  }

  /**
   * DailyHealth delete
   */
  export type DailyHealthDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyHealth
     */
    select?: DailyHealthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyHealth
     */
    omit?: DailyHealthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyHealthInclude<ExtArgs> | null
    /**
     * Filter which DailyHealth to delete.
     */
    where: DailyHealthWhereUniqueInput
  }

  /**
   * DailyHealth deleteMany
   */
  export type DailyHealthDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyHealths to delete
     */
    where?: DailyHealthWhereInput
    /**
     * Limit how many DailyHealths to delete.
     */
    limit?: number
  }

  /**
   * DailyHealth without action
   */
  export type DailyHealthDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyHealth
     */
    select?: DailyHealthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyHealth
     */
    omit?: DailyHealthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyHealthInclude<ExtArgs> | null
  }


  /**
   * Model DailyWorkout
   */

  export type AggregateDailyWorkout = {
    _count: DailyWorkoutCountAggregateOutputType | null
    _avg: DailyWorkoutAvgAggregateOutputType | null
    _sum: DailyWorkoutSumAggregateOutputType | null
    _min: DailyWorkoutMinAggregateOutputType | null
    _max: DailyWorkoutMaxAggregateOutputType | null
  }

  export type DailyWorkoutAvgAggregateOutputType = {
    totalExercises: number | null
    completedExercises: number | null
    completionPercentage: number | null
    durationMinutes: number | null
  }

  export type DailyWorkoutSumAggregateOutputType = {
    totalExercises: number | null
    completedExercises: number | null
    completionPercentage: number | null
    durationMinutes: number | null
  }

  export type DailyWorkoutMinAggregateOutputType = {
    id: string | null
    userId: string | null
    date: string | null
    totalExercises: number | null
    completedExercises: number | null
    completionPercentage: number | null
    durationMinutes: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DailyWorkoutMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    date: string | null
    totalExercises: number | null
    completedExercises: number | null
    completionPercentage: number | null
    durationMinutes: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DailyWorkoutCountAggregateOutputType = {
    id: number
    userId: number
    date: number
    exercises: number
    totalExercises: number
    completedExercises: number
    completionPercentage: number
    durationMinutes: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DailyWorkoutAvgAggregateInputType = {
    totalExercises?: true
    completedExercises?: true
    completionPercentage?: true
    durationMinutes?: true
  }

  export type DailyWorkoutSumAggregateInputType = {
    totalExercises?: true
    completedExercises?: true
    completionPercentage?: true
    durationMinutes?: true
  }

  export type DailyWorkoutMinAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    totalExercises?: true
    completedExercises?: true
    completionPercentage?: true
    durationMinutes?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DailyWorkoutMaxAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    totalExercises?: true
    completedExercises?: true
    completionPercentage?: true
    durationMinutes?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DailyWorkoutCountAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    exercises?: true
    totalExercises?: true
    completedExercises?: true
    completionPercentage?: true
    durationMinutes?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DailyWorkoutAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyWorkout to aggregate.
     */
    where?: DailyWorkoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyWorkouts to fetch.
     */
    orderBy?: DailyWorkoutOrderByWithRelationInput | DailyWorkoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DailyWorkoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyWorkouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyWorkouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DailyWorkouts
    **/
    _count?: true | DailyWorkoutCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DailyWorkoutAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DailyWorkoutSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DailyWorkoutMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DailyWorkoutMaxAggregateInputType
  }

  export type GetDailyWorkoutAggregateType<T extends DailyWorkoutAggregateArgs> = {
        [P in keyof T & keyof AggregateDailyWorkout]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDailyWorkout[P]>
      : GetScalarType<T[P], AggregateDailyWorkout[P]>
  }




  export type DailyWorkoutGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyWorkoutWhereInput
    orderBy?: DailyWorkoutOrderByWithAggregationInput | DailyWorkoutOrderByWithAggregationInput[]
    by: DailyWorkoutScalarFieldEnum[] | DailyWorkoutScalarFieldEnum
    having?: DailyWorkoutScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DailyWorkoutCountAggregateInputType | true
    _avg?: DailyWorkoutAvgAggregateInputType
    _sum?: DailyWorkoutSumAggregateInputType
    _min?: DailyWorkoutMinAggregateInputType
    _max?: DailyWorkoutMaxAggregateInputType
  }

  export type DailyWorkoutGroupByOutputType = {
    id: string
    userId: string
    date: string
    exercises: JsonValue
    totalExercises: number
    completedExercises: number
    completionPercentage: number
    durationMinutes: number | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: DailyWorkoutCountAggregateOutputType | null
    _avg: DailyWorkoutAvgAggregateOutputType | null
    _sum: DailyWorkoutSumAggregateOutputType | null
    _min: DailyWorkoutMinAggregateOutputType | null
    _max: DailyWorkoutMaxAggregateOutputType | null
  }

  type GetDailyWorkoutGroupByPayload<T extends DailyWorkoutGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DailyWorkoutGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DailyWorkoutGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DailyWorkoutGroupByOutputType[P]>
            : GetScalarType<T[P], DailyWorkoutGroupByOutputType[P]>
        }
      >
    >


  export type DailyWorkoutSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    exercises?: boolean
    totalExercises?: boolean
    completedExercises?: boolean
    completionPercentage?: boolean
    durationMinutes?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailyWorkout"]>

  export type DailyWorkoutSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    exercises?: boolean
    totalExercises?: boolean
    completedExercises?: boolean
    completionPercentage?: boolean
    durationMinutes?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailyWorkout"]>

  export type DailyWorkoutSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    exercises?: boolean
    totalExercises?: boolean
    completedExercises?: boolean
    completionPercentage?: boolean
    durationMinutes?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailyWorkout"]>

  export type DailyWorkoutSelectScalar = {
    id?: boolean
    userId?: boolean
    date?: boolean
    exercises?: boolean
    totalExercises?: boolean
    completedExercises?: boolean
    completionPercentage?: boolean
    durationMinutes?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DailyWorkoutOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "date" | "exercises" | "totalExercises" | "completedExercises" | "completionPercentage" | "durationMinutes" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["dailyWorkout"]>
  export type DailyWorkoutInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DailyWorkoutIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DailyWorkoutIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DailyWorkoutPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DailyWorkout"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      date: string
      exercises: Prisma.JsonValue
      totalExercises: number
      completedExercises: number
      completionPercentage: number
      durationMinutes: number | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dailyWorkout"]>
    composites: {}
  }

  type DailyWorkoutGetPayload<S extends boolean | null | undefined | DailyWorkoutDefaultArgs> = $Result.GetResult<Prisma.$DailyWorkoutPayload, S>

  type DailyWorkoutCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DailyWorkoutFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DailyWorkoutCountAggregateInputType | true
    }

  export interface DailyWorkoutDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DailyWorkout'], meta: { name: 'DailyWorkout' } }
    /**
     * Find zero or one DailyWorkout that matches the filter.
     * @param {DailyWorkoutFindUniqueArgs} args - Arguments to find a DailyWorkout
     * @example
     * // Get one DailyWorkout
     * const dailyWorkout = await prisma.dailyWorkout.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DailyWorkoutFindUniqueArgs>(args: SelectSubset<T, DailyWorkoutFindUniqueArgs<ExtArgs>>): Prisma__DailyWorkoutClient<$Result.GetResult<Prisma.$DailyWorkoutPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DailyWorkout that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DailyWorkoutFindUniqueOrThrowArgs} args - Arguments to find a DailyWorkout
     * @example
     * // Get one DailyWorkout
     * const dailyWorkout = await prisma.dailyWorkout.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DailyWorkoutFindUniqueOrThrowArgs>(args: SelectSubset<T, DailyWorkoutFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DailyWorkoutClient<$Result.GetResult<Prisma.$DailyWorkoutPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DailyWorkout that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyWorkoutFindFirstArgs} args - Arguments to find a DailyWorkout
     * @example
     * // Get one DailyWorkout
     * const dailyWorkout = await prisma.dailyWorkout.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DailyWorkoutFindFirstArgs>(args?: SelectSubset<T, DailyWorkoutFindFirstArgs<ExtArgs>>): Prisma__DailyWorkoutClient<$Result.GetResult<Prisma.$DailyWorkoutPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DailyWorkout that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyWorkoutFindFirstOrThrowArgs} args - Arguments to find a DailyWorkout
     * @example
     * // Get one DailyWorkout
     * const dailyWorkout = await prisma.dailyWorkout.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DailyWorkoutFindFirstOrThrowArgs>(args?: SelectSubset<T, DailyWorkoutFindFirstOrThrowArgs<ExtArgs>>): Prisma__DailyWorkoutClient<$Result.GetResult<Prisma.$DailyWorkoutPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DailyWorkouts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyWorkoutFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DailyWorkouts
     * const dailyWorkouts = await prisma.dailyWorkout.findMany()
     * 
     * // Get first 10 DailyWorkouts
     * const dailyWorkouts = await prisma.dailyWorkout.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dailyWorkoutWithIdOnly = await prisma.dailyWorkout.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DailyWorkoutFindManyArgs>(args?: SelectSubset<T, DailyWorkoutFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyWorkoutPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DailyWorkout.
     * @param {DailyWorkoutCreateArgs} args - Arguments to create a DailyWorkout.
     * @example
     * // Create one DailyWorkout
     * const DailyWorkout = await prisma.dailyWorkout.create({
     *   data: {
     *     // ... data to create a DailyWorkout
     *   }
     * })
     * 
     */
    create<T extends DailyWorkoutCreateArgs>(args: SelectSubset<T, DailyWorkoutCreateArgs<ExtArgs>>): Prisma__DailyWorkoutClient<$Result.GetResult<Prisma.$DailyWorkoutPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DailyWorkouts.
     * @param {DailyWorkoutCreateManyArgs} args - Arguments to create many DailyWorkouts.
     * @example
     * // Create many DailyWorkouts
     * const dailyWorkout = await prisma.dailyWorkout.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DailyWorkoutCreateManyArgs>(args?: SelectSubset<T, DailyWorkoutCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DailyWorkouts and returns the data saved in the database.
     * @param {DailyWorkoutCreateManyAndReturnArgs} args - Arguments to create many DailyWorkouts.
     * @example
     * // Create many DailyWorkouts
     * const dailyWorkout = await prisma.dailyWorkout.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DailyWorkouts and only return the `id`
     * const dailyWorkoutWithIdOnly = await prisma.dailyWorkout.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DailyWorkoutCreateManyAndReturnArgs>(args?: SelectSubset<T, DailyWorkoutCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyWorkoutPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DailyWorkout.
     * @param {DailyWorkoutDeleteArgs} args - Arguments to delete one DailyWorkout.
     * @example
     * // Delete one DailyWorkout
     * const DailyWorkout = await prisma.dailyWorkout.delete({
     *   where: {
     *     // ... filter to delete one DailyWorkout
     *   }
     * })
     * 
     */
    delete<T extends DailyWorkoutDeleteArgs>(args: SelectSubset<T, DailyWorkoutDeleteArgs<ExtArgs>>): Prisma__DailyWorkoutClient<$Result.GetResult<Prisma.$DailyWorkoutPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DailyWorkout.
     * @param {DailyWorkoutUpdateArgs} args - Arguments to update one DailyWorkout.
     * @example
     * // Update one DailyWorkout
     * const dailyWorkout = await prisma.dailyWorkout.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DailyWorkoutUpdateArgs>(args: SelectSubset<T, DailyWorkoutUpdateArgs<ExtArgs>>): Prisma__DailyWorkoutClient<$Result.GetResult<Prisma.$DailyWorkoutPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DailyWorkouts.
     * @param {DailyWorkoutDeleteManyArgs} args - Arguments to filter DailyWorkouts to delete.
     * @example
     * // Delete a few DailyWorkouts
     * const { count } = await prisma.dailyWorkout.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DailyWorkoutDeleteManyArgs>(args?: SelectSubset<T, DailyWorkoutDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyWorkouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyWorkoutUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DailyWorkouts
     * const dailyWorkout = await prisma.dailyWorkout.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DailyWorkoutUpdateManyArgs>(args: SelectSubset<T, DailyWorkoutUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyWorkouts and returns the data updated in the database.
     * @param {DailyWorkoutUpdateManyAndReturnArgs} args - Arguments to update many DailyWorkouts.
     * @example
     * // Update many DailyWorkouts
     * const dailyWorkout = await prisma.dailyWorkout.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DailyWorkouts and only return the `id`
     * const dailyWorkoutWithIdOnly = await prisma.dailyWorkout.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DailyWorkoutUpdateManyAndReturnArgs>(args: SelectSubset<T, DailyWorkoutUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyWorkoutPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DailyWorkout.
     * @param {DailyWorkoutUpsertArgs} args - Arguments to update or create a DailyWorkout.
     * @example
     * // Update or create a DailyWorkout
     * const dailyWorkout = await prisma.dailyWorkout.upsert({
     *   create: {
     *     // ... data to create a DailyWorkout
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DailyWorkout we want to update
     *   }
     * })
     */
    upsert<T extends DailyWorkoutUpsertArgs>(args: SelectSubset<T, DailyWorkoutUpsertArgs<ExtArgs>>): Prisma__DailyWorkoutClient<$Result.GetResult<Prisma.$DailyWorkoutPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DailyWorkouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyWorkoutCountArgs} args - Arguments to filter DailyWorkouts to count.
     * @example
     * // Count the number of DailyWorkouts
     * const count = await prisma.dailyWorkout.count({
     *   where: {
     *     // ... the filter for the DailyWorkouts we want to count
     *   }
     * })
    **/
    count<T extends DailyWorkoutCountArgs>(
      args?: Subset<T, DailyWorkoutCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DailyWorkoutCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DailyWorkout.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyWorkoutAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DailyWorkoutAggregateArgs>(args: Subset<T, DailyWorkoutAggregateArgs>): Prisma.PrismaPromise<GetDailyWorkoutAggregateType<T>>

    /**
     * Group by DailyWorkout.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyWorkoutGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DailyWorkoutGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DailyWorkoutGroupByArgs['orderBy'] }
        : { orderBy?: DailyWorkoutGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DailyWorkoutGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDailyWorkoutGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DailyWorkout model
   */
  readonly fields: DailyWorkoutFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DailyWorkout.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DailyWorkoutClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DailyWorkout model
   */
  interface DailyWorkoutFieldRefs {
    readonly id: FieldRef<"DailyWorkout", 'String'>
    readonly userId: FieldRef<"DailyWorkout", 'String'>
    readonly date: FieldRef<"DailyWorkout", 'String'>
    readonly exercises: FieldRef<"DailyWorkout", 'Json'>
    readonly totalExercises: FieldRef<"DailyWorkout", 'Int'>
    readonly completedExercises: FieldRef<"DailyWorkout", 'Int'>
    readonly completionPercentage: FieldRef<"DailyWorkout", 'Float'>
    readonly durationMinutes: FieldRef<"DailyWorkout", 'Int'>
    readonly notes: FieldRef<"DailyWorkout", 'String'>
    readonly createdAt: FieldRef<"DailyWorkout", 'DateTime'>
    readonly updatedAt: FieldRef<"DailyWorkout", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DailyWorkout findUnique
   */
  export type DailyWorkoutFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyWorkout
     */
    select?: DailyWorkoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyWorkout
     */
    omit?: DailyWorkoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyWorkoutInclude<ExtArgs> | null
    /**
     * Filter, which DailyWorkout to fetch.
     */
    where: DailyWorkoutWhereUniqueInput
  }

  /**
   * DailyWorkout findUniqueOrThrow
   */
  export type DailyWorkoutFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyWorkout
     */
    select?: DailyWorkoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyWorkout
     */
    omit?: DailyWorkoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyWorkoutInclude<ExtArgs> | null
    /**
     * Filter, which DailyWorkout to fetch.
     */
    where: DailyWorkoutWhereUniqueInput
  }

  /**
   * DailyWorkout findFirst
   */
  export type DailyWorkoutFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyWorkout
     */
    select?: DailyWorkoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyWorkout
     */
    omit?: DailyWorkoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyWorkoutInclude<ExtArgs> | null
    /**
     * Filter, which DailyWorkout to fetch.
     */
    where?: DailyWorkoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyWorkouts to fetch.
     */
    orderBy?: DailyWorkoutOrderByWithRelationInput | DailyWorkoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyWorkouts.
     */
    cursor?: DailyWorkoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyWorkouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyWorkouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyWorkouts.
     */
    distinct?: DailyWorkoutScalarFieldEnum | DailyWorkoutScalarFieldEnum[]
  }

  /**
   * DailyWorkout findFirstOrThrow
   */
  export type DailyWorkoutFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyWorkout
     */
    select?: DailyWorkoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyWorkout
     */
    omit?: DailyWorkoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyWorkoutInclude<ExtArgs> | null
    /**
     * Filter, which DailyWorkout to fetch.
     */
    where?: DailyWorkoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyWorkouts to fetch.
     */
    orderBy?: DailyWorkoutOrderByWithRelationInput | DailyWorkoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyWorkouts.
     */
    cursor?: DailyWorkoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyWorkouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyWorkouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyWorkouts.
     */
    distinct?: DailyWorkoutScalarFieldEnum | DailyWorkoutScalarFieldEnum[]
  }

  /**
   * DailyWorkout findMany
   */
  export type DailyWorkoutFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyWorkout
     */
    select?: DailyWorkoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyWorkout
     */
    omit?: DailyWorkoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyWorkoutInclude<ExtArgs> | null
    /**
     * Filter, which DailyWorkouts to fetch.
     */
    where?: DailyWorkoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyWorkouts to fetch.
     */
    orderBy?: DailyWorkoutOrderByWithRelationInput | DailyWorkoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DailyWorkouts.
     */
    cursor?: DailyWorkoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyWorkouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyWorkouts.
     */
    skip?: number
    distinct?: DailyWorkoutScalarFieldEnum | DailyWorkoutScalarFieldEnum[]
  }

  /**
   * DailyWorkout create
   */
  export type DailyWorkoutCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyWorkout
     */
    select?: DailyWorkoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyWorkout
     */
    omit?: DailyWorkoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyWorkoutInclude<ExtArgs> | null
    /**
     * The data needed to create a DailyWorkout.
     */
    data: XOR<DailyWorkoutCreateInput, DailyWorkoutUncheckedCreateInput>
  }

  /**
   * DailyWorkout createMany
   */
  export type DailyWorkoutCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DailyWorkouts.
     */
    data: DailyWorkoutCreateManyInput | DailyWorkoutCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DailyWorkout createManyAndReturn
   */
  export type DailyWorkoutCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyWorkout
     */
    select?: DailyWorkoutSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DailyWorkout
     */
    omit?: DailyWorkoutOmit<ExtArgs> | null
    /**
     * The data used to create many DailyWorkouts.
     */
    data: DailyWorkoutCreateManyInput | DailyWorkoutCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyWorkoutIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DailyWorkout update
   */
  export type DailyWorkoutUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyWorkout
     */
    select?: DailyWorkoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyWorkout
     */
    omit?: DailyWorkoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyWorkoutInclude<ExtArgs> | null
    /**
     * The data needed to update a DailyWorkout.
     */
    data: XOR<DailyWorkoutUpdateInput, DailyWorkoutUncheckedUpdateInput>
    /**
     * Choose, which DailyWorkout to update.
     */
    where: DailyWorkoutWhereUniqueInput
  }

  /**
   * DailyWorkout updateMany
   */
  export type DailyWorkoutUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DailyWorkouts.
     */
    data: XOR<DailyWorkoutUpdateManyMutationInput, DailyWorkoutUncheckedUpdateManyInput>
    /**
     * Filter which DailyWorkouts to update
     */
    where?: DailyWorkoutWhereInput
    /**
     * Limit how many DailyWorkouts to update.
     */
    limit?: number
  }

  /**
   * DailyWorkout updateManyAndReturn
   */
  export type DailyWorkoutUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyWorkout
     */
    select?: DailyWorkoutSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DailyWorkout
     */
    omit?: DailyWorkoutOmit<ExtArgs> | null
    /**
     * The data used to update DailyWorkouts.
     */
    data: XOR<DailyWorkoutUpdateManyMutationInput, DailyWorkoutUncheckedUpdateManyInput>
    /**
     * Filter which DailyWorkouts to update
     */
    where?: DailyWorkoutWhereInput
    /**
     * Limit how many DailyWorkouts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyWorkoutIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DailyWorkout upsert
   */
  export type DailyWorkoutUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyWorkout
     */
    select?: DailyWorkoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyWorkout
     */
    omit?: DailyWorkoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyWorkoutInclude<ExtArgs> | null
    /**
     * The filter to search for the DailyWorkout to update in case it exists.
     */
    where: DailyWorkoutWhereUniqueInput
    /**
     * In case the DailyWorkout found by the `where` argument doesn't exist, create a new DailyWorkout with this data.
     */
    create: XOR<DailyWorkoutCreateInput, DailyWorkoutUncheckedCreateInput>
    /**
     * In case the DailyWorkout was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DailyWorkoutUpdateInput, DailyWorkoutUncheckedUpdateInput>
  }

  /**
   * DailyWorkout delete
   */
  export type DailyWorkoutDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyWorkout
     */
    select?: DailyWorkoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyWorkout
     */
    omit?: DailyWorkoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyWorkoutInclude<ExtArgs> | null
    /**
     * Filter which DailyWorkout to delete.
     */
    where: DailyWorkoutWhereUniqueInput
  }

  /**
   * DailyWorkout deleteMany
   */
  export type DailyWorkoutDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyWorkouts to delete
     */
    where?: DailyWorkoutWhereInput
    /**
     * Limit how many DailyWorkouts to delete.
     */
    limit?: number
  }

  /**
   * DailyWorkout without action
   */
  export type DailyWorkoutDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyWorkout
     */
    select?: DailyWorkoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyWorkout
     */
    omit?: DailyWorkoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyWorkoutInclude<ExtArgs> | null
  }


  /**
   * Model DailyRoutine
   */

  export type AggregateDailyRoutine = {
    _count: DailyRoutineCountAggregateOutputType | null
    _avg: DailyRoutineAvgAggregateOutputType | null
    _sum: DailyRoutineSumAggregateOutputType | null
    _min: DailyRoutineMinAggregateOutputType | null
    _max: DailyRoutineMaxAggregateOutputType | null
  }

  export type DailyRoutineAvgAggregateOutputType = {
    completedCount: number | null
    totalCount: number | null
    completionPercentage: number | null
  }

  export type DailyRoutineSumAggregateOutputType = {
    completedCount: number | null
    totalCount: number | null
    completionPercentage: number | null
  }

  export type DailyRoutineMinAggregateOutputType = {
    id: string | null
    userId: string | null
    date: string | null
    routineType: $Enums.RoutineType | null
    completedCount: number | null
    totalCount: number | null
    completionPercentage: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DailyRoutineMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    date: string | null
    routineType: $Enums.RoutineType | null
    completedCount: number | null
    totalCount: number | null
    completionPercentage: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DailyRoutineCountAggregateOutputType = {
    id: number
    userId: number
    date: number
    routineType: number
    items: number
    completedCount: number
    totalCount: number
    completionPercentage: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DailyRoutineAvgAggregateInputType = {
    completedCount?: true
    totalCount?: true
    completionPercentage?: true
  }

  export type DailyRoutineSumAggregateInputType = {
    completedCount?: true
    totalCount?: true
    completionPercentage?: true
  }

  export type DailyRoutineMinAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    routineType?: true
    completedCount?: true
    totalCount?: true
    completionPercentage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DailyRoutineMaxAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    routineType?: true
    completedCount?: true
    totalCount?: true
    completionPercentage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DailyRoutineCountAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    routineType?: true
    items?: true
    completedCount?: true
    totalCount?: true
    completionPercentage?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DailyRoutineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyRoutine to aggregate.
     */
    where?: DailyRoutineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyRoutines to fetch.
     */
    orderBy?: DailyRoutineOrderByWithRelationInput | DailyRoutineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DailyRoutineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyRoutines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyRoutines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DailyRoutines
    **/
    _count?: true | DailyRoutineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DailyRoutineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DailyRoutineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DailyRoutineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DailyRoutineMaxAggregateInputType
  }

  export type GetDailyRoutineAggregateType<T extends DailyRoutineAggregateArgs> = {
        [P in keyof T & keyof AggregateDailyRoutine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDailyRoutine[P]>
      : GetScalarType<T[P], AggregateDailyRoutine[P]>
  }




  export type DailyRoutineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyRoutineWhereInput
    orderBy?: DailyRoutineOrderByWithAggregationInput | DailyRoutineOrderByWithAggregationInput[]
    by: DailyRoutineScalarFieldEnum[] | DailyRoutineScalarFieldEnum
    having?: DailyRoutineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DailyRoutineCountAggregateInputType | true
    _avg?: DailyRoutineAvgAggregateInputType
    _sum?: DailyRoutineSumAggregateInputType
    _min?: DailyRoutineMinAggregateInputType
    _max?: DailyRoutineMaxAggregateInputType
  }

  export type DailyRoutineGroupByOutputType = {
    id: string
    userId: string
    date: string
    routineType: $Enums.RoutineType
    items: JsonValue
    completedCount: number
    totalCount: number
    completionPercentage: number
    createdAt: Date
    updatedAt: Date
    _count: DailyRoutineCountAggregateOutputType | null
    _avg: DailyRoutineAvgAggregateOutputType | null
    _sum: DailyRoutineSumAggregateOutputType | null
    _min: DailyRoutineMinAggregateOutputType | null
    _max: DailyRoutineMaxAggregateOutputType | null
  }

  type GetDailyRoutineGroupByPayload<T extends DailyRoutineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DailyRoutineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DailyRoutineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DailyRoutineGroupByOutputType[P]>
            : GetScalarType<T[P], DailyRoutineGroupByOutputType[P]>
        }
      >
    >


  export type DailyRoutineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    routineType?: boolean
    items?: boolean
    completedCount?: boolean
    totalCount?: boolean
    completionPercentage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailyRoutine"]>

  export type DailyRoutineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    routineType?: boolean
    items?: boolean
    completedCount?: boolean
    totalCount?: boolean
    completionPercentage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailyRoutine"]>

  export type DailyRoutineSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    routineType?: boolean
    items?: boolean
    completedCount?: boolean
    totalCount?: boolean
    completionPercentage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailyRoutine"]>

  export type DailyRoutineSelectScalar = {
    id?: boolean
    userId?: boolean
    date?: boolean
    routineType?: boolean
    items?: boolean
    completedCount?: boolean
    totalCount?: boolean
    completionPercentage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DailyRoutineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "date" | "routineType" | "items" | "completedCount" | "totalCount" | "completionPercentage" | "createdAt" | "updatedAt", ExtArgs["result"]["dailyRoutine"]>
  export type DailyRoutineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DailyRoutineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DailyRoutineIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DailyRoutinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DailyRoutine"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      date: string
      routineType: $Enums.RoutineType
      items: Prisma.JsonValue
      completedCount: number
      totalCount: number
      completionPercentage: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dailyRoutine"]>
    composites: {}
  }

  type DailyRoutineGetPayload<S extends boolean | null | undefined | DailyRoutineDefaultArgs> = $Result.GetResult<Prisma.$DailyRoutinePayload, S>

  type DailyRoutineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DailyRoutineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DailyRoutineCountAggregateInputType | true
    }

  export interface DailyRoutineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DailyRoutine'], meta: { name: 'DailyRoutine' } }
    /**
     * Find zero or one DailyRoutine that matches the filter.
     * @param {DailyRoutineFindUniqueArgs} args - Arguments to find a DailyRoutine
     * @example
     * // Get one DailyRoutine
     * const dailyRoutine = await prisma.dailyRoutine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DailyRoutineFindUniqueArgs>(args: SelectSubset<T, DailyRoutineFindUniqueArgs<ExtArgs>>): Prisma__DailyRoutineClient<$Result.GetResult<Prisma.$DailyRoutinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DailyRoutine that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DailyRoutineFindUniqueOrThrowArgs} args - Arguments to find a DailyRoutine
     * @example
     * // Get one DailyRoutine
     * const dailyRoutine = await prisma.dailyRoutine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DailyRoutineFindUniqueOrThrowArgs>(args: SelectSubset<T, DailyRoutineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DailyRoutineClient<$Result.GetResult<Prisma.$DailyRoutinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DailyRoutine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyRoutineFindFirstArgs} args - Arguments to find a DailyRoutine
     * @example
     * // Get one DailyRoutine
     * const dailyRoutine = await prisma.dailyRoutine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DailyRoutineFindFirstArgs>(args?: SelectSubset<T, DailyRoutineFindFirstArgs<ExtArgs>>): Prisma__DailyRoutineClient<$Result.GetResult<Prisma.$DailyRoutinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DailyRoutine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyRoutineFindFirstOrThrowArgs} args - Arguments to find a DailyRoutine
     * @example
     * // Get one DailyRoutine
     * const dailyRoutine = await prisma.dailyRoutine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DailyRoutineFindFirstOrThrowArgs>(args?: SelectSubset<T, DailyRoutineFindFirstOrThrowArgs<ExtArgs>>): Prisma__DailyRoutineClient<$Result.GetResult<Prisma.$DailyRoutinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DailyRoutines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyRoutineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DailyRoutines
     * const dailyRoutines = await prisma.dailyRoutine.findMany()
     * 
     * // Get first 10 DailyRoutines
     * const dailyRoutines = await prisma.dailyRoutine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dailyRoutineWithIdOnly = await prisma.dailyRoutine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DailyRoutineFindManyArgs>(args?: SelectSubset<T, DailyRoutineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyRoutinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DailyRoutine.
     * @param {DailyRoutineCreateArgs} args - Arguments to create a DailyRoutine.
     * @example
     * // Create one DailyRoutine
     * const DailyRoutine = await prisma.dailyRoutine.create({
     *   data: {
     *     // ... data to create a DailyRoutine
     *   }
     * })
     * 
     */
    create<T extends DailyRoutineCreateArgs>(args: SelectSubset<T, DailyRoutineCreateArgs<ExtArgs>>): Prisma__DailyRoutineClient<$Result.GetResult<Prisma.$DailyRoutinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DailyRoutines.
     * @param {DailyRoutineCreateManyArgs} args - Arguments to create many DailyRoutines.
     * @example
     * // Create many DailyRoutines
     * const dailyRoutine = await prisma.dailyRoutine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DailyRoutineCreateManyArgs>(args?: SelectSubset<T, DailyRoutineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DailyRoutines and returns the data saved in the database.
     * @param {DailyRoutineCreateManyAndReturnArgs} args - Arguments to create many DailyRoutines.
     * @example
     * // Create many DailyRoutines
     * const dailyRoutine = await prisma.dailyRoutine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DailyRoutines and only return the `id`
     * const dailyRoutineWithIdOnly = await prisma.dailyRoutine.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DailyRoutineCreateManyAndReturnArgs>(args?: SelectSubset<T, DailyRoutineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyRoutinePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DailyRoutine.
     * @param {DailyRoutineDeleteArgs} args - Arguments to delete one DailyRoutine.
     * @example
     * // Delete one DailyRoutine
     * const DailyRoutine = await prisma.dailyRoutine.delete({
     *   where: {
     *     // ... filter to delete one DailyRoutine
     *   }
     * })
     * 
     */
    delete<T extends DailyRoutineDeleteArgs>(args: SelectSubset<T, DailyRoutineDeleteArgs<ExtArgs>>): Prisma__DailyRoutineClient<$Result.GetResult<Prisma.$DailyRoutinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DailyRoutine.
     * @param {DailyRoutineUpdateArgs} args - Arguments to update one DailyRoutine.
     * @example
     * // Update one DailyRoutine
     * const dailyRoutine = await prisma.dailyRoutine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DailyRoutineUpdateArgs>(args: SelectSubset<T, DailyRoutineUpdateArgs<ExtArgs>>): Prisma__DailyRoutineClient<$Result.GetResult<Prisma.$DailyRoutinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DailyRoutines.
     * @param {DailyRoutineDeleteManyArgs} args - Arguments to filter DailyRoutines to delete.
     * @example
     * // Delete a few DailyRoutines
     * const { count } = await prisma.dailyRoutine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DailyRoutineDeleteManyArgs>(args?: SelectSubset<T, DailyRoutineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyRoutines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyRoutineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DailyRoutines
     * const dailyRoutine = await prisma.dailyRoutine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DailyRoutineUpdateManyArgs>(args: SelectSubset<T, DailyRoutineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyRoutines and returns the data updated in the database.
     * @param {DailyRoutineUpdateManyAndReturnArgs} args - Arguments to update many DailyRoutines.
     * @example
     * // Update many DailyRoutines
     * const dailyRoutine = await prisma.dailyRoutine.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DailyRoutines and only return the `id`
     * const dailyRoutineWithIdOnly = await prisma.dailyRoutine.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DailyRoutineUpdateManyAndReturnArgs>(args: SelectSubset<T, DailyRoutineUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyRoutinePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DailyRoutine.
     * @param {DailyRoutineUpsertArgs} args - Arguments to update or create a DailyRoutine.
     * @example
     * // Update or create a DailyRoutine
     * const dailyRoutine = await prisma.dailyRoutine.upsert({
     *   create: {
     *     // ... data to create a DailyRoutine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DailyRoutine we want to update
     *   }
     * })
     */
    upsert<T extends DailyRoutineUpsertArgs>(args: SelectSubset<T, DailyRoutineUpsertArgs<ExtArgs>>): Prisma__DailyRoutineClient<$Result.GetResult<Prisma.$DailyRoutinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DailyRoutines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyRoutineCountArgs} args - Arguments to filter DailyRoutines to count.
     * @example
     * // Count the number of DailyRoutines
     * const count = await prisma.dailyRoutine.count({
     *   where: {
     *     // ... the filter for the DailyRoutines we want to count
     *   }
     * })
    **/
    count<T extends DailyRoutineCountArgs>(
      args?: Subset<T, DailyRoutineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DailyRoutineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DailyRoutine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyRoutineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DailyRoutineAggregateArgs>(args: Subset<T, DailyRoutineAggregateArgs>): Prisma.PrismaPromise<GetDailyRoutineAggregateType<T>>

    /**
     * Group by DailyRoutine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyRoutineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DailyRoutineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DailyRoutineGroupByArgs['orderBy'] }
        : { orderBy?: DailyRoutineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DailyRoutineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDailyRoutineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DailyRoutine model
   */
  readonly fields: DailyRoutineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DailyRoutine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DailyRoutineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DailyRoutine model
   */
  interface DailyRoutineFieldRefs {
    readonly id: FieldRef<"DailyRoutine", 'String'>
    readonly userId: FieldRef<"DailyRoutine", 'String'>
    readonly date: FieldRef<"DailyRoutine", 'String'>
    readonly routineType: FieldRef<"DailyRoutine", 'RoutineType'>
    readonly items: FieldRef<"DailyRoutine", 'Json'>
    readonly completedCount: FieldRef<"DailyRoutine", 'Int'>
    readonly totalCount: FieldRef<"DailyRoutine", 'Int'>
    readonly completionPercentage: FieldRef<"DailyRoutine", 'Float'>
    readonly createdAt: FieldRef<"DailyRoutine", 'DateTime'>
    readonly updatedAt: FieldRef<"DailyRoutine", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DailyRoutine findUnique
   */
  export type DailyRoutineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRoutine
     */
    select?: DailyRoutineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyRoutine
     */
    omit?: DailyRoutineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRoutineInclude<ExtArgs> | null
    /**
     * Filter, which DailyRoutine to fetch.
     */
    where: DailyRoutineWhereUniqueInput
  }

  /**
   * DailyRoutine findUniqueOrThrow
   */
  export type DailyRoutineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRoutine
     */
    select?: DailyRoutineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyRoutine
     */
    omit?: DailyRoutineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRoutineInclude<ExtArgs> | null
    /**
     * Filter, which DailyRoutine to fetch.
     */
    where: DailyRoutineWhereUniqueInput
  }

  /**
   * DailyRoutine findFirst
   */
  export type DailyRoutineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRoutine
     */
    select?: DailyRoutineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyRoutine
     */
    omit?: DailyRoutineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRoutineInclude<ExtArgs> | null
    /**
     * Filter, which DailyRoutine to fetch.
     */
    where?: DailyRoutineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyRoutines to fetch.
     */
    orderBy?: DailyRoutineOrderByWithRelationInput | DailyRoutineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyRoutines.
     */
    cursor?: DailyRoutineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyRoutines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyRoutines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyRoutines.
     */
    distinct?: DailyRoutineScalarFieldEnum | DailyRoutineScalarFieldEnum[]
  }

  /**
   * DailyRoutine findFirstOrThrow
   */
  export type DailyRoutineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRoutine
     */
    select?: DailyRoutineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyRoutine
     */
    omit?: DailyRoutineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRoutineInclude<ExtArgs> | null
    /**
     * Filter, which DailyRoutine to fetch.
     */
    where?: DailyRoutineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyRoutines to fetch.
     */
    orderBy?: DailyRoutineOrderByWithRelationInput | DailyRoutineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyRoutines.
     */
    cursor?: DailyRoutineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyRoutines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyRoutines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyRoutines.
     */
    distinct?: DailyRoutineScalarFieldEnum | DailyRoutineScalarFieldEnum[]
  }

  /**
   * DailyRoutine findMany
   */
  export type DailyRoutineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRoutine
     */
    select?: DailyRoutineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyRoutine
     */
    omit?: DailyRoutineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRoutineInclude<ExtArgs> | null
    /**
     * Filter, which DailyRoutines to fetch.
     */
    where?: DailyRoutineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyRoutines to fetch.
     */
    orderBy?: DailyRoutineOrderByWithRelationInput | DailyRoutineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DailyRoutines.
     */
    cursor?: DailyRoutineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyRoutines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyRoutines.
     */
    skip?: number
    distinct?: DailyRoutineScalarFieldEnum | DailyRoutineScalarFieldEnum[]
  }

  /**
   * DailyRoutine create
   */
  export type DailyRoutineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRoutine
     */
    select?: DailyRoutineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyRoutine
     */
    omit?: DailyRoutineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRoutineInclude<ExtArgs> | null
    /**
     * The data needed to create a DailyRoutine.
     */
    data: XOR<DailyRoutineCreateInput, DailyRoutineUncheckedCreateInput>
  }

  /**
   * DailyRoutine createMany
   */
  export type DailyRoutineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DailyRoutines.
     */
    data: DailyRoutineCreateManyInput | DailyRoutineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DailyRoutine createManyAndReturn
   */
  export type DailyRoutineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRoutine
     */
    select?: DailyRoutineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DailyRoutine
     */
    omit?: DailyRoutineOmit<ExtArgs> | null
    /**
     * The data used to create many DailyRoutines.
     */
    data: DailyRoutineCreateManyInput | DailyRoutineCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRoutineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DailyRoutine update
   */
  export type DailyRoutineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRoutine
     */
    select?: DailyRoutineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyRoutine
     */
    omit?: DailyRoutineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRoutineInclude<ExtArgs> | null
    /**
     * The data needed to update a DailyRoutine.
     */
    data: XOR<DailyRoutineUpdateInput, DailyRoutineUncheckedUpdateInput>
    /**
     * Choose, which DailyRoutine to update.
     */
    where: DailyRoutineWhereUniqueInput
  }

  /**
   * DailyRoutine updateMany
   */
  export type DailyRoutineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DailyRoutines.
     */
    data: XOR<DailyRoutineUpdateManyMutationInput, DailyRoutineUncheckedUpdateManyInput>
    /**
     * Filter which DailyRoutines to update
     */
    where?: DailyRoutineWhereInput
    /**
     * Limit how many DailyRoutines to update.
     */
    limit?: number
  }

  /**
   * DailyRoutine updateManyAndReturn
   */
  export type DailyRoutineUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRoutine
     */
    select?: DailyRoutineSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DailyRoutine
     */
    omit?: DailyRoutineOmit<ExtArgs> | null
    /**
     * The data used to update DailyRoutines.
     */
    data: XOR<DailyRoutineUpdateManyMutationInput, DailyRoutineUncheckedUpdateManyInput>
    /**
     * Filter which DailyRoutines to update
     */
    where?: DailyRoutineWhereInput
    /**
     * Limit how many DailyRoutines to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRoutineIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DailyRoutine upsert
   */
  export type DailyRoutineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRoutine
     */
    select?: DailyRoutineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyRoutine
     */
    omit?: DailyRoutineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRoutineInclude<ExtArgs> | null
    /**
     * The filter to search for the DailyRoutine to update in case it exists.
     */
    where: DailyRoutineWhereUniqueInput
    /**
     * In case the DailyRoutine found by the `where` argument doesn't exist, create a new DailyRoutine with this data.
     */
    create: XOR<DailyRoutineCreateInput, DailyRoutineUncheckedCreateInput>
    /**
     * In case the DailyRoutine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DailyRoutineUpdateInput, DailyRoutineUncheckedUpdateInput>
  }

  /**
   * DailyRoutine delete
   */
  export type DailyRoutineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRoutine
     */
    select?: DailyRoutineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyRoutine
     */
    omit?: DailyRoutineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRoutineInclude<ExtArgs> | null
    /**
     * Filter which DailyRoutine to delete.
     */
    where: DailyRoutineWhereUniqueInput
  }

  /**
   * DailyRoutine deleteMany
   */
  export type DailyRoutineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyRoutines to delete
     */
    where?: DailyRoutineWhereInput
    /**
     * Limit how many DailyRoutines to delete.
     */
    limit?: number
  }

  /**
   * DailyRoutine without action
   */
  export type DailyRoutineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRoutine
     */
    select?: DailyRoutineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyRoutine
     */
    omit?: DailyRoutineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRoutineInclude<ExtArgs> | null
  }


  /**
   * Model DailyReflections
   */

  export type AggregateDailyReflections = {
    _count: DailyReflectionsCountAggregateOutputType | null
    _avg: DailyReflectionsAvgAggregateOutputType | null
    _sum: DailyReflectionsSumAggregateOutputType | null
    _min: DailyReflectionsMinAggregateOutputType | null
    _max: DailyReflectionsMaxAggregateOutputType | null
  }

  export type DailyReflectionsAvgAggregateOutputType = {
    overallRating: number | null
  }

  export type DailyReflectionsSumAggregateOutputType = {
    overallRating: number | null
  }

  export type DailyReflectionsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    date: string | null
    overallRating: number | null
    keyLearnings: string | null
    tomorrowFocus: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DailyReflectionsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    date: string | null
    overallRating: number | null
    keyLearnings: string | null
    tomorrowFocus: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DailyReflectionsCountAggregateOutputType = {
    id: number
    userId: number
    date: number
    wentWell: number
    evenBetterIf: number
    analysis: number
    patterns: number
    changes: number
    overallRating: number
    keyLearnings: number
    tomorrowFocus: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DailyReflectionsAvgAggregateInputType = {
    overallRating?: true
  }

  export type DailyReflectionsSumAggregateInputType = {
    overallRating?: true
  }

  export type DailyReflectionsMinAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    overallRating?: true
    keyLearnings?: true
    tomorrowFocus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DailyReflectionsMaxAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    overallRating?: true
    keyLearnings?: true
    tomorrowFocus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DailyReflectionsCountAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    wentWell?: true
    evenBetterIf?: true
    analysis?: true
    patterns?: true
    changes?: true
    overallRating?: true
    keyLearnings?: true
    tomorrowFocus?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DailyReflectionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyReflections to aggregate.
     */
    where?: DailyReflectionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyReflections to fetch.
     */
    orderBy?: DailyReflectionsOrderByWithRelationInput | DailyReflectionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DailyReflectionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyReflections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyReflections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DailyReflections
    **/
    _count?: true | DailyReflectionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DailyReflectionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DailyReflectionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DailyReflectionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DailyReflectionsMaxAggregateInputType
  }

  export type GetDailyReflectionsAggregateType<T extends DailyReflectionsAggregateArgs> = {
        [P in keyof T & keyof AggregateDailyReflections]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDailyReflections[P]>
      : GetScalarType<T[P], AggregateDailyReflections[P]>
  }




  export type DailyReflectionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyReflectionsWhereInput
    orderBy?: DailyReflectionsOrderByWithAggregationInput | DailyReflectionsOrderByWithAggregationInput[]
    by: DailyReflectionsScalarFieldEnum[] | DailyReflectionsScalarFieldEnum
    having?: DailyReflectionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DailyReflectionsCountAggregateInputType | true
    _avg?: DailyReflectionsAvgAggregateInputType
    _sum?: DailyReflectionsSumAggregateInputType
    _min?: DailyReflectionsMinAggregateInputType
    _max?: DailyReflectionsMaxAggregateInputType
  }

  export type DailyReflectionsGroupByOutputType = {
    id: string
    userId: string
    date: string
    wentWell: string[]
    evenBetterIf: string[]
    analysis: string[]
    patterns: string[]
    changes: string[]
    overallRating: number | null
    keyLearnings: string | null
    tomorrowFocus: string | null
    createdAt: Date
    updatedAt: Date
    _count: DailyReflectionsCountAggregateOutputType | null
    _avg: DailyReflectionsAvgAggregateOutputType | null
    _sum: DailyReflectionsSumAggregateOutputType | null
    _min: DailyReflectionsMinAggregateOutputType | null
    _max: DailyReflectionsMaxAggregateOutputType | null
  }

  type GetDailyReflectionsGroupByPayload<T extends DailyReflectionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DailyReflectionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DailyReflectionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DailyReflectionsGroupByOutputType[P]>
            : GetScalarType<T[P], DailyReflectionsGroupByOutputType[P]>
        }
      >
    >


  export type DailyReflectionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    wentWell?: boolean
    evenBetterIf?: boolean
    analysis?: boolean
    patterns?: boolean
    changes?: boolean
    overallRating?: boolean
    keyLearnings?: boolean
    tomorrowFocus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailyReflections"]>

  export type DailyReflectionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    wentWell?: boolean
    evenBetterIf?: boolean
    analysis?: boolean
    patterns?: boolean
    changes?: boolean
    overallRating?: boolean
    keyLearnings?: boolean
    tomorrowFocus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailyReflections"]>

  export type DailyReflectionsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    wentWell?: boolean
    evenBetterIf?: boolean
    analysis?: boolean
    patterns?: boolean
    changes?: boolean
    overallRating?: boolean
    keyLearnings?: boolean
    tomorrowFocus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailyReflections"]>

  export type DailyReflectionsSelectScalar = {
    id?: boolean
    userId?: boolean
    date?: boolean
    wentWell?: boolean
    evenBetterIf?: boolean
    analysis?: boolean
    patterns?: boolean
    changes?: boolean
    overallRating?: boolean
    keyLearnings?: boolean
    tomorrowFocus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DailyReflectionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "date" | "wentWell" | "evenBetterIf" | "analysis" | "patterns" | "changes" | "overallRating" | "keyLearnings" | "tomorrowFocus" | "createdAt" | "updatedAt", ExtArgs["result"]["dailyReflections"]>
  export type DailyReflectionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DailyReflectionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DailyReflectionsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DailyReflectionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DailyReflections"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      date: string
      wentWell: string[]
      evenBetterIf: string[]
      analysis: string[]
      patterns: string[]
      changes: string[]
      overallRating: number | null
      keyLearnings: string | null
      tomorrowFocus: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dailyReflections"]>
    composites: {}
  }

  type DailyReflectionsGetPayload<S extends boolean | null | undefined | DailyReflectionsDefaultArgs> = $Result.GetResult<Prisma.$DailyReflectionsPayload, S>

  type DailyReflectionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DailyReflectionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DailyReflectionsCountAggregateInputType | true
    }

  export interface DailyReflectionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DailyReflections'], meta: { name: 'DailyReflections' } }
    /**
     * Find zero or one DailyReflections that matches the filter.
     * @param {DailyReflectionsFindUniqueArgs} args - Arguments to find a DailyReflections
     * @example
     * // Get one DailyReflections
     * const dailyReflections = await prisma.dailyReflections.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DailyReflectionsFindUniqueArgs>(args: SelectSubset<T, DailyReflectionsFindUniqueArgs<ExtArgs>>): Prisma__DailyReflectionsClient<$Result.GetResult<Prisma.$DailyReflectionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DailyReflections that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DailyReflectionsFindUniqueOrThrowArgs} args - Arguments to find a DailyReflections
     * @example
     * // Get one DailyReflections
     * const dailyReflections = await prisma.dailyReflections.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DailyReflectionsFindUniqueOrThrowArgs>(args: SelectSubset<T, DailyReflectionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DailyReflectionsClient<$Result.GetResult<Prisma.$DailyReflectionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DailyReflections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyReflectionsFindFirstArgs} args - Arguments to find a DailyReflections
     * @example
     * // Get one DailyReflections
     * const dailyReflections = await prisma.dailyReflections.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DailyReflectionsFindFirstArgs>(args?: SelectSubset<T, DailyReflectionsFindFirstArgs<ExtArgs>>): Prisma__DailyReflectionsClient<$Result.GetResult<Prisma.$DailyReflectionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DailyReflections that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyReflectionsFindFirstOrThrowArgs} args - Arguments to find a DailyReflections
     * @example
     * // Get one DailyReflections
     * const dailyReflections = await prisma.dailyReflections.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DailyReflectionsFindFirstOrThrowArgs>(args?: SelectSubset<T, DailyReflectionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__DailyReflectionsClient<$Result.GetResult<Prisma.$DailyReflectionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DailyReflections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyReflectionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DailyReflections
     * const dailyReflections = await prisma.dailyReflections.findMany()
     * 
     * // Get first 10 DailyReflections
     * const dailyReflections = await prisma.dailyReflections.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dailyReflectionsWithIdOnly = await prisma.dailyReflections.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DailyReflectionsFindManyArgs>(args?: SelectSubset<T, DailyReflectionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyReflectionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DailyReflections.
     * @param {DailyReflectionsCreateArgs} args - Arguments to create a DailyReflections.
     * @example
     * // Create one DailyReflections
     * const DailyReflections = await prisma.dailyReflections.create({
     *   data: {
     *     // ... data to create a DailyReflections
     *   }
     * })
     * 
     */
    create<T extends DailyReflectionsCreateArgs>(args: SelectSubset<T, DailyReflectionsCreateArgs<ExtArgs>>): Prisma__DailyReflectionsClient<$Result.GetResult<Prisma.$DailyReflectionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DailyReflections.
     * @param {DailyReflectionsCreateManyArgs} args - Arguments to create many DailyReflections.
     * @example
     * // Create many DailyReflections
     * const dailyReflections = await prisma.dailyReflections.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DailyReflectionsCreateManyArgs>(args?: SelectSubset<T, DailyReflectionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DailyReflections and returns the data saved in the database.
     * @param {DailyReflectionsCreateManyAndReturnArgs} args - Arguments to create many DailyReflections.
     * @example
     * // Create many DailyReflections
     * const dailyReflections = await prisma.dailyReflections.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DailyReflections and only return the `id`
     * const dailyReflectionsWithIdOnly = await prisma.dailyReflections.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DailyReflectionsCreateManyAndReturnArgs>(args?: SelectSubset<T, DailyReflectionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyReflectionsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DailyReflections.
     * @param {DailyReflectionsDeleteArgs} args - Arguments to delete one DailyReflections.
     * @example
     * // Delete one DailyReflections
     * const DailyReflections = await prisma.dailyReflections.delete({
     *   where: {
     *     // ... filter to delete one DailyReflections
     *   }
     * })
     * 
     */
    delete<T extends DailyReflectionsDeleteArgs>(args: SelectSubset<T, DailyReflectionsDeleteArgs<ExtArgs>>): Prisma__DailyReflectionsClient<$Result.GetResult<Prisma.$DailyReflectionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DailyReflections.
     * @param {DailyReflectionsUpdateArgs} args - Arguments to update one DailyReflections.
     * @example
     * // Update one DailyReflections
     * const dailyReflections = await prisma.dailyReflections.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DailyReflectionsUpdateArgs>(args: SelectSubset<T, DailyReflectionsUpdateArgs<ExtArgs>>): Prisma__DailyReflectionsClient<$Result.GetResult<Prisma.$DailyReflectionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DailyReflections.
     * @param {DailyReflectionsDeleteManyArgs} args - Arguments to filter DailyReflections to delete.
     * @example
     * // Delete a few DailyReflections
     * const { count } = await prisma.dailyReflections.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DailyReflectionsDeleteManyArgs>(args?: SelectSubset<T, DailyReflectionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyReflections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyReflectionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DailyReflections
     * const dailyReflections = await prisma.dailyReflections.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DailyReflectionsUpdateManyArgs>(args: SelectSubset<T, DailyReflectionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyReflections and returns the data updated in the database.
     * @param {DailyReflectionsUpdateManyAndReturnArgs} args - Arguments to update many DailyReflections.
     * @example
     * // Update many DailyReflections
     * const dailyReflections = await prisma.dailyReflections.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DailyReflections and only return the `id`
     * const dailyReflectionsWithIdOnly = await prisma.dailyReflections.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DailyReflectionsUpdateManyAndReturnArgs>(args: SelectSubset<T, DailyReflectionsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyReflectionsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DailyReflections.
     * @param {DailyReflectionsUpsertArgs} args - Arguments to update or create a DailyReflections.
     * @example
     * // Update or create a DailyReflections
     * const dailyReflections = await prisma.dailyReflections.upsert({
     *   create: {
     *     // ... data to create a DailyReflections
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DailyReflections we want to update
     *   }
     * })
     */
    upsert<T extends DailyReflectionsUpsertArgs>(args: SelectSubset<T, DailyReflectionsUpsertArgs<ExtArgs>>): Prisma__DailyReflectionsClient<$Result.GetResult<Prisma.$DailyReflectionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DailyReflections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyReflectionsCountArgs} args - Arguments to filter DailyReflections to count.
     * @example
     * // Count the number of DailyReflections
     * const count = await prisma.dailyReflections.count({
     *   where: {
     *     // ... the filter for the DailyReflections we want to count
     *   }
     * })
    **/
    count<T extends DailyReflectionsCountArgs>(
      args?: Subset<T, DailyReflectionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DailyReflectionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DailyReflections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyReflectionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DailyReflectionsAggregateArgs>(args: Subset<T, DailyReflectionsAggregateArgs>): Prisma.PrismaPromise<GetDailyReflectionsAggregateType<T>>

    /**
     * Group by DailyReflections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyReflectionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DailyReflectionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DailyReflectionsGroupByArgs['orderBy'] }
        : { orderBy?: DailyReflectionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DailyReflectionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDailyReflectionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DailyReflections model
   */
  readonly fields: DailyReflectionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DailyReflections.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DailyReflectionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DailyReflections model
   */
  interface DailyReflectionsFieldRefs {
    readonly id: FieldRef<"DailyReflections", 'String'>
    readonly userId: FieldRef<"DailyReflections", 'String'>
    readonly date: FieldRef<"DailyReflections", 'String'>
    readonly wentWell: FieldRef<"DailyReflections", 'String[]'>
    readonly evenBetterIf: FieldRef<"DailyReflections", 'String[]'>
    readonly analysis: FieldRef<"DailyReflections", 'String[]'>
    readonly patterns: FieldRef<"DailyReflections", 'String[]'>
    readonly changes: FieldRef<"DailyReflections", 'String[]'>
    readonly overallRating: FieldRef<"DailyReflections", 'Int'>
    readonly keyLearnings: FieldRef<"DailyReflections", 'String'>
    readonly tomorrowFocus: FieldRef<"DailyReflections", 'String'>
    readonly createdAt: FieldRef<"DailyReflections", 'DateTime'>
    readonly updatedAt: FieldRef<"DailyReflections", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DailyReflections findUnique
   */
  export type DailyReflectionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyReflections
     */
    select?: DailyReflectionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyReflections
     */
    omit?: DailyReflectionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyReflectionsInclude<ExtArgs> | null
    /**
     * Filter, which DailyReflections to fetch.
     */
    where: DailyReflectionsWhereUniqueInput
  }

  /**
   * DailyReflections findUniqueOrThrow
   */
  export type DailyReflectionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyReflections
     */
    select?: DailyReflectionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyReflections
     */
    omit?: DailyReflectionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyReflectionsInclude<ExtArgs> | null
    /**
     * Filter, which DailyReflections to fetch.
     */
    where: DailyReflectionsWhereUniqueInput
  }

  /**
   * DailyReflections findFirst
   */
  export type DailyReflectionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyReflections
     */
    select?: DailyReflectionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyReflections
     */
    omit?: DailyReflectionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyReflectionsInclude<ExtArgs> | null
    /**
     * Filter, which DailyReflections to fetch.
     */
    where?: DailyReflectionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyReflections to fetch.
     */
    orderBy?: DailyReflectionsOrderByWithRelationInput | DailyReflectionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyReflections.
     */
    cursor?: DailyReflectionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyReflections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyReflections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyReflections.
     */
    distinct?: DailyReflectionsScalarFieldEnum | DailyReflectionsScalarFieldEnum[]
  }

  /**
   * DailyReflections findFirstOrThrow
   */
  export type DailyReflectionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyReflections
     */
    select?: DailyReflectionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyReflections
     */
    omit?: DailyReflectionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyReflectionsInclude<ExtArgs> | null
    /**
     * Filter, which DailyReflections to fetch.
     */
    where?: DailyReflectionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyReflections to fetch.
     */
    orderBy?: DailyReflectionsOrderByWithRelationInput | DailyReflectionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyReflections.
     */
    cursor?: DailyReflectionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyReflections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyReflections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyReflections.
     */
    distinct?: DailyReflectionsScalarFieldEnum | DailyReflectionsScalarFieldEnum[]
  }

  /**
   * DailyReflections findMany
   */
  export type DailyReflectionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyReflections
     */
    select?: DailyReflectionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyReflections
     */
    omit?: DailyReflectionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyReflectionsInclude<ExtArgs> | null
    /**
     * Filter, which DailyReflections to fetch.
     */
    where?: DailyReflectionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyReflections to fetch.
     */
    orderBy?: DailyReflectionsOrderByWithRelationInput | DailyReflectionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DailyReflections.
     */
    cursor?: DailyReflectionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyReflections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyReflections.
     */
    skip?: number
    distinct?: DailyReflectionsScalarFieldEnum | DailyReflectionsScalarFieldEnum[]
  }

  /**
   * DailyReflections create
   */
  export type DailyReflectionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyReflections
     */
    select?: DailyReflectionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyReflections
     */
    omit?: DailyReflectionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyReflectionsInclude<ExtArgs> | null
    /**
     * The data needed to create a DailyReflections.
     */
    data: XOR<DailyReflectionsCreateInput, DailyReflectionsUncheckedCreateInput>
  }

  /**
   * DailyReflections createMany
   */
  export type DailyReflectionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DailyReflections.
     */
    data: DailyReflectionsCreateManyInput | DailyReflectionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DailyReflections createManyAndReturn
   */
  export type DailyReflectionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyReflections
     */
    select?: DailyReflectionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DailyReflections
     */
    omit?: DailyReflectionsOmit<ExtArgs> | null
    /**
     * The data used to create many DailyReflections.
     */
    data: DailyReflectionsCreateManyInput | DailyReflectionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyReflectionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DailyReflections update
   */
  export type DailyReflectionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyReflections
     */
    select?: DailyReflectionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyReflections
     */
    omit?: DailyReflectionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyReflectionsInclude<ExtArgs> | null
    /**
     * The data needed to update a DailyReflections.
     */
    data: XOR<DailyReflectionsUpdateInput, DailyReflectionsUncheckedUpdateInput>
    /**
     * Choose, which DailyReflections to update.
     */
    where: DailyReflectionsWhereUniqueInput
  }

  /**
   * DailyReflections updateMany
   */
  export type DailyReflectionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DailyReflections.
     */
    data: XOR<DailyReflectionsUpdateManyMutationInput, DailyReflectionsUncheckedUpdateManyInput>
    /**
     * Filter which DailyReflections to update
     */
    where?: DailyReflectionsWhereInput
    /**
     * Limit how many DailyReflections to update.
     */
    limit?: number
  }

  /**
   * DailyReflections updateManyAndReturn
   */
  export type DailyReflectionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyReflections
     */
    select?: DailyReflectionsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DailyReflections
     */
    omit?: DailyReflectionsOmit<ExtArgs> | null
    /**
     * The data used to update DailyReflections.
     */
    data: XOR<DailyReflectionsUpdateManyMutationInput, DailyReflectionsUncheckedUpdateManyInput>
    /**
     * Filter which DailyReflections to update
     */
    where?: DailyReflectionsWhereInput
    /**
     * Limit how many DailyReflections to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyReflectionsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DailyReflections upsert
   */
  export type DailyReflectionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyReflections
     */
    select?: DailyReflectionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyReflections
     */
    omit?: DailyReflectionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyReflectionsInclude<ExtArgs> | null
    /**
     * The filter to search for the DailyReflections to update in case it exists.
     */
    where: DailyReflectionsWhereUniqueInput
    /**
     * In case the DailyReflections found by the `where` argument doesn't exist, create a new DailyReflections with this data.
     */
    create: XOR<DailyReflectionsCreateInput, DailyReflectionsUncheckedCreateInput>
    /**
     * In case the DailyReflections was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DailyReflectionsUpdateInput, DailyReflectionsUncheckedUpdateInput>
  }

  /**
   * DailyReflections delete
   */
  export type DailyReflectionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyReflections
     */
    select?: DailyReflectionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyReflections
     */
    omit?: DailyReflectionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyReflectionsInclude<ExtArgs> | null
    /**
     * Filter which DailyReflections to delete.
     */
    where: DailyReflectionsWhereUniqueInput
  }

  /**
   * DailyReflections deleteMany
   */
  export type DailyReflectionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyReflections to delete
     */
    where?: DailyReflectionsWhereInput
    /**
     * Limit how many DailyReflections to delete.
     */
    limit?: number
  }

  /**
   * DailyReflections without action
   */
  export type DailyReflectionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyReflections
     */
    select?: DailyReflectionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyReflections
     */
    omit?: DailyReflectionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyReflectionsInclude<ExtArgs> | null
  }


  /**
   * Model TimeBlock
   */

  export type AggregateTimeBlock = {
    _count: TimeBlockCountAggregateOutputType | null
    _min: TimeBlockMinAggregateOutputType | null
    _max: TimeBlockMaxAggregateOutputType | null
  }

  export type TimeBlockMinAggregateOutputType = {
    id: string | null
    userId: string | null
    date: string | null
    startTime: string | null
    endTime: string | null
    title: string | null
    description: string | null
    category: $Enums.TimeBlockCategory | null
    completed: boolean | null
    actualStart: string | null
    actualEnd: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TimeBlockMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    date: string | null
    startTime: string | null
    endTime: string | null
    title: string | null
    description: string | null
    category: $Enums.TimeBlockCategory | null
    completed: boolean | null
    actualStart: string | null
    actualEnd: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TimeBlockCountAggregateOutputType = {
    id: number
    userId: number
    date: number
    startTime: number
    endTime: number
    title: number
    description: number
    category: number
    completed: number
    actualStart: number
    actualEnd: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TimeBlockMinAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    startTime?: true
    endTime?: true
    title?: true
    description?: true
    category?: true
    completed?: true
    actualStart?: true
    actualEnd?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TimeBlockMaxAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    startTime?: true
    endTime?: true
    title?: true
    description?: true
    category?: true
    completed?: true
    actualStart?: true
    actualEnd?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TimeBlockCountAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    startTime?: true
    endTime?: true
    title?: true
    description?: true
    category?: true
    completed?: true
    actualStart?: true
    actualEnd?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TimeBlockAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TimeBlock to aggregate.
     */
    where?: TimeBlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeBlocks to fetch.
     */
    orderBy?: TimeBlockOrderByWithRelationInput | TimeBlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TimeBlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeBlocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeBlocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TimeBlocks
    **/
    _count?: true | TimeBlockCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TimeBlockMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TimeBlockMaxAggregateInputType
  }

  export type GetTimeBlockAggregateType<T extends TimeBlockAggregateArgs> = {
        [P in keyof T & keyof AggregateTimeBlock]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTimeBlock[P]>
      : GetScalarType<T[P], AggregateTimeBlock[P]>
  }




  export type TimeBlockGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimeBlockWhereInput
    orderBy?: TimeBlockOrderByWithAggregationInput | TimeBlockOrderByWithAggregationInput[]
    by: TimeBlockScalarFieldEnum[] | TimeBlockScalarFieldEnum
    having?: TimeBlockScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TimeBlockCountAggregateInputType | true
    _min?: TimeBlockMinAggregateInputType
    _max?: TimeBlockMaxAggregateInputType
  }

  export type TimeBlockGroupByOutputType = {
    id: string
    userId: string
    date: string
    startTime: string
    endTime: string
    title: string
    description: string | null
    category: $Enums.TimeBlockCategory
    completed: boolean
    actualStart: string | null
    actualEnd: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: TimeBlockCountAggregateOutputType | null
    _min: TimeBlockMinAggregateOutputType | null
    _max: TimeBlockMaxAggregateOutputType | null
  }

  type GetTimeBlockGroupByPayload<T extends TimeBlockGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TimeBlockGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TimeBlockGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TimeBlockGroupByOutputType[P]>
            : GetScalarType<T[P], TimeBlockGroupByOutputType[P]>
        }
      >
    >


  export type TimeBlockSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    completed?: boolean
    actualStart?: boolean
    actualEnd?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["timeBlock"]>

  export type TimeBlockSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    completed?: boolean
    actualStart?: boolean
    actualEnd?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["timeBlock"]>

  export type TimeBlockSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    completed?: boolean
    actualStart?: boolean
    actualEnd?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["timeBlock"]>

  export type TimeBlockSelectScalar = {
    id?: boolean
    userId?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    completed?: boolean
    actualStart?: boolean
    actualEnd?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TimeBlockOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "date" | "startTime" | "endTime" | "title" | "description" | "category" | "completed" | "actualStart" | "actualEnd" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["timeBlock"]>
  export type TimeBlockInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TimeBlockIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TimeBlockIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TimeBlockPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TimeBlock"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      date: string
      startTime: string
      endTime: string
      title: string
      description: string | null
      category: $Enums.TimeBlockCategory
      completed: boolean
      actualStart: string | null
      actualEnd: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["timeBlock"]>
    composites: {}
  }

  type TimeBlockGetPayload<S extends boolean | null | undefined | TimeBlockDefaultArgs> = $Result.GetResult<Prisma.$TimeBlockPayload, S>

  type TimeBlockCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TimeBlockFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TimeBlockCountAggregateInputType | true
    }

  export interface TimeBlockDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TimeBlock'], meta: { name: 'TimeBlock' } }
    /**
     * Find zero or one TimeBlock that matches the filter.
     * @param {TimeBlockFindUniqueArgs} args - Arguments to find a TimeBlock
     * @example
     * // Get one TimeBlock
     * const timeBlock = await prisma.timeBlock.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TimeBlockFindUniqueArgs>(args: SelectSubset<T, TimeBlockFindUniqueArgs<ExtArgs>>): Prisma__TimeBlockClient<$Result.GetResult<Prisma.$TimeBlockPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TimeBlock that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TimeBlockFindUniqueOrThrowArgs} args - Arguments to find a TimeBlock
     * @example
     * // Get one TimeBlock
     * const timeBlock = await prisma.timeBlock.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TimeBlockFindUniqueOrThrowArgs>(args: SelectSubset<T, TimeBlockFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TimeBlockClient<$Result.GetResult<Prisma.$TimeBlockPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TimeBlock that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeBlockFindFirstArgs} args - Arguments to find a TimeBlock
     * @example
     * // Get one TimeBlock
     * const timeBlock = await prisma.timeBlock.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TimeBlockFindFirstArgs>(args?: SelectSubset<T, TimeBlockFindFirstArgs<ExtArgs>>): Prisma__TimeBlockClient<$Result.GetResult<Prisma.$TimeBlockPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TimeBlock that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeBlockFindFirstOrThrowArgs} args - Arguments to find a TimeBlock
     * @example
     * // Get one TimeBlock
     * const timeBlock = await prisma.timeBlock.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TimeBlockFindFirstOrThrowArgs>(args?: SelectSubset<T, TimeBlockFindFirstOrThrowArgs<ExtArgs>>): Prisma__TimeBlockClient<$Result.GetResult<Prisma.$TimeBlockPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TimeBlocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeBlockFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TimeBlocks
     * const timeBlocks = await prisma.timeBlock.findMany()
     * 
     * // Get first 10 TimeBlocks
     * const timeBlocks = await prisma.timeBlock.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const timeBlockWithIdOnly = await prisma.timeBlock.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TimeBlockFindManyArgs>(args?: SelectSubset<T, TimeBlockFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeBlockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TimeBlock.
     * @param {TimeBlockCreateArgs} args - Arguments to create a TimeBlock.
     * @example
     * // Create one TimeBlock
     * const TimeBlock = await prisma.timeBlock.create({
     *   data: {
     *     // ... data to create a TimeBlock
     *   }
     * })
     * 
     */
    create<T extends TimeBlockCreateArgs>(args: SelectSubset<T, TimeBlockCreateArgs<ExtArgs>>): Prisma__TimeBlockClient<$Result.GetResult<Prisma.$TimeBlockPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TimeBlocks.
     * @param {TimeBlockCreateManyArgs} args - Arguments to create many TimeBlocks.
     * @example
     * // Create many TimeBlocks
     * const timeBlock = await prisma.timeBlock.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TimeBlockCreateManyArgs>(args?: SelectSubset<T, TimeBlockCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TimeBlocks and returns the data saved in the database.
     * @param {TimeBlockCreateManyAndReturnArgs} args - Arguments to create many TimeBlocks.
     * @example
     * // Create many TimeBlocks
     * const timeBlock = await prisma.timeBlock.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TimeBlocks and only return the `id`
     * const timeBlockWithIdOnly = await prisma.timeBlock.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TimeBlockCreateManyAndReturnArgs>(args?: SelectSubset<T, TimeBlockCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeBlockPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TimeBlock.
     * @param {TimeBlockDeleteArgs} args - Arguments to delete one TimeBlock.
     * @example
     * // Delete one TimeBlock
     * const TimeBlock = await prisma.timeBlock.delete({
     *   where: {
     *     // ... filter to delete one TimeBlock
     *   }
     * })
     * 
     */
    delete<T extends TimeBlockDeleteArgs>(args: SelectSubset<T, TimeBlockDeleteArgs<ExtArgs>>): Prisma__TimeBlockClient<$Result.GetResult<Prisma.$TimeBlockPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TimeBlock.
     * @param {TimeBlockUpdateArgs} args - Arguments to update one TimeBlock.
     * @example
     * // Update one TimeBlock
     * const timeBlock = await prisma.timeBlock.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TimeBlockUpdateArgs>(args: SelectSubset<T, TimeBlockUpdateArgs<ExtArgs>>): Prisma__TimeBlockClient<$Result.GetResult<Prisma.$TimeBlockPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TimeBlocks.
     * @param {TimeBlockDeleteManyArgs} args - Arguments to filter TimeBlocks to delete.
     * @example
     * // Delete a few TimeBlocks
     * const { count } = await prisma.timeBlock.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TimeBlockDeleteManyArgs>(args?: SelectSubset<T, TimeBlockDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TimeBlocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeBlockUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TimeBlocks
     * const timeBlock = await prisma.timeBlock.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TimeBlockUpdateManyArgs>(args: SelectSubset<T, TimeBlockUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TimeBlocks and returns the data updated in the database.
     * @param {TimeBlockUpdateManyAndReturnArgs} args - Arguments to update many TimeBlocks.
     * @example
     * // Update many TimeBlocks
     * const timeBlock = await prisma.timeBlock.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TimeBlocks and only return the `id`
     * const timeBlockWithIdOnly = await prisma.timeBlock.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TimeBlockUpdateManyAndReturnArgs>(args: SelectSubset<T, TimeBlockUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeBlockPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TimeBlock.
     * @param {TimeBlockUpsertArgs} args - Arguments to update or create a TimeBlock.
     * @example
     * // Update or create a TimeBlock
     * const timeBlock = await prisma.timeBlock.upsert({
     *   create: {
     *     // ... data to create a TimeBlock
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TimeBlock we want to update
     *   }
     * })
     */
    upsert<T extends TimeBlockUpsertArgs>(args: SelectSubset<T, TimeBlockUpsertArgs<ExtArgs>>): Prisma__TimeBlockClient<$Result.GetResult<Prisma.$TimeBlockPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TimeBlocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeBlockCountArgs} args - Arguments to filter TimeBlocks to count.
     * @example
     * // Count the number of TimeBlocks
     * const count = await prisma.timeBlock.count({
     *   where: {
     *     // ... the filter for the TimeBlocks we want to count
     *   }
     * })
    **/
    count<T extends TimeBlockCountArgs>(
      args?: Subset<T, TimeBlockCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TimeBlockCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TimeBlock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeBlockAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TimeBlockAggregateArgs>(args: Subset<T, TimeBlockAggregateArgs>): Prisma.PrismaPromise<GetTimeBlockAggregateType<T>>

    /**
     * Group by TimeBlock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeBlockGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TimeBlockGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TimeBlockGroupByArgs['orderBy'] }
        : { orderBy?: TimeBlockGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TimeBlockGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTimeBlockGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TimeBlock model
   */
  readonly fields: TimeBlockFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TimeBlock.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TimeBlockClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TimeBlock model
   */
  interface TimeBlockFieldRefs {
    readonly id: FieldRef<"TimeBlock", 'String'>
    readonly userId: FieldRef<"TimeBlock", 'String'>
    readonly date: FieldRef<"TimeBlock", 'String'>
    readonly startTime: FieldRef<"TimeBlock", 'String'>
    readonly endTime: FieldRef<"TimeBlock", 'String'>
    readonly title: FieldRef<"TimeBlock", 'String'>
    readonly description: FieldRef<"TimeBlock", 'String'>
    readonly category: FieldRef<"TimeBlock", 'TimeBlockCategory'>
    readonly completed: FieldRef<"TimeBlock", 'Boolean'>
    readonly actualStart: FieldRef<"TimeBlock", 'String'>
    readonly actualEnd: FieldRef<"TimeBlock", 'String'>
    readonly notes: FieldRef<"TimeBlock", 'String'>
    readonly createdAt: FieldRef<"TimeBlock", 'DateTime'>
    readonly updatedAt: FieldRef<"TimeBlock", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TimeBlock findUnique
   */
  export type TimeBlockFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeBlock
     */
    select?: TimeBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeBlock
     */
    omit?: TimeBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeBlockInclude<ExtArgs> | null
    /**
     * Filter, which TimeBlock to fetch.
     */
    where: TimeBlockWhereUniqueInput
  }

  /**
   * TimeBlock findUniqueOrThrow
   */
  export type TimeBlockFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeBlock
     */
    select?: TimeBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeBlock
     */
    omit?: TimeBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeBlockInclude<ExtArgs> | null
    /**
     * Filter, which TimeBlock to fetch.
     */
    where: TimeBlockWhereUniqueInput
  }

  /**
   * TimeBlock findFirst
   */
  export type TimeBlockFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeBlock
     */
    select?: TimeBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeBlock
     */
    omit?: TimeBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeBlockInclude<ExtArgs> | null
    /**
     * Filter, which TimeBlock to fetch.
     */
    where?: TimeBlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeBlocks to fetch.
     */
    orderBy?: TimeBlockOrderByWithRelationInput | TimeBlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TimeBlocks.
     */
    cursor?: TimeBlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeBlocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeBlocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TimeBlocks.
     */
    distinct?: TimeBlockScalarFieldEnum | TimeBlockScalarFieldEnum[]
  }

  /**
   * TimeBlock findFirstOrThrow
   */
  export type TimeBlockFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeBlock
     */
    select?: TimeBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeBlock
     */
    omit?: TimeBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeBlockInclude<ExtArgs> | null
    /**
     * Filter, which TimeBlock to fetch.
     */
    where?: TimeBlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeBlocks to fetch.
     */
    orderBy?: TimeBlockOrderByWithRelationInput | TimeBlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TimeBlocks.
     */
    cursor?: TimeBlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeBlocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeBlocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TimeBlocks.
     */
    distinct?: TimeBlockScalarFieldEnum | TimeBlockScalarFieldEnum[]
  }

  /**
   * TimeBlock findMany
   */
  export type TimeBlockFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeBlock
     */
    select?: TimeBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeBlock
     */
    omit?: TimeBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeBlockInclude<ExtArgs> | null
    /**
     * Filter, which TimeBlocks to fetch.
     */
    where?: TimeBlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeBlocks to fetch.
     */
    orderBy?: TimeBlockOrderByWithRelationInput | TimeBlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TimeBlocks.
     */
    cursor?: TimeBlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeBlocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeBlocks.
     */
    skip?: number
    distinct?: TimeBlockScalarFieldEnum | TimeBlockScalarFieldEnum[]
  }

  /**
   * TimeBlock create
   */
  export type TimeBlockCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeBlock
     */
    select?: TimeBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeBlock
     */
    omit?: TimeBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeBlockInclude<ExtArgs> | null
    /**
     * The data needed to create a TimeBlock.
     */
    data: XOR<TimeBlockCreateInput, TimeBlockUncheckedCreateInput>
  }

  /**
   * TimeBlock createMany
   */
  export type TimeBlockCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TimeBlocks.
     */
    data: TimeBlockCreateManyInput | TimeBlockCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TimeBlock createManyAndReturn
   */
  export type TimeBlockCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeBlock
     */
    select?: TimeBlockSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TimeBlock
     */
    omit?: TimeBlockOmit<ExtArgs> | null
    /**
     * The data used to create many TimeBlocks.
     */
    data: TimeBlockCreateManyInput | TimeBlockCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeBlockIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TimeBlock update
   */
  export type TimeBlockUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeBlock
     */
    select?: TimeBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeBlock
     */
    omit?: TimeBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeBlockInclude<ExtArgs> | null
    /**
     * The data needed to update a TimeBlock.
     */
    data: XOR<TimeBlockUpdateInput, TimeBlockUncheckedUpdateInput>
    /**
     * Choose, which TimeBlock to update.
     */
    where: TimeBlockWhereUniqueInput
  }

  /**
   * TimeBlock updateMany
   */
  export type TimeBlockUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TimeBlocks.
     */
    data: XOR<TimeBlockUpdateManyMutationInput, TimeBlockUncheckedUpdateManyInput>
    /**
     * Filter which TimeBlocks to update
     */
    where?: TimeBlockWhereInput
    /**
     * Limit how many TimeBlocks to update.
     */
    limit?: number
  }

  /**
   * TimeBlock updateManyAndReturn
   */
  export type TimeBlockUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeBlock
     */
    select?: TimeBlockSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TimeBlock
     */
    omit?: TimeBlockOmit<ExtArgs> | null
    /**
     * The data used to update TimeBlocks.
     */
    data: XOR<TimeBlockUpdateManyMutationInput, TimeBlockUncheckedUpdateManyInput>
    /**
     * Filter which TimeBlocks to update
     */
    where?: TimeBlockWhereInput
    /**
     * Limit how many TimeBlocks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeBlockIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TimeBlock upsert
   */
  export type TimeBlockUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeBlock
     */
    select?: TimeBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeBlock
     */
    omit?: TimeBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeBlockInclude<ExtArgs> | null
    /**
     * The filter to search for the TimeBlock to update in case it exists.
     */
    where: TimeBlockWhereUniqueInput
    /**
     * In case the TimeBlock found by the `where` argument doesn't exist, create a new TimeBlock with this data.
     */
    create: XOR<TimeBlockCreateInput, TimeBlockUncheckedCreateInput>
    /**
     * In case the TimeBlock was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TimeBlockUpdateInput, TimeBlockUncheckedUpdateInput>
  }

  /**
   * TimeBlock delete
   */
  export type TimeBlockDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeBlock
     */
    select?: TimeBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeBlock
     */
    omit?: TimeBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeBlockInclude<ExtArgs> | null
    /**
     * Filter which TimeBlock to delete.
     */
    where: TimeBlockWhereUniqueInput
  }

  /**
   * TimeBlock deleteMany
   */
  export type TimeBlockDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TimeBlocks to delete
     */
    where?: TimeBlockWhereInput
    /**
     * Limit how many TimeBlocks to delete.
     */
    limit?: number
  }

  /**
   * TimeBlock without action
   */
  export type TimeBlockDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeBlock
     */
    select?: TimeBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeBlock
     */
    omit?: TimeBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeBlockInclude<ExtArgs> | null
  }


  /**
   * Model PersonalContext
   */

  export type AggregatePersonalContext = {
    _count: PersonalContextCountAggregateOutputType | null
    _min: PersonalContextMinAggregateOutputType | null
    _max: PersonalContextMaxAggregateOutputType | null
  }

  export type PersonalContextMinAggregateOutputType = {
    id: string | null
    userId: string | null
    currentGoals: string | null
    skillPriorities: string | null
    revenueTargets: string | null
    timeConstraints: string | null
    currentProjects: string | null
    hatedTasks: string | null
    valuedTasks: string | null
    learningObjectives: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PersonalContextMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    currentGoals: string | null
    skillPriorities: string | null
    revenueTargets: string | null
    timeConstraints: string | null
    currentProjects: string | null
    hatedTasks: string | null
    valuedTasks: string | null
    learningObjectives: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PersonalContextCountAggregateOutputType = {
    id: number
    userId: number
    currentGoals: number
    skillPriorities: number
    revenueTargets: number
    timeConstraints: number
    currentProjects: number
    hatedTasks: number
    valuedTasks: number
    learningObjectives: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PersonalContextMinAggregateInputType = {
    id?: true
    userId?: true
    currentGoals?: true
    skillPriorities?: true
    revenueTargets?: true
    timeConstraints?: true
    currentProjects?: true
    hatedTasks?: true
    valuedTasks?: true
    learningObjectives?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PersonalContextMaxAggregateInputType = {
    id?: true
    userId?: true
    currentGoals?: true
    skillPriorities?: true
    revenueTargets?: true
    timeConstraints?: true
    currentProjects?: true
    hatedTasks?: true
    valuedTasks?: true
    learningObjectives?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PersonalContextCountAggregateInputType = {
    id?: true
    userId?: true
    currentGoals?: true
    skillPriorities?: true
    revenueTargets?: true
    timeConstraints?: true
    currentProjects?: true
    hatedTasks?: true
    valuedTasks?: true
    learningObjectives?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PersonalContextAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersonalContext to aggregate.
     */
    where?: PersonalContextWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonalContexts to fetch.
     */
    orderBy?: PersonalContextOrderByWithRelationInput | PersonalContextOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PersonalContextWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonalContexts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonalContexts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PersonalContexts
    **/
    _count?: true | PersonalContextCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PersonalContextMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PersonalContextMaxAggregateInputType
  }

  export type GetPersonalContextAggregateType<T extends PersonalContextAggregateArgs> = {
        [P in keyof T & keyof AggregatePersonalContext]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePersonalContext[P]>
      : GetScalarType<T[P], AggregatePersonalContext[P]>
  }




  export type PersonalContextGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonalContextWhereInput
    orderBy?: PersonalContextOrderByWithAggregationInput | PersonalContextOrderByWithAggregationInput[]
    by: PersonalContextScalarFieldEnum[] | PersonalContextScalarFieldEnum
    having?: PersonalContextScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PersonalContextCountAggregateInputType | true
    _min?: PersonalContextMinAggregateInputType
    _max?: PersonalContextMaxAggregateInputType
  }

  export type PersonalContextGroupByOutputType = {
    id: string
    userId: string
    currentGoals: string | null
    skillPriorities: string | null
    revenueTargets: string | null
    timeConstraints: string | null
    currentProjects: string | null
    hatedTasks: string | null
    valuedTasks: string | null
    learningObjectives: string | null
    createdAt: Date
    updatedAt: Date
    _count: PersonalContextCountAggregateOutputType | null
    _min: PersonalContextMinAggregateOutputType | null
    _max: PersonalContextMaxAggregateOutputType | null
  }

  type GetPersonalContextGroupByPayload<T extends PersonalContextGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PersonalContextGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PersonalContextGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PersonalContextGroupByOutputType[P]>
            : GetScalarType<T[P], PersonalContextGroupByOutputType[P]>
        }
      >
    >


  export type PersonalContextSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    currentGoals?: boolean
    skillPriorities?: boolean
    revenueTargets?: boolean
    timeConstraints?: boolean
    currentProjects?: boolean
    hatedTasks?: boolean
    valuedTasks?: boolean
    learningObjectives?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["personalContext"]>

  export type PersonalContextSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    currentGoals?: boolean
    skillPriorities?: boolean
    revenueTargets?: boolean
    timeConstraints?: boolean
    currentProjects?: boolean
    hatedTasks?: boolean
    valuedTasks?: boolean
    learningObjectives?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["personalContext"]>

  export type PersonalContextSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    currentGoals?: boolean
    skillPriorities?: boolean
    revenueTargets?: boolean
    timeConstraints?: boolean
    currentProjects?: boolean
    hatedTasks?: boolean
    valuedTasks?: boolean
    learningObjectives?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["personalContext"]>

  export type PersonalContextSelectScalar = {
    id?: boolean
    userId?: boolean
    currentGoals?: boolean
    skillPriorities?: boolean
    revenueTargets?: boolean
    timeConstraints?: boolean
    currentProjects?: boolean
    hatedTasks?: boolean
    valuedTasks?: boolean
    learningObjectives?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PersonalContextOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "currentGoals" | "skillPriorities" | "revenueTargets" | "timeConstraints" | "currentProjects" | "hatedTasks" | "valuedTasks" | "learningObjectives" | "createdAt" | "updatedAt", ExtArgs["result"]["personalContext"]>
  export type PersonalContextInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PersonalContextIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PersonalContextIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PersonalContextPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PersonalContext"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      currentGoals: string | null
      skillPriorities: string | null
      revenueTargets: string | null
      timeConstraints: string | null
      currentProjects: string | null
      hatedTasks: string | null
      valuedTasks: string | null
      learningObjectives: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["personalContext"]>
    composites: {}
  }

  type PersonalContextGetPayload<S extends boolean | null | undefined | PersonalContextDefaultArgs> = $Result.GetResult<Prisma.$PersonalContextPayload, S>

  type PersonalContextCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PersonalContextFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PersonalContextCountAggregateInputType | true
    }

  export interface PersonalContextDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PersonalContext'], meta: { name: 'PersonalContext' } }
    /**
     * Find zero or one PersonalContext that matches the filter.
     * @param {PersonalContextFindUniqueArgs} args - Arguments to find a PersonalContext
     * @example
     * // Get one PersonalContext
     * const personalContext = await prisma.personalContext.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PersonalContextFindUniqueArgs>(args: SelectSubset<T, PersonalContextFindUniqueArgs<ExtArgs>>): Prisma__PersonalContextClient<$Result.GetResult<Prisma.$PersonalContextPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PersonalContext that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PersonalContextFindUniqueOrThrowArgs} args - Arguments to find a PersonalContext
     * @example
     * // Get one PersonalContext
     * const personalContext = await prisma.personalContext.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PersonalContextFindUniqueOrThrowArgs>(args: SelectSubset<T, PersonalContextFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PersonalContextClient<$Result.GetResult<Prisma.$PersonalContextPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PersonalContext that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalContextFindFirstArgs} args - Arguments to find a PersonalContext
     * @example
     * // Get one PersonalContext
     * const personalContext = await prisma.personalContext.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PersonalContextFindFirstArgs>(args?: SelectSubset<T, PersonalContextFindFirstArgs<ExtArgs>>): Prisma__PersonalContextClient<$Result.GetResult<Prisma.$PersonalContextPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PersonalContext that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalContextFindFirstOrThrowArgs} args - Arguments to find a PersonalContext
     * @example
     * // Get one PersonalContext
     * const personalContext = await prisma.personalContext.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PersonalContextFindFirstOrThrowArgs>(args?: SelectSubset<T, PersonalContextFindFirstOrThrowArgs<ExtArgs>>): Prisma__PersonalContextClient<$Result.GetResult<Prisma.$PersonalContextPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PersonalContexts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalContextFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PersonalContexts
     * const personalContexts = await prisma.personalContext.findMany()
     * 
     * // Get first 10 PersonalContexts
     * const personalContexts = await prisma.personalContext.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const personalContextWithIdOnly = await prisma.personalContext.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PersonalContextFindManyArgs>(args?: SelectSubset<T, PersonalContextFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonalContextPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PersonalContext.
     * @param {PersonalContextCreateArgs} args - Arguments to create a PersonalContext.
     * @example
     * // Create one PersonalContext
     * const PersonalContext = await prisma.personalContext.create({
     *   data: {
     *     // ... data to create a PersonalContext
     *   }
     * })
     * 
     */
    create<T extends PersonalContextCreateArgs>(args: SelectSubset<T, PersonalContextCreateArgs<ExtArgs>>): Prisma__PersonalContextClient<$Result.GetResult<Prisma.$PersonalContextPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PersonalContexts.
     * @param {PersonalContextCreateManyArgs} args - Arguments to create many PersonalContexts.
     * @example
     * // Create many PersonalContexts
     * const personalContext = await prisma.personalContext.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PersonalContextCreateManyArgs>(args?: SelectSubset<T, PersonalContextCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PersonalContexts and returns the data saved in the database.
     * @param {PersonalContextCreateManyAndReturnArgs} args - Arguments to create many PersonalContexts.
     * @example
     * // Create many PersonalContexts
     * const personalContext = await prisma.personalContext.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PersonalContexts and only return the `id`
     * const personalContextWithIdOnly = await prisma.personalContext.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PersonalContextCreateManyAndReturnArgs>(args?: SelectSubset<T, PersonalContextCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonalContextPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PersonalContext.
     * @param {PersonalContextDeleteArgs} args - Arguments to delete one PersonalContext.
     * @example
     * // Delete one PersonalContext
     * const PersonalContext = await prisma.personalContext.delete({
     *   where: {
     *     // ... filter to delete one PersonalContext
     *   }
     * })
     * 
     */
    delete<T extends PersonalContextDeleteArgs>(args: SelectSubset<T, PersonalContextDeleteArgs<ExtArgs>>): Prisma__PersonalContextClient<$Result.GetResult<Prisma.$PersonalContextPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PersonalContext.
     * @param {PersonalContextUpdateArgs} args - Arguments to update one PersonalContext.
     * @example
     * // Update one PersonalContext
     * const personalContext = await prisma.personalContext.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PersonalContextUpdateArgs>(args: SelectSubset<T, PersonalContextUpdateArgs<ExtArgs>>): Prisma__PersonalContextClient<$Result.GetResult<Prisma.$PersonalContextPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PersonalContexts.
     * @param {PersonalContextDeleteManyArgs} args - Arguments to filter PersonalContexts to delete.
     * @example
     * // Delete a few PersonalContexts
     * const { count } = await prisma.personalContext.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PersonalContextDeleteManyArgs>(args?: SelectSubset<T, PersonalContextDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PersonalContexts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalContextUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PersonalContexts
     * const personalContext = await prisma.personalContext.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PersonalContextUpdateManyArgs>(args: SelectSubset<T, PersonalContextUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PersonalContexts and returns the data updated in the database.
     * @param {PersonalContextUpdateManyAndReturnArgs} args - Arguments to update many PersonalContexts.
     * @example
     * // Update many PersonalContexts
     * const personalContext = await prisma.personalContext.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PersonalContexts and only return the `id`
     * const personalContextWithIdOnly = await prisma.personalContext.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PersonalContextUpdateManyAndReturnArgs>(args: SelectSubset<T, PersonalContextUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonalContextPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PersonalContext.
     * @param {PersonalContextUpsertArgs} args - Arguments to update or create a PersonalContext.
     * @example
     * // Update or create a PersonalContext
     * const personalContext = await prisma.personalContext.upsert({
     *   create: {
     *     // ... data to create a PersonalContext
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PersonalContext we want to update
     *   }
     * })
     */
    upsert<T extends PersonalContextUpsertArgs>(args: SelectSubset<T, PersonalContextUpsertArgs<ExtArgs>>): Prisma__PersonalContextClient<$Result.GetResult<Prisma.$PersonalContextPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PersonalContexts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalContextCountArgs} args - Arguments to filter PersonalContexts to count.
     * @example
     * // Count the number of PersonalContexts
     * const count = await prisma.personalContext.count({
     *   where: {
     *     // ... the filter for the PersonalContexts we want to count
     *   }
     * })
    **/
    count<T extends PersonalContextCountArgs>(
      args?: Subset<T, PersonalContextCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PersonalContextCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PersonalContext.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalContextAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PersonalContextAggregateArgs>(args: Subset<T, PersonalContextAggregateArgs>): Prisma.PrismaPromise<GetPersonalContextAggregateType<T>>

    /**
     * Group by PersonalContext.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalContextGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PersonalContextGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PersonalContextGroupByArgs['orderBy'] }
        : { orderBy?: PersonalContextGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PersonalContextGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersonalContextGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PersonalContext model
   */
  readonly fields: PersonalContextFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PersonalContext.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PersonalContextClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PersonalContext model
   */
  interface PersonalContextFieldRefs {
    readonly id: FieldRef<"PersonalContext", 'String'>
    readonly userId: FieldRef<"PersonalContext", 'String'>
    readonly currentGoals: FieldRef<"PersonalContext", 'String'>
    readonly skillPriorities: FieldRef<"PersonalContext", 'String'>
    readonly revenueTargets: FieldRef<"PersonalContext", 'String'>
    readonly timeConstraints: FieldRef<"PersonalContext", 'String'>
    readonly currentProjects: FieldRef<"PersonalContext", 'String'>
    readonly hatedTasks: FieldRef<"PersonalContext", 'String'>
    readonly valuedTasks: FieldRef<"PersonalContext", 'String'>
    readonly learningObjectives: FieldRef<"PersonalContext", 'String'>
    readonly createdAt: FieldRef<"PersonalContext", 'DateTime'>
    readonly updatedAt: FieldRef<"PersonalContext", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PersonalContext findUnique
   */
  export type PersonalContextFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalContext
     */
    select?: PersonalContextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalContext
     */
    omit?: PersonalContextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalContextInclude<ExtArgs> | null
    /**
     * Filter, which PersonalContext to fetch.
     */
    where: PersonalContextWhereUniqueInput
  }

  /**
   * PersonalContext findUniqueOrThrow
   */
  export type PersonalContextFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalContext
     */
    select?: PersonalContextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalContext
     */
    omit?: PersonalContextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalContextInclude<ExtArgs> | null
    /**
     * Filter, which PersonalContext to fetch.
     */
    where: PersonalContextWhereUniqueInput
  }

  /**
   * PersonalContext findFirst
   */
  export type PersonalContextFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalContext
     */
    select?: PersonalContextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalContext
     */
    omit?: PersonalContextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalContextInclude<ExtArgs> | null
    /**
     * Filter, which PersonalContext to fetch.
     */
    where?: PersonalContextWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonalContexts to fetch.
     */
    orderBy?: PersonalContextOrderByWithRelationInput | PersonalContextOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersonalContexts.
     */
    cursor?: PersonalContextWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonalContexts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonalContexts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersonalContexts.
     */
    distinct?: PersonalContextScalarFieldEnum | PersonalContextScalarFieldEnum[]
  }

  /**
   * PersonalContext findFirstOrThrow
   */
  export type PersonalContextFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalContext
     */
    select?: PersonalContextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalContext
     */
    omit?: PersonalContextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalContextInclude<ExtArgs> | null
    /**
     * Filter, which PersonalContext to fetch.
     */
    where?: PersonalContextWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonalContexts to fetch.
     */
    orderBy?: PersonalContextOrderByWithRelationInput | PersonalContextOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersonalContexts.
     */
    cursor?: PersonalContextWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonalContexts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonalContexts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersonalContexts.
     */
    distinct?: PersonalContextScalarFieldEnum | PersonalContextScalarFieldEnum[]
  }

  /**
   * PersonalContext findMany
   */
  export type PersonalContextFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalContext
     */
    select?: PersonalContextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalContext
     */
    omit?: PersonalContextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalContextInclude<ExtArgs> | null
    /**
     * Filter, which PersonalContexts to fetch.
     */
    where?: PersonalContextWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonalContexts to fetch.
     */
    orderBy?: PersonalContextOrderByWithRelationInput | PersonalContextOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PersonalContexts.
     */
    cursor?: PersonalContextWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonalContexts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonalContexts.
     */
    skip?: number
    distinct?: PersonalContextScalarFieldEnum | PersonalContextScalarFieldEnum[]
  }

  /**
   * PersonalContext create
   */
  export type PersonalContextCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalContext
     */
    select?: PersonalContextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalContext
     */
    omit?: PersonalContextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalContextInclude<ExtArgs> | null
    /**
     * The data needed to create a PersonalContext.
     */
    data: XOR<PersonalContextCreateInput, PersonalContextUncheckedCreateInput>
  }

  /**
   * PersonalContext createMany
   */
  export type PersonalContextCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PersonalContexts.
     */
    data: PersonalContextCreateManyInput | PersonalContextCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PersonalContext createManyAndReturn
   */
  export type PersonalContextCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalContext
     */
    select?: PersonalContextSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalContext
     */
    omit?: PersonalContextOmit<ExtArgs> | null
    /**
     * The data used to create many PersonalContexts.
     */
    data: PersonalContextCreateManyInput | PersonalContextCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalContextIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PersonalContext update
   */
  export type PersonalContextUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalContext
     */
    select?: PersonalContextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalContext
     */
    omit?: PersonalContextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalContextInclude<ExtArgs> | null
    /**
     * The data needed to update a PersonalContext.
     */
    data: XOR<PersonalContextUpdateInput, PersonalContextUncheckedUpdateInput>
    /**
     * Choose, which PersonalContext to update.
     */
    where: PersonalContextWhereUniqueInput
  }

  /**
   * PersonalContext updateMany
   */
  export type PersonalContextUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PersonalContexts.
     */
    data: XOR<PersonalContextUpdateManyMutationInput, PersonalContextUncheckedUpdateManyInput>
    /**
     * Filter which PersonalContexts to update
     */
    where?: PersonalContextWhereInput
    /**
     * Limit how many PersonalContexts to update.
     */
    limit?: number
  }

  /**
   * PersonalContext updateManyAndReturn
   */
  export type PersonalContextUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalContext
     */
    select?: PersonalContextSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalContext
     */
    omit?: PersonalContextOmit<ExtArgs> | null
    /**
     * The data used to update PersonalContexts.
     */
    data: XOR<PersonalContextUpdateManyMutationInput, PersonalContextUncheckedUpdateManyInput>
    /**
     * Filter which PersonalContexts to update
     */
    where?: PersonalContextWhereInput
    /**
     * Limit how many PersonalContexts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalContextIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PersonalContext upsert
   */
  export type PersonalContextUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalContext
     */
    select?: PersonalContextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalContext
     */
    omit?: PersonalContextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalContextInclude<ExtArgs> | null
    /**
     * The filter to search for the PersonalContext to update in case it exists.
     */
    where: PersonalContextWhereUniqueInput
    /**
     * In case the PersonalContext found by the `where` argument doesn't exist, create a new PersonalContext with this data.
     */
    create: XOR<PersonalContextCreateInput, PersonalContextUncheckedCreateInput>
    /**
     * In case the PersonalContext was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PersonalContextUpdateInput, PersonalContextUncheckedUpdateInput>
  }

  /**
   * PersonalContext delete
   */
  export type PersonalContextDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalContext
     */
    select?: PersonalContextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalContext
     */
    omit?: PersonalContextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalContextInclude<ExtArgs> | null
    /**
     * Filter which PersonalContext to delete.
     */
    where: PersonalContextWhereUniqueInput
  }

  /**
   * PersonalContext deleteMany
   */
  export type PersonalContextDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersonalContexts to delete
     */
    where?: PersonalContextWhereInput
    /**
     * Limit how many PersonalContexts to delete.
     */
    limit?: number
  }

  /**
   * PersonalContext without action
   */
  export type PersonalContextDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalContext
     */
    select?: PersonalContextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalContext
     */
    omit?: PersonalContextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalContextInclude<ExtArgs> | null
  }


  /**
   * Model UserProgress
   */

  export type AggregateUserProgress = {
    _count: UserProgressCountAggregateOutputType | null
    _avg: UserProgressAvgAggregateOutputType | null
    _sum: UserProgressSumAggregateOutputType | null
    _min: UserProgressMinAggregateOutputType | null
    _max: UserProgressMaxAggregateOutputType | null
  }

  export type UserProgressAvgAggregateOutputType = {
    currentLevel: number | null
    totalXP: number | null
    dailyXP: number | null
    currentStreak: number | null
    bestStreak: number | null
  }

  export type UserProgressSumAggregateOutputType = {
    currentLevel: number | null
    totalXP: number | null
    dailyXP: number | null
    currentStreak: number | null
    bestStreak: number | null
  }

  export type UserProgressMinAggregateOutputType = {
    id: string | null
    userId: string | null
    currentLevel: number | null
    totalXP: number | null
    dailyXP: number | null
    currentStreak: number | null
    bestStreak: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserProgressMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    currentLevel: number | null
    totalXP: number | null
    dailyXP: number | null
    currentStreak: number | null
    bestStreak: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserProgressCountAggregateOutputType = {
    id: number
    userId: number
    currentLevel: number
    totalXP: number
    dailyXP: number
    currentStreak: number
    bestStreak: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserProgressAvgAggregateInputType = {
    currentLevel?: true
    totalXP?: true
    dailyXP?: true
    currentStreak?: true
    bestStreak?: true
  }

  export type UserProgressSumAggregateInputType = {
    currentLevel?: true
    totalXP?: true
    dailyXP?: true
    currentStreak?: true
    bestStreak?: true
  }

  export type UserProgressMinAggregateInputType = {
    id?: true
    userId?: true
    currentLevel?: true
    totalXP?: true
    dailyXP?: true
    currentStreak?: true
    bestStreak?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserProgressMaxAggregateInputType = {
    id?: true
    userId?: true
    currentLevel?: true
    totalXP?: true
    dailyXP?: true
    currentStreak?: true
    bestStreak?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserProgressCountAggregateInputType = {
    id?: true
    userId?: true
    currentLevel?: true
    totalXP?: true
    dailyXP?: true
    currentStreak?: true
    bestStreak?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserProgressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProgress to aggregate.
     */
    where?: UserProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProgresses to fetch.
     */
    orderBy?: UserProgressOrderByWithRelationInput | UserProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserProgresses
    **/
    _count?: true | UserProgressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserProgressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserProgressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserProgressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserProgressMaxAggregateInputType
  }

  export type GetUserProgressAggregateType<T extends UserProgressAggregateArgs> = {
        [P in keyof T & keyof AggregateUserProgress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserProgress[P]>
      : GetScalarType<T[P], AggregateUserProgress[P]>
  }




  export type UserProgressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserProgressWhereInput
    orderBy?: UserProgressOrderByWithAggregationInput | UserProgressOrderByWithAggregationInput[]
    by: UserProgressScalarFieldEnum[] | UserProgressScalarFieldEnum
    having?: UserProgressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserProgressCountAggregateInputType | true
    _avg?: UserProgressAvgAggregateInputType
    _sum?: UserProgressSumAggregateInputType
    _min?: UserProgressMinAggregateInputType
    _max?: UserProgressMaxAggregateInputType
  }

  export type UserProgressGroupByOutputType = {
    id: string
    userId: string
    currentLevel: number
    totalXP: number
    dailyXP: number
    currentStreak: number
    bestStreak: number
    createdAt: Date
    updatedAt: Date
    _count: UserProgressCountAggregateOutputType | null
    _avg: UserProgressAvgAggregateOutputType | null
    _sum: UserProgressSumAggregateOutputType | null
    _min: UserProgressMinAggregateOutputType | null
    _max: UserProgressMaxAggregateOutputType | null
  }

  type GetUserProgressGroupByPayload<T extends UserProgressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserProgressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserProgressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserProgressGroupByOutputType[P]>
            : GetScalarType<T[P], UserProgressGroupByOutputType[P]>
        }
      >
    >


  export type UserProgressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    currentLevel?: boolean
    totalXP?: boolean
    dailyXP?: boolean
    currentStreak?: boolean
    bestStreak?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    achievements?: boolean | UserProgress$achievementsArgs<ExtArgs>
    dailyStats?: boolean | UserProgress$dailyStatsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | UserProgressCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userProgress"]>

  export type UserProgressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    currentLevel?: boolean
    totalXP?: boolean
    dailyXP?: boolean
    currentStreak?: boolean
    bestStreak?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userProgress"]>

  export type UserProgressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    currentLevel?: boolean
    totalXP?: boolean
    dailyXP?: boolean
    currentStreak?: boolean
    bestStreak?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userProgress"]>

  export type UserProgressSelectScalar = {
    id?: boolean
    userId?: boolean
    currentLevel?: boolean
    totalXP?: boolean
    dailyXP?: boolean
    currentStreak?: boolean
    bestStreak?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserProgressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "currentLevel" | "totalXP" | "dailyXP" | "currentStreak" | "bestStreak" | "createdAt" | "updatedAt", ExtArgs["result"]["userProgress"]>
  export type UserProgressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    achievements?: boolean | UserProgress$achievementsArgs<ExtArgs>
    dailyStats?: boolean | UserProgress$dailyStatsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | UserProgressCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserProgressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserProgressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserProgressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserProgress"
    objects: {
      achievements: Prisma.$AchievementPayload<ExtArgs>[]
      dailyStats: Prisma.$DailyStatsPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      currentLevel: number
      totalXP: number
      dailyXP: number
      currentStreak: number
      bestStreak: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userProgress"]>
    composites: {}
  }

  type UserProgressGetPayload<S extends boolean | null | undefined | UserProgressDefaultArgs> = $Result.GetResult<Prisma.$UserProgressPayload, S>

  type UserProgressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserProgressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserProgressCountAggregateInputType | true
    }

  export interface UserProgressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserProgress'], meta: { name: 'UserProgress' } }
    /**
     * Find zero or one UserProgress that matches the filter.
     * @param {UserProgressFindUniqueArgs} args - Arguments to find a UserProgress
     * @example
     * // Get one UserProgress
     * const userProgress = await prisma.userProgress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserProgressFindUniqueArgs>(args: SelectSubset<T, UserProgressFindUniqueArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserProgress that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserProgressFindUniqueOrThrowArgs} args - Arguments to find a UserProgress
     * @example
     * // Get one UserProgress
     * const userProgress = await prisma.userProgress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserProgressFindUniqueOrThrowArgs>(args: SelectSubset<T, UserProgressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserProgress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProgressFindFirstArgs} args - Arguments to find a UserProgress
     * @example
     * // Get one UserProgress
     * const userProgress = await prisma.userProgress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserProgressFindFirstArgs>(args?: SelectSubset<T, UserProgressFindFirstArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserProgress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProgressFindFirstOrThrowArgs} args - Arguments to find a UserProgress
     * @example
     * // Get one UserProgress
     * const userProgress = await prisma.userProgress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserProgressFindFirstOrThrowArgs>(args?: SelectSubset<T, UserProgressFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserProgresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProgressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserProgresses
     * const userProgresses = await prisma.userProgress.findMany()
     * 
     * // Get first 10 UserProgresses
     * const userProgresses = await prisma.userProgress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userProgressWithIdOnly = await prisma.userProgress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserProgressFindManyArgs>(args?: SelectSubset<T, UserProgressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserProgress.
     * @param {UserProgressCreateArgs} args - Arguments to create a UserProgress.
     * @example
     * // Create one UserProgress
     * const UserProgress = await prisma.userProgress.create({
     *   data: {
     *     // ... data to create a UserProgress
     *   }
     * })
     * 
     */
    create<T extends UserProgressCreateArgs>(args: SelectSubset<T, UserProgressCreateArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserProgresses.
     * @param {UserProgressCreateManyArgs} args - Arguments to create many UserProgresses.
     * @example
     * // Create many UserProgresses
     * const userProgress = await prisma.userProgress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserProgressCreateManyArgs>(args?: SelectSubset<T, UserProgressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserProgresses and returns the data saved in the database.
     * @param {UserProgressCreateManyAndReturnArgs} args - Arguments to create many UserProgresses.
     * @example
     * // Create many UserProgresses
     * const userProgress = await prisma.userProgress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserProgresses and only return the `id`
     * const userProgressWithIdOnly = await prisma.userProgress.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserProgressCreateManyAndReturnArgs>(args?: SelectSubset<T, UserProgressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserProgress.
     * @param {UserProgressDeleteArgs} args - Arguments to delete one UserProgress.
     * @example
     * // Delete one UserProgress
     * const UserProgress = await prisma.userProgress.delete({
     *   where: {
     *     // ... filter to delete one UserProgress
     *   }
     * })
     * 
     */
    delete<T extends UserProgressDeleteArgs>(args: SelectSubset<T, UserProgressDeleteArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserProgress.
     * @param {UserProgressUpdateArgs} args - Arguments to update one UserProgress.
     * @example
     * // Update one UserProgress
     * const userProgress = await prisma.userProgress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserProgressUpdateArgs>(args: SelectSubset<T, UserProgressUpdateArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserProgresses.
     * @param {UserProgressDeleteManyArgs} args - Arguments to filter UserProgresses to delete.
     * @example
     * // Delete a few UserProgresses
     * const { count } = await prisma.userProgress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserProgressDeleteManyArgs>(args?: SelectSubset<T, UserProgressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProgressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserProgresses
     * const userProgress = await prisma.userProgress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserProgressUpdateManyArgs>(args: SelectSubset<T, UserProgressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserProgresses and returns the data updated in the database.
     * @param {UserProgressUpdateManyAndReturnArgs} args - Arguments to update many UserProgresses.
     * @example
     * // Update many UserProgresses
     * const userProgress = await prisma.userProgress.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserProgresses and only return the `id`
     * const userProgressWithIdOnly = await prisma.userProgress.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserProgressUpdateManyAndReturnArgs>(args: SelectSubset<T, UserProgressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserProgress.
     * @param {UserProgressUpsertArgs} args - Arguments to update or create a UserProgress.
     * @example
     * // Update or create a UserProgress
     * const userProgress = await prisma.userProgress.upsert({
     *   create: {
     *     // ... data to create a UserProgress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserProgress we want to update
     *   }
     * })
     */
    upsert<T extends UserProgressUpsertArgs>(args: SelectSubset<T, UserProgressUpsertArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProgressCountArgs} args - Arguments to filter UserProgresses to count.
     * @example
     * // Count the number of UserProgresses
     * const count = await prisma.userProgress.count({
     *   where: {
     *     // ... the filter for the UserProgresses we want to count
     *   }
     * })
    **/
    count<T extends UserProgressCountArgs>(
      args?: Subset<T, UserProgressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserProgressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProgressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserProgressAggregateArgs>(args: Subset<T, UserProgressAggregateArgs>): Prisma.PrismaPromise<GetUserProgressAggregateType<T>>

    /**
     * Group by UserProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProgressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserProgressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserProgressGroupByArgs['orderBy'] }
        : { orderBy?: UserProgressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserProgressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserProgressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserProgress model
   */
  readonly fields: UserProgressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserProgress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserProgressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    achievements<T extends UserProgress$achievementsArgs<ExtArgs> = {}>(args?: Subset<T, UserProgress$achievementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dailyStats<T extends UserProgress$dailyStatsArgs<ExtArgs> = {}>(args?: Subset<T, UserProgress$dailyStatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyStatsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserProgress model
   */
  interface UserProgressFieldRefs {
    readonly id: FieldRef<"UserProgress", 'String'>
    readonly userId: FieldRef<"UserProgress", 'String'>
    readonly currentLevel: FieldRef<"UserProgress", 'Int'>
    readonly totalXP: FieldRef<"UserProgress", 'Int'>
    readonly dailyXP: FieldRef<"UserProgress", 'Int'>
    readonly currentStreak: FieldRef<"UserProgress", 'Int'>
    readonly bestStreak: FieldRef<"UserProgress", 'Int'>
    readonly createdAt: FieldRef<"UserProgress", 'DateTime'>
    readonly updatedAt: FieldRef<"UserProgress", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserProgress findUnique
   */
  export type UserProgressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    /**
     * Filter, which UserProgress to fetch.
     */
    where: UserProgressWhereUniqueInput
  }

  /**
   * UserProgress findUniqueOrThrow
   */
  export type UserProgressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    /**
     * Filter, which UserProgress to fetch.
     */
    where: UserProgressWhereUniqueInput
  }

  /**
   * UserProgress findFirst
   */
  export type UserProgressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    /**
     * Filter, which UserProgress to fetch.
     */
    where?: UserProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProgresses to fetch.
     */
    orderBy?: UserProgressOrderByWithRelationInput | UserProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProgresses.
     */
    cursor?: UserProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProgresses.
     */
    distinct?: UserProgressScalarFieldEnum | UserProgressScalarFieldEnum[]
  }

  /**
   * UserProgress findFirstOrThrow
   */
  export type UserProgressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    /**
     * Filter, which UserProgress to fetch.
     */
    where?: UserProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProgresses to fetch.
     */
    orderBy?: UserProgressOrderByWithRelationInput | UserProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProgresses.
     */
    cursor?: UserProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProgresses.
     */
    distinct?: UserProgressScalarFieldEnum | UserProgressScalarFieldEnum[]
  }

  /**
   * UserProgress findMany
   */
  export type UserProgressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    /**
     * Filter, which UserProgresses to fetch.
     */
    where?: UserProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProgresses to fetch.
     */
    orderBy?: UserProgressOrderByWithRelationInput | UserProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserProgresses.
     */
    cursor?: UserProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProgresses.
     */
    skip?: number
    distinct?: UserProgressScalarFieldEnum | UserProgressScalarFieldEnum[]
  }

  /**
   * UserProgress create
   */
  export type UserProgressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    /**
     * The data needed to create a UserProgress.
     */
    data: XOR<UserProgressCreateInput, UserProgressUncheckedCreateInput>
  }

  /**
   * UserProgress createMany
   */
  export type UserProgressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserProgresses.
     */
    data: UserProgressCreateManyInput | UserProgressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserProgress createManyAndReturn
   */
  export type UserProgressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * The data used to create many UserProgresses.
     */
    data: UserProgressCreateManyInput | UserProgressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserProgress update
   */
  export type UserProgressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    /**
     * The data needed to update a UserProgress.
     */
    data: XOR<UserProgressUpdateInput, UserProgressUncheckedUpdateInput>
    /**
     * Choose, which UserProgress to update.
     */
    where: UserProgressWhereUniqueInput
  }

  /**
   * UserProgress updateMany
   */
  export type UserProgressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserProgresses.
     */
    data: XOR<UserProgressUpdateManyMutationInput, UserProgressUncheckedUpdateManyInput>
    /**
     * Filter which UserProgresses to update
     */
    where?: UserProgressWhereInput
    /**
     * Limit how many UserProgresses to update.
     */
    limit?: number
  }

  /**
   * UserProgress updateManyAndReturn
   */
  export type UserProgressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * The data used to update UserProgresses.
     */
    data: XOR<UserProgressUpdateManyMutationInput, UserProgressUncheckedUpdateManyInput>
    /**
     * Filter which UserProgresses to update
     */
    where?: UserProgressWhereInput
    /**
     * Limit how many UserProgresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserProgress upsert
   */
  export type UserProgressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    /**
     * The filter to search for the UserProgress to update in case it exists.
     */
    where: UserProgressWhereUniqueInput
    /**
     * In case the UserProgress found by the `where` argument doesn't exist, create a new UserProgress with this data.
     */
    create: XOR<UserProgressCreateInput, UserProgressUncheckedCreateInput>
    /**
     * In case the UserProgress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserProgressUpdateInput, UserProgressUncheckedUpdateInput>
  }

  /**
   * UserProgress delete
   */
  export type UserProgressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    /**
     * Filter which UserProgress to delete.
     */
    where: UserProgressWhereUniqueInput
  }

  /**
   * UserProgress deleteMany
   */
  export type UserProgressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProgresses to delete
     */
    where?: UserProgressWhereInput
    /**
     * Limit how many UserProgresses to delete.
     */
    limit?: number
  }

  /**
   * UserProgress.achievements
   */
  export type UserProgress$achievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    where?: AchievementWhereInput
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    cursor?: AchievementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * UserProgress.dailyStats
   */
  export type UserProgress$dailyStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyStats
     */
    select?: DailyStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyStats
     */
    omit?: DailyStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyStatsInclude<ExtArgs> | null
    where?: DailyStatsWhereInput
    orderBy?: DailyStatsOrderByWithRelationInput | DailyStatsOrderByWithRelationInput[]
    cursor?: DailyStatsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DailyStatsScalarFieldEnum | DailyStatsScalarFieldEnum[]
  }

  /**
   * UserProgress without action
   */
  export type UserProgressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
  }


  /**
   * Model Achievement
   */

  export type AggregateAchievement = {
    _count: AchievementCountAggregateOutputType | null
    _avg: AchievementAvgAggregateOutputType | null
    _sum: AchievementSumAggregateOutputType | null
    _min: AchievementMinAggregateOutputType | null
    _max: AchievementMaxAggregateOutputType | null
  }

  export type AchievementAvgAggregateOutputType = {
    requirement: number | null
    progress: number | null
    maxProgress: number | null
  }

  export type AchievementSumAggregateOutputType = {
    requirement: number | null
    progress: number | null
    maxProgress: number | null
  }

  export type AchievementMinAggregateOutputType = {
    id: string | null
    progressId: string | null
    name: string | null
    description: string | null
    badge: string | null
    category: $Enums.AchievementCategory | null
    requirement: number | null
    unlocked: boolean | null
    progress: number | null
    maxProgress: number | null
    unlockedAt: Date | null
    createdAt: Date | null
  }

  export type AchievementMaxAggregateOutputType = {
    id: string | null
    progressId: string | null
    name: string | null
    description: string | null
    badge: string | null
    category: $Enums.AchievementCategory | null
    requirement: number | null
    unlocked: boolean | null
    progress: number | null
    maxProgress: number | null
    unlockedAt: Date | null
    createdAt: Date | null
  }

  export type AchievementCountAggregateOutputType = {
    id: number
    progressId: number
    name: number
    description: number
    badge: number
    category: number
    requirement: number
    unlocked: number
    progress: number
    maxProgress: number
    unlockedAt: number
    createdAt: number
    _all: number
  }


  export type AchievementAvgAggregateInputType = {
    requirement?: true
    progress?: true
    maxProgress?: true
  }

  export type AchievementSumAggregateInputType = {
    requirement?: true
    progress?: true
    maxProgress?: true
  }

  export type AchievementMinAggregateInputType = {
    id?: true
    progressId?: true
    name?: true
    description?: true
    badge?: true
    category?: true
    requirement?: true
    unlocked?: true
    progress?: true
    maxProgress?: true
    unlockedAt?: true
    createdAt?: true
  }

  export type AchievementMaxAggregateInputType = {
    id?: true
    progressId?: true
    name?: true
    description?: true
    badge?: true
    category?: true
    requirement?: true
    unlocked?: true
    progress?: true
    maxProgress?: true
    unlockedAt?: true
    createdAt?: true
  }

  export type AchievementCountAggregateInputType = {
    id?: true
    progressId?: true
    name?: true
    description?: true
    badge?: true
    category?: true
    requirement?: true
    unlocked?: true
    progress?: true
    maxProgress?: true
    unlockedAt?: true
    createdAt?: true
    _all?: true
  }

  export type AchievementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Achievement to aggregate.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Achievements
    **/
    _count?: true | AchievementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AchievementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AchievementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AchievementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AchievementMaxAggregateInputType
  }

  export type GetAchievementAggregateType<T extends AchievementAggregateArgs> = {
        [P in keyof T & keyof AggregateAchievement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAchievement[P]>
      : GetScalarType<T[P], AggregateAchievement[P]>
  }




  export type AchievementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AchievementWhereInput
    orderBy?: AchievementOrderByWithAggregationInput | AchievementOrderByWithAggregationInput[]
    by: AchievementScalarFieldEnum[] | AchievementScalarFieldEnum
    having?: AchievementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AchievementCountAggregateInputType | true
    _avg?: AchievementAvgAggregateInputType
    _sum?: AchievementSumAggregateInputType
    _min?: AchievementMinAggregateInputType
    _max?: AchievementMaxAggregateInputType
  }

  export type AchievementGroupByOutputType = {
    id: string
    progressId: string
    name: string
    description: string
    badge: string
    category: $Enums.AchievementCategory
    requirement: number
    unlocked: boolean
    progress: number
    maxProgress: number
    unlockedAt: Date | null
    createdAt: Date
    _count: AchievementCountAggregateOutputType | null
    _avg: AchievementAvgAggregateOutputType | null
    _sum: AchievementSumAggregateOutputType | null
    _min: AchievementMinAggregateOutputType | null
    _max: AchievementMaxAggregateOutputType | null
  }

  type GetAchievementGroupByPayload<T extends AchievementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AchievementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AchievementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AchievementGroupByOutputType[P]>
            : GetScalarType<T[P], AchievementGroupByOutputType[P]>
        }
      >
    >


  export type AchievementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    progressId?: boolean
    name?: boolean
    description?: boolean
    badge?: boolean
    category?: boolean
    requirement?: boolean
    unlocked?: boolean
    progress?: boolean
    maxProgress?: boolean
    unlockedAt?: boolean
    createdAt?: boolean
    userProgress?: boolean | UserProgressDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["achievement"]>

  export type AchievementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    progressId?: boolean
    name?: boolean
    description?: boolean
    badge?: boolean
    category?: boolean
    requirement?: boolean
    unlocked?: boolean
    progress?: boolean
    maxProgress?: boolean
    unlockedAt?: boolean
    createdAt?: boolean
    userProgress?: boolean | UserProgressDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["achievement"]>

  export type AchievementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    progressId?: boolean
    name?: boolean
    description?: boolean
    badge?: boolean
    category?: boolean
    requirement?: boolean
    unlocked?: boolean
    progress?: boolean
    maxProgress?: boolean
    unlockedAt?: boolean
    createdAt?: boolean
    userProgress?: boolean | UserProgressDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["achievement"]>

  export type AchievementSelectScalar = {
    id?: boolean
    progressId?: boolean
    name?: boolean
    description?: boolean
    badge?: boolean
    category?: boolean
    requirement?: boolean
    unlocked?: boolean
    progress?: boolean
    maxProgress?: boolean
    unlockedAt?: boolean
    createdAt?: boolean
  }

  export type AchievementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "progressId" | "name" | "description" | "badge" | "category" | "requirement" | "unlocked" | "progress" | "maxProgress" | "unlockedAt" | "createdAt", ExtArgs["result"]["achievement"]>
  export type AchievementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userProgress?: boolean | UserProgressDefaultArgs<ExtArgs>
  }
  export type AchievementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userProgress?: boolean | UserProgressDefaultArgs<ExtArgs>
  }
  export type AchievementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userProgress?: boolean | UserProgressDefaultArgs<ExtArgs>
  }

  export type $AchievementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Achievement"
    objects: {
      userProgress: Prisma.$UserProgressPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      progressId: string
      name: string
      description: string
      badge: string
      category: $Enums.AchievementCategory
      requirement: number
      unlocked: boolean
      progress: number
      maxProgress: number
      unlockedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["achievement"]>
    composites: {}
  }

  type AchievementGetPayload<S extends boolean | null | undefined | AchievementDefaultArgs> = $Result.GetResult<Prisma.$AchievementPayload, S>

  type AchievementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AchievementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AchievementCountAggregateInputType | true
    }

  export interface AchievementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Achievement'], meta: { name: 'Achievement' } }
    /**
     * Find zero or one Achievement that matches the filter.
     * @param {AchievementFindUniqueArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AchievementFindUniqueArgs>(args: SelectSubset<T, AchievementFindUniqueArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Achievement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AchievementFindUniqueOrThrowArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AchievementFindUniqueOrThrowArgs>(args: SelectSubset<T, AchievementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Achievement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindFirstArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AchievementFindFirstArgs>(args?: SelectSubset<T, AchievementFindFirstArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Achievement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindFirstOrThrowArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AchievementFindFirstOrThrowArgs>(args?: SelectSubset<T, AchievementFindFirstOrThrowArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Achievements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Achievements
     * const achievements = await prisma.achievement.findMany()
     * 
     * // Get first 10 Achievements
     * const achievements = await prisma.achievement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const achievementWithIdOnly = await prisma.achievement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AchievementFindManyArgs>(args?: SelectSubset<T, AchievementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Achievement.
     * @param {AchievementCreateArgs} args - Arguments to create a Achievement.
     * @example
     * // Create one Achievement
     * const Achievement = await prisma.achievement.create({
     *   data: {
     *     // ... data to create a Achievement
     *   }
     * })
     * 
     */
    create<T extends AchievementCreateArgs>(args: SelectSubset<T, AchievementCreateArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Achievements.
     * @param {AchievementCreateManyArgs} args - Arguments to create many Achievements.
     * @example
     * // Create many Achievements
     * const achievement = await prisma.achievement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AchievementCreateManyArgs>(args?: SelectSubset<T, AchievementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Achievements and returns the data saved in the database.
     * @param {AchievementCreateManyAndReturnArgs} args - Arguments to create many Achievements.
     * @example
     * // Create many Achievements
     * const achievement = await prisma.achievement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Achievements and only return the `id`
     * const achievementWithIdOnly = await prisma.achievement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AchievementCreateManyAndReturnArgs>(args?: SelectSubset<T, AchievementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Achievement.
     * @param {AchievementDeleteArgs} args - Arguments to delete one Achievement.
     * @example
     * // Delete one Achievement
     * const Achievement = await prisma.achievement.delete({
     *   where: {
     *     // ... filter to delete one Achievement
     *   }
     * })
     * 
     */
    delete<T extends AchievementDeleteArgs>(args: SelectSubset<T, AchievementDeleteArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Achievement.
     * @param {AchievementUpdateArgs} args - Arguments to update one Achievement.
     * @example
     * // Update one Achievement
     * const achievement = await prisma.achievement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AchievementUpdateArgs>(args: SelectSubset<T, AchievementUpdateArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Achievements.
     * @param {AchievementDeleteManyArgs} args - Arguments to filter Achievements to delete.
     * @example
     * // Delete a few Achievements
     * const { count } = await prisma.achievement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AchievementDeleteManyArgs>(args?: SelectSubset<T, AchievementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Achievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Achievements
     * const achievement = await prisma.achievement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AchievementUpdateManyArgs>(args: SelectSubset<T, AchievementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Achievements and returns the data updated in the database.
     * @param {AchievementUpdateManyAndReturnArgs} args - Arguments to update many Achievements.
     * @example
     * // Update many Achievements
     * const achievement = await prisma.achievement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Achievements and only return the `id`
     * const achievementWithIdOnly = await prisma.achievement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AchievementUpdateManyAndReturnArgs>(args: SelectSubset<T, AchievementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Achievement.
     * @param {AchievementUpsertArgs} args - Arguments to update or create a Achievement.
     * @example
     * // Update or create a Achievement
     * const achievement = await prisma.achievement.upsert({
     *   create: {
     *     // ... data to create a Achievement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Achievement we want to update
     *   }
     * })
     */
    upsert<T extends AchievementUpsertArgs>(args: SelectSubset<T, AchievementUpsertArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Achievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementCountArgs} args - Arguments to filter Achievements to count.
     * @example
     * // Count the number of Achievements
     * const count = await prisma.achievement.count({
     *   where: {
     *     // ... the filter for the Achievements we want to count
     *   }
     * })
    **/
    count<T extends AchievementCountArgs>(
      args?: Subset<T, AchievementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AchievementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Achievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AchievementAggregateArgs>(args: Subset<T, AchievementAggregateArgs>): Prisma.PrismaPromise<GetAchievementAggregateType<T>>

    /**
     * Group by Achievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AchievementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AchievementGroupByArgs['orderBy'] }
        : { orderBy?: AchievementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AchievementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAchievementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Achievement model
   */
  readonly fields: AchievementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Achievement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AchievementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userProgress<T extends UserProgressDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProgressDefaultArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Achievement model
   */
  interface AchievementFieldRefs {
    readonly id: FieldRef<"Achievement", 'String'>
    readonly progressId: FieldRef<"Achievement", 'String'>
    readonly name: FieldRef<"Achievement", 'String'>
    readonly description: FieldRef<"Achievement", 'String'>
    readonly badge: FieldRef<"Achievement", 'String'>
    readonly category: FieldRef<"Achievement", 'AchievementCategory'>
    readonly requirement: FieldRef<"Achievement", 'Int'>
    readonly unlocked: FieldRef<"Achievement", 'Boolean'>
    readonly progress: FieldRef<"Achievement", 'Int'>
    readonly maxProgress: FieldRef<"Achievement", 'Int'>
    readonly unlockedAt: FieldRef<"Achievement", 'DateTime'>
    readonly createdAt: FieldRef<"Achievement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Achievement findUnique
   */
  export type AchievementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement findUniqueOrThrow
   */
  export type AchievementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement findFirst
   */
  export type AchievementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Achievements.
     */
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement findFirstOrThrow
   */
  export type AchievementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Achievements.
     */
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement findMany
   */
  export type AchievementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievements to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement create
   */
  export type AchievementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The data needed to create a Achievement.
     */
    data: XOR<AchievementCreateInput, AchievementUncheckedCreateInput>
  }

  /**
   * Achievement createMany
   */
  export type AchievementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Achievements.
     */
    data: AchievementCreateManyInput | AchievementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Achievement createManyAndReturn
   */
  export type AchievementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * The data used to create many Achievements.
     */
    data: AchievementCreateManyInput | AchievementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Achievement update
   */
  export type AchievementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The data needed to update a Achievement.
     */
    data: XOR<AchievementUpdateInput, AchievementUncheckedUpdateInput>
    /**
     * Choose, which Achievement to update.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement updateMany
   */
  export type AchievementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Achievements.
     */
    data: XOR<AchievementUpdateManyMutationInput, AchievementUncheckedUpdateManyInput>
    /**
     * Filter which Achievements to update
     */
    where?: AchievementWhereInput
    /**
     * Limit how many Achievements to update.
     */
    limit?: number
  }

  /**
   * Achievement updateManyAndReturn
   */
  export type AchievementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * The data used to update Achievements.
     */
    data: XOR<AchievementUpdateManyMutationInput, AchievementUncheckedUpdateManyInput>
    /**
     * Filter which Achievements to update
     */
    where?: AchievementWhereInput
    /**
     * Limit how many Achievements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Achievement upsert
   */
  export type AchievementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The filter to search for the Achievement to update in case it exists.
     */
    where: AchievementWhereUniqueInput
    /**
     * In case the Achievement found by the `where` argument doesn't exist, create a new Achievement with this data.
     */
    create: XOR<AchievementCreateInput, AchievementUncheckedCreateInput>
    /**
     * In case the Achievement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AchievementUpdateInput, AchievementUncheckedUpdateInput>
  }

  /**
   * Achievement delete
   */
  export type AchievementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter which Achievement to delete.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement deleteMany
   */
  export type AchievementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Achievements to delete
     */
    where?: AchievementWhereInput
    /**
     * Limit how many Achievements to delete.
     */
    limit?: number
  }

  /**
   * Achievement without action
   */
  export type AchievementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
  }


  /**
   * Model DailyStats
   */

  export type AggregateDailyStats = {
    _count: DailyStatsCountAggregateOutputType | null
    _avg: DailyStatsAvgAggregateOutputType | null
    _sum: DailyStatsSumAggregateOutputType | null
    _min: DailyStatsMinAggregateOutputType | null
    _max: DailyStatsMaxAggregateOutputType | null
  }

  export type DailyStatsAvgAggregateOutputType = {
    totalXP: number | null
    activitiesCompleted: number | null
    streakCount: number | null
    level: number | null
    routineXP: number | null
    taskXP: number | null
    healthXP: number | null
    focusXP: number | null
    habitXP: number | null
  }

  export type DailyStatsSumAggregateOutputType = {
    totalXP: number | null
    activitiesCompleted: number | null
    streakCount: number | null
    level: number | null
    routineXP: number | null
    taskXP: number | null
    healthXP: number | null
    focusXP: number | null
    habitXP: number | null
  }

  export type DailyStatsMinAggregateOutputType = {
    id: string | null
    progressId: string | null
    date: string | null
    totalXP: number | null
    activitiesCompleted: number | null
    streakCount: number | null
    level: number | null
    routineXP: number | null
    taskXP: number | null
    healthXP: number | null
    focusXP: number | null
    habitXP: number | null
    createdAt: Date | null
  }

  export type DailyStatsMaxAggregateOutputType = {
    id: string | null
    progressId: string | null
    date: string | null
    totalXP: number | null
    activitiesCompleted: number | null
    streakCount: number | null
    level: number | null
    routineXP: number | null
    taskXP: number | null
    healthXP: number | null
    focusXP: number | null
    habitXP: number | null
    createdAt: Date | null
  }

  export type DailyStatsCountAggregateOutputType = {
    id: number
    progressId: number
    date: number
    totalXP: number
    activitiesCompleted: number
    streakCount: number
    level: number
    routineXP: number
    taskXP: number
    healthXP: number
    focusXP: number
    habitXP: number
    createdAt: number
    _all: number
  }


  export type DailyStatsAvgAggregateInputType = {
    totalXP?: true
    activitiesCompleted?: true
    streakCount?: true
    level?: true
    routineXP?: true
    taskXP?: true
    healthXP?: true
    focusXP?: true
    habitXP?: true
  }

  export type DailyStatsSumAggregateInputType = {
    totalXP?: true
    activitiesCompleted?: true
    streakCount?: true
    level?: true
    routineXP?: true
    taskXP?: true
    healthXP?: true
    focusXP?: true
    habitXP?: true
  }

  export type DailyStatsMinAggregateInputType = {
    id?: true
    progressId?: true
    date?: true
    totalXP?: true
    activitiesCompleted?: true
    streakCount?: true
    level?: true
    routineXP?: true
    taskXP?: true
    healthXP?: true
    focusXP?: true
    habitXP?: true
    createdAt?: true
  }

  export type DailyStatsMaxAggregateInputType = {
    id?: true
    progressId?: true
    date?: true
    totalXP?: true
    activitiesCompleted?: true
    streakCount?: true
    level?: true
    routineXP?: true
    taskXP?: true
    healthXP?: true
    focusXP?: true
    habitXP?: true
    createdAt?: true
  }

  export type DailyStatsCountAggregateInputType = {
    id?: true
    progressId?: true
    date?: true
    totalXP?: true
    activitiesCompleted?: true
    streakCount?: true
    level?: true
    routineXP?: true
    taskXP?: true
    healthXP?: true
    focusXP?: true
    habitXP?: true
    createdAt?: true
    _all?: true
  }

  export type DailyStatsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyStats to aggregate.
     */
    where?: DailyStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyStats to fetch.
     */
    orderBy?: DailyStatsOrderByWithRelationInput | DailyStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DailyStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DailyStats
    **/
    _count?: true | DailyStatsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DailyStatsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DailyStatsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DailyStatsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DailyStatsMaxAggregateInputType
  }

  export type GetDailyStatsAggregateType<T extends DailyStatsAggregateArgs> = {
        [P in keyof T & keyof AggregateDailyStats]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDailyStats[P]>
      : GetScalarType<T[P], AggregateDailyStats[P]>
  }




  export type DailyStatsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyStatsWhereInput
    orderBy?: DailyStatsOrderByWithAggregationInput | DailyStatsOrderByWithAggregationInput[]
    by: DailyStatsScalarFieldEnum[] | DailyStatsScalarFieldEnum
    having?: DailyStatsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DailyStatsCountAggregateInputType | true
    _avg?: DailyStatsAvgAggregateInputType
    _sum?: DailyStatsSumAggregateInputType
    _min?: DailyStatsMinAggregateInputType
    _max?: DailyStatsMaxAggregateInputType
  }

  export type DailyStatsGroupByOutputType = {
    id: string
    progressId: string
    date: string
    totalXP: number
    activitiesCompleted: number
    streakCount: number
    level: number
    routineXP: number
    taskXP: number
    healthXP: number
    focusXP: number
    habitXP: number
    createdAt: Date
    _count: DailyStatsCountAggregateOutputType | null
    _avg: DailyStatsAvgAggregateOutputType | null
    _sum: DailyStatsSumAggregateOutputType | null
    _min: DailyStatsMinAggregateOutputType | null
    _max: DailyStatsMaxAggregateOutputType | null
  }

  type GetDailyStatsGroupByPayload<T extends DailyStatsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DailyStatsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DailyStatsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DailyStatsGroupByOutputType[P]>
            : GetScalarType<T[P], DailyStatsGroupByOutputType[P]>
        }
      >
    >


  export type DailyStatsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    progressId?: boolean
    date?: boolean
    totalXP?: boolean
    activitiesCompleted?: boolean
    streakCount?: boolean
    level?: boolean
    routineXP?: boolean
    taskXP?: boolean
    healthXP?: boolean
    focusXP?: boolean
    habitXP?: boolean
    createdAt?: boolean
    userProgress?: boolean | UserProgressDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailyStats"]>

  export type DailyStatsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    progressId?: boolean
    date?: boolean
    totalXP?: boolean
    activitiesCompleted?: boolean
    streakCount?: boolean
    level?: boolean
    routineXP?: boolean
    taskXP?: boolean
    healthXP?: boolean
    focusXP?: boolean
    habitXP?: boolean
    createdAt?: boolean
    userProgress?: boolean | UserProgressDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailyStats"]>

  export type DailyStatsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    progressId?: boolean
    date?: boolean
    totalXP?: boolean
    activitiesCompleted?: boolean
    streakCount?: boolean
    level?: boolean
    routineXP?: boolean
    taskXP?: boolean
    healthXP?: boolean
    focusXP?: boolean
    habitXP?: boolean
    createdAt?: boolean
    userProgress?: boolean | UserProgressDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailyStats"]>

  export type DailyStatsSelectScalar = {
    id?: boolean
    progressId?: boolean
    date?: boolean
    totalXP?: boolean
    activitiesCompleted?: boolean
    streakCount?: boolean
    level?: boolean
    routineXP?: boolean
    taskXP?: boolean
    healthXP?: boolean
    focusXP?: boolean
    habitXP?: boolean
    createdAt?: boolean
  }

  export type DailyStatsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "progressId" | "date" | "totalXP" | "activitiesCompleted" | "streakCount" | "level" | "routineXP" | "taskXP" | "healthXP" | "focusXP" | "habitXP" | "createdAt", ExtArgs["result"]["dailyStats"]>
  export type DailyStatsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userProgress?: boolean | UserProgressDefaultArgs<ExtArgs>
  }
  export type DailyStatsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userProgress?: boolean | UserProgressDefaultArgs<ExtArgs>
  }
  export type DailyStatsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userProgress?: boolean | UserProgressDefaultArgs<ExtArgs>
  }

  export type $DailyStatsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DailyStats"
    objects: {
      userProgress: Prisma.$UserProgressPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      progressId: string
      date: string
      totalXP: number
      activitiesCompleted: number
      streakCount: number
      level: number
      routineXP: number
      taskXP: number
      healthXP: number
      focusXP: number
      habitXP: number
      createdAt: Date
    }, ExtArgs["result"]["dailyStats"]>
    composites: {}
  }

  type DailyStatsGetPayload<S extends boolean | null | undefined | DailyStatsDefaultArgs> = $Result.GetResult<Prisma.$DailyStatsPayload, S>

  type DailyStatsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DailyStatsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DailyStatsCountAggregateInputType | true
    }

  export interface DailyStatsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DailyStats'], meta: { name: 'DailyStats' } }
    /**
     * Find zero or one DailyStats that matches the filter.
     * @param {DailyStatsFindUniqueArgs} args - Arguments to find a DailyStats
     * @example
     * // Get one DailyStats
     * const dailyStats = await prisma.dailyStats.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DailyStatsFindUniqueArgs>(args: SelectSubset<T, DailyStatsFindUniqueArgs<ExtArgs>>): Prisma__DailyStatsClient<$Result.GetResult<Prisma.$DailyStatsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DailyStats that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DailyStatsFindUniqueOrThrowArgs} args - Arguments to find a DailyStats
     * @example
     * // Get one DailyStats
     * const dailyStats = await prisma.dailyStats.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DailyStatsFindUniqueOrThrowArgs>(args: SelectSubset<T, DailyStatsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DailyStatsClient<$Result.GetResult<Prisma.$DailyStatsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DailyStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyStatsFindFirstArgs} args - Arguments to find a DailyStats
     * @example
     * // Get one DailyStats
     * const dailyStats = await prisma.dailyStats.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DailyStatsFindFirstArgs>(args?: SelectSubset<T, DailyStatsFindFirstArgs<ExtArgs>>): Prisma__DailyStatsClient<$Result.GetResult<Prisma.$DailyStatsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DailyStats that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyStatsFindFirstOrThrowArgs} args - Arguments to find a DailyStats
     * @example
     * // Get one DailyStats
     * const dailyStats = await prisma.dailyStats.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DailyStatsFindFirstOrThrowArgs>(args?: SelectSubset<T, DailyStatsFindFirstOrThrowArgs<ExtArgs>>): Prisma__DailyStatsClient<$Result.GetResult<Prisma.$DailyStatsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DailyStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyStatsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DailyStats
     * const dailyStats = await prisma.dailyStats.findMany()
     * 
     * // Get first 10 DailyStats
     * const dailyStats = await prisma.dailyStats.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dailyStatsWithIdOnly = await prisma.dailyStats.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DailyStatsFindManyArgs>(args?: SelectSubset<T, DailyStatsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyStatsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DailyStats.
     * @param {DailyStatsCreateArgs} args - Arguments to create a DailyStats.
     * @example
     * // Create one DailyStats
     * const DailyStats = await prisma.dailyStats.create({
     *   data: {
     *     // ... data to create a DailyStats
     *   }
     * })
     * 
     */
    create<T extends DailyStatsCreateArgs>(args: SelectSubset<T, DailyStatsCreateArgs<ExtArgs>>): Prisma__DailyStatsClient<$Result.GetResult<Prisma.$DailyStatsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DailyStats.
     * @param {DailyStatsCreateManyArgs} args - Arguments to create many DailyStats.
     * @example
     * // Create many DailyStats
     * const dailyStats = await prisma.dailyStats.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DailyStatsCreateManyArgs>(args?: SelectSubset<T, DailyStatsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DailyStats and returns the data saved in the database.
     * @param {DailyStatsCreateManyAndReturnArgs} args - Arguments to create many DailyStats.
     * @example
     * // Create many DailyStats
     * const dailyStats = await prisma.dailyStats.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DailyStats and only return the `id`
     * const dailyStatsWithIdOnly = await prisma.dailyStats.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DailyStatsCreateManyAndReturnArgs>(args?: SelectSubset<T, DailyStatsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyStatsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DailyStats.
     * @param {DailyStatsDeleteArgs} args - Arguments to delete one DailyStats.
     * @example
     * // Delete one DailyStats
     * const DailyStats = await prisma.dailyStats.delete({
     *   where: {
     *     // ... filter to delete one DailyStats
     *   }
     * })
     * 
     */
    delete<T extends DailyStatsDeleteArgs>(args: SelectSubset<T, DailyStatsDeleteArgs<ExtArgs>>): Prisma__DailyStatsClient<$Result.GetResult<Prisma.$DailyStatsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DailyStats.
     * @param {DailyStatsUpdateArgs} args - Arguments to update one DailyStats.
     * @example
     * // Update one DailyStats
     * const dailyStats = await prisma.dailyStats.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DailyStatsUpdateArgs>(args: SelectSubset<T, DailyStatsUpdateArgs<ExtArgs>>): Prisma__DailyStatsClient<$Result.GetResult<Prisma.$DailyStatsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DailyStats.
     * @param {DailyStatsDeleteManyArgs} args - Arguments to filter DailyStats to delete.
     * @example
     * // Delete a few DailyStats
     * const { count } = await prisma.dailyStats.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DailyStatsDeleteManyArgs>(args?: SelectSubset<T, DailyStatsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyStatsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DailyStats
     * const dailyStats = await prisma.dailyStats.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DailyStatsUpdateManyArgs>(args: SelectSubset<T, DailyStatsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyStats and returns the data updated in the database.
     * @param {DailyStatsUpdateManyAndReturnArgs} args - Arguments to update many DailyStats.
     * @example
     * // Update many DailyStats
     * const dailyStats = await prisma.dailyStats.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DailyStats and only return the `id`
     * const dailyStatsWithIdOnly = await prisma.dailyStats.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DailyStatsUpdateManyAndReturnArgs>(args: SelectSubset<T, DailyStatsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyStatsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DailyStats.
     * @param {DailyStatsUpsertArgs} args - Arguments to update or create a DailyStats.
     * @example
     * // Update or create a DailyStats
     * const dailyStats = await prisma.dailyStats.upsert({
     *   create: {
     *     // ... data to create a DailyStats
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DailyStats we want to update
     *   }
     * })
     */
    upsert<T extends DailyStatsUpsertArgs>(args: SelectSubset<T, DailyStatsUpsertArgs<ExtArgs>>): Prisma__DailyStatsClient<$Result.GetResult<Prisma.$DailyStatsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DailyStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyStatsCountArgs} args - Arguments to filter DailyStats to count.
     * @example
     * // Count the number of DailyStats
     * const count = await prisma.dailyStats.count({
     *   where: {
     *     // ... the filter for the DailyStats we want to count
     *   }
     * })
    **/
    count<T extends DailyStatsCountArgs>(
      args?: Subset<T, DailyStatsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DailyStatsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DailyStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyStatsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DailyStatsAggregateArgs>(args: Subset<T, DailyStatsAggregateArgs>): Prisma.PrismaPromise<GetDailyStatsAggregateType<T>>

    /**
     * Group by DailyStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyStatsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DailyStatsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DailyStatsGroupByArgs['orderBy'] }
        : { orderBy?: DailyStatsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DailyStatsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDailyStatsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DailyStats model
   */
  readonly fields: DailyStatsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DailyStats.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DailyStatsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userProgress<T extends UserProgressDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProgressDefaultArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DailyStats model
   */
  interface DailyStatsFieldRefs {
    readonly id: FieldRef<"DailyStats", 'String'>
    readonly progressId: FieldRef<"DailyStats", 'String'>
    readonly date: FieldRef<"DailyStats", 'String'>
    readonly totalXP: FieldRef<"DailyStats", 'Int'>
    readonly activitiesCompleted: FieldRef<"DailyStats", 'Int'>
    readonly streakCount: FieldRef<"DailyStats", 'Int'>
    readonly level: FieldRef<"DailyStats", 'Int'>
    readonly routineXP: FieldRef<"DailyStats", 'Int'>
    readonly taskXP: FieldRef<"DailyStats", 'Int'>
    readonly healthXP: FieldRef<"DailyStats", 'Int'>
    readonly focusXP: FieldRef<"DailyStats", 'Int'>
    readonly habitXP: FieldRef<"DailyStats", 'Int'>
    readonly createdAt: FieldRef<"DailyStats", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DailyStats findUnique
   */
  export type DailyStatsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyStats
     */
    select?: DailyStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyStats
     */
    omit?: DailyStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyStatsInclude<ExtArgs> | null
    /**
     * Filter, which DailyStats to fetch.
     */
    where: DailyStatsWhereUniqueInput
  }

  /**
   * DailyStats findUniqueOrThrow
   */
  export type DailyStatsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyStats
     */
    select?: DailyStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyStats
     */
    omit?: DailyStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyStatsInclude<ExtArgs> | null
    /**
     * Filter, which DailyStats to fetch.
     */
    where: DailyStatsWhereUniqueInput
  }

  /**
   * DailyStats findFirst
   */
  export type DailyStatsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyStats
     */
    select?: DailyStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyStats
     */
    omit?: DailyStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyStatsInclude<ExtArgs> | null
    /**
     * Filter, which DailyStats to fetch.
     */
    where?: DailyStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyStats to fetch.
     */
    orderBy?: DailyStatsOrderByWithRelationInput | DailyStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyStats.
     */
    cursor?: DailyStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyStats.
     */
    distinct?: DailyStatsScalarFieldEnum | DailyStatsScalarFieldEnum[]
  }

  /**
   * DailyStats findFirstOrThrow
   */
  export type DailyStatsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyStats
     */
    select?: DailyStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyStats
     */
    omit?: DailyStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyStatsInclude<ExtArgs> | null
    /**
     * Filter, which DailyStats to fetch.
     */
    where?: DailyStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyStats to fetch.
     */
    orderBy?: DailyStatsOrderByWithRelationInput | DailyStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyStats.
     */
    cursor?: DailyStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyStats.
     */
    distinct?: DailyStatsScalarFieldEnum | DailyStatsScalarFieldEnum[]
  }

  /**
   * DailyStats findMany
   */
  export type DailyStatsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyStats
     */
    select?: DailyStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyStats
     */
    omit?: DailyStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyStatsInclude<ExtArgs> | null
    /**
     * Filter, which DailyStats to fetch.
     */
    where?: DailyStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyStats to fetch.
     */
    orderBy?: DailyStatsOrderByWithRelationInput | DailyStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DailyStats.
     */
    cursor?: DailyStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyStats.
     */
    skip?: number
    distinct?: DailyStatsScalarFieldEnum | DailyStatsScalarFieldEnum[]
  }

  /**
   * DailyStats create
   */
  export type DailyStatsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyStats
     */
    select?: DailyStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyStats
     */
    omit?: DailyStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyStatsInclude<ExtArgs> | null
    /**
     * The data needed to create a DailyStats.
     */
    data: XOR<DailyStatsCreateInput, DailyStatsUncheckedCreateInput>
  }

  /**
   * DailyStats createMany
   */
  export type DailyStatsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DailyStats.
     */
    data: DailyStatsCreateManyInput | DailyStatsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DailyStats createManyAndReturn
   */
  export type DailyStatsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyStats
     */
    select?: DailyStatsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DailyStats
     */
    omit?: DailyStatsOmit<ExtArgs> | null
    /**
     * The data used to create many DailyStats.
     */
    data: DailyStatsCreateManyInput | DailyStatsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyStatsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DailyStats update
   */
  export type DailyStatsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyStats
     */
    select?: DailyStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyStats
     */
    omit?: DailyStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyStatsInclude<ExtArgs> | null
    /**
     * The data needed to update a DailyStats.
     */
    data: XOR<DailyStatsUpdateInput, DailyStatsUncheckedUpdateInput>
    /**
     * Choose, which DailyStats to update.
     */
    where: DailyStatsWhereUniqueInput
  }

  /**
   * DailyStats updateMany
   */
  export type DailyStatsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DailyStats.
     */
    data: XOR<DailyStatsUpdateManyMutationInput, DailyStatsUncheckedUpdateManyInput>
    /**
     * Filter which DailyStats to update
     */
    where?: DailyStatsWhereInput
    /**
     * Limit how many DailyStats to update.
     */
    limit?: number
  }

  /**
   * DailyStats updateManyAndReturn
   */
  export type DailyStatsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyStats
     */
    select?: DailyStatsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DailyStats
     */
    omit?: DailyStatsOmit<ExtArgs> | null
    /**
     * The data used to update DailyStats.
     */
    data: XOR<DailyStatsUpdateManyMutationInput, DailyStatsUncheckedUpdateManyInput>
    /**
     * Filter which DailyStats to update
     */
    where?: DailyStatsWhereInput
    /**
     * Limit how many DailyStats to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyStatsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DailyStats upsert
   */
  export type DailyStatsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyStats
     */
    select?: DailyStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyStats
     */
    omit?: DailyStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyStatsInclude<ExtArgs> | null
    /**
     * The filter to search for the DailyStats to update in case it exists.
     */
    where: DailyStatsWhereUniqueInput
    /**
     * In case the DailyStats found by the `where` argument doesn't exist, create a new DailyStats with this data.
     */
    create: XOR<DailyStatsCreateInput, DailyStatsUncheckedCreateInput>
    /**
     * In case the DailyStats was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DailyStatsUpdateInput, DailyStatsUncheckedUpdateInput>
  }

  /**
   * DailyStats delete
   */
  export type DailyStatsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyStats
     */
    select?: DailyStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyStats
     */
    omit?: DailyStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyStatsInclude<ExtArgs> | null
    /**
     * Filter which DailyStats to delete.
     */
    where: DailyStatsWhereUniqueInput
  }

  /**
   * DailyStats deleteMany
   */
  export type DailyStatsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyStats to delete
     */
    where?: DailyStatsWhereInput
    /**
     * Limit how many DailyStats to delete.
     */
    limit?: number
  }

  /**
   * DailyStats without action
   */
  export type DailyStatsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyStats
     */
    select?: DailyStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyStats
     */
    omit?: DailyStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyStatsInclude<ExtArgs> | null
  }


  /**
   * Model XPBalance
   */

  export type AggregateXPBalance = {
    _count: XPBalanceCountAggregateOutputType | null
    _avg: XPBalanceAvgAggregateOutputType | null
    _sum: XPBalanceSumAggregateOutputType | null
    _min: XPBalanceMinAggregateOutputType | null
    _max: XPBalanceMaxAggregateOutputType | null
  }

  export type XPBalanceAvgAggregateOutputType = {
    currentXP: number | null
    totalEarned: number | null
    totalSpent: number | null
    reserveXP: number | null
    pendingLoans: number | null
  }

  export type XPBalanceSumAggregateOutputType = {
    currentXP: number | null
    totalEarned: number | null
    totalSpent: number | null
    reserveXP: number | null
    pendingLoans: number | null
  }

  export type XPBalanceMinAggregateOutputType = {
    id: string | null
    userId: string | null
    currentXP: number | null
    totalEarned: number | null
    totalSpent: number | null
    reserveXP: number | null
    pendingLoans: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type XPBalanceMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    currentXP: number | null
    totalEarned: number | null
    totalSpent: number | null
    reserveXP: number | null
    pendingLoans: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type XPBalanceCountAggregateOutputType = {
    id: number
    userId: number
    currentXP: number
    totalEarned: number
    totalSpent: number
    reserveXP: number
    pendingLoans: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type XPBalanceAvgAggregateInputType = {
    currentXP?: true
    totalEarned?: true
    totalSpent?: true
    reserveXP?: true
    pendingLoans?: true
  }

  export type XPBalanceSumAggregateInputType = {
    currentXP?: true
    totalEarned?: true
    totalSpent?: true
    reserveXP?: true
    pendingLoans?: true
  }

  export type XPBalanceMinAggregateInputType = {
    id?: true
    userId?: true
    currentXP?: true
    totalEarned?: true
    totalSpent?: true
    reserveXP?: true
    pendingLoans?: true
    createdAt?: true
    updatedAt?: true
  }

  export type XPBalanceMaxAggregateInputType = {
    id?: true
    userId?: true
    currentXP?: true
    totalEarned?: true
    totalSpent?: true
    reserveXP?: true
    pendingLoans?: true
    createdAt?: true
    updatedAt?: true
  }

  export type XPBalanceCountAggregateInputType = {
    id?: true
    userId?: true
    currentXP?: true
    totalEarned?: true
    totalSpent?: true
    reserveXP?: true
    pendingLoans?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type XPBalanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which XPBalance to aggregate.
     */
    where?: XPBalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of XPBalances to fetch.
     */
    orderBy?: XPBalanceOrderByWithRelationInput | XPBalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: XPBalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` XPBalances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` XPBalances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned XPBalances
    **/
    _count?: true | XPBalanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: XPBalanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: XPBalanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: XPBalanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: XPBalanceMaxAggregateInputType
  }

  export type GetXPBalanceAggregateType<T extends XPBalanceAggregateArgs> = {
        [P in keyof T & keyof AggregateXPBalance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateXPBalance[P]>
      : GetScalarType<T[P], AggregateXPBalance[P]>
  }




  export type XPBalanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: XPBalanceWhereInput
    orderBy?: XPBalanceOrderByWithAggregationInput | XPBalanceOrderByWithAggregationInput[]
    by: XPBalanceScalarFieldEnum[] | XPBalanceScalarFieldEnum
    having?: XPBalanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: XPBalanceCountAggregateInputType | true
    _avg?: XPBalanceAvgAggregateInputType
    _sum?: XPBalanceSumAggregateInputType
    _min?: XPBalanceMinAggregateInputType
    _max?: XPBalanceMaxAggregateInputType
  }

  export type XPBalanceGroupByOutputType = {
    id: string
    userId: string
    currentXP: number
    totalEarned: number
    totalSpent: number
    reserveXP: number
    pendingLoans: number
    createdAt: Date
    updatedAt: Date
    _count: XPBalanceCountAggregateOutputType | null
    _avg: XPBalanceAvgAggregateOutputType | null
    _sum: XPBalanceSumAggregateOutputType | null
    _min: XPBalanceMinAggregateOutputType | null
    _max: XPBalanceMaxAggregateOutputType | null
  }

  type GetXPBalanceGroupByPayload<T extends XPBalanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<XPBalanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof XPBalanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], XPBalanceGroupByOutputType[P]>
            : GetScalarType<T[P], XPBalanceGroupByOutputType[P]>
        }
      >
    >


  export type XPBalanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    currentXP?: boolean
    totalEarned?: boolean
    totalSpent?: boolean
    reserveXP?: boolean
    pendingLoans?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["xPBalance"]>

  export type XPBalanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    currentXP?: boolean
    totalEarned?: boolean
    totalSpent?: boolean
    reserveXP?: boolean
    pendingLoans?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["xPBalance"]>

  export type XPBalanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    currentXP?: boolean
    totalEarned?: boolean
    totalSpent?: boolean
    reserveXP?: boolean
    pendingLoans?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["xPBalance"]>

  export type XPBalanceSelectScalar = {
    id?: boolean
    userId?: boolean
    currentXP?: boolean
    totalEarned?: boolean
    totalSpent?: boolean
    reserveXP?: boolean
    pendingLoans?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type XPBalanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "currentXP" | "totalEarned" | "totalSpent" | "reserveXP" | "pendingLoans" | "createdAt" | "updatedAt", ExtArgs["result"]["xPBalance"]>
  export type XPBalanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type XPBalanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type XPBalanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $XPBalancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "XPBalance"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      currentXP: number
      totalEarned: number
      totalSpent: number
      reserveXP: number
      pendingLoans: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["xPBalance"]>
    composites: {}
  }

  type XPBalanceGetPayload<S extends boolean | null | undefined | XPBalanceDefaultArgs> = $Result.GetResult<Prisma.$XPBalancePayload, S>

  type XPBalanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<XPBalanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: XPBalanceCountAggregateInputType | true
    }

  export interface XPBalanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['XPBalance'], meta: { name: 'XPBalance' } }
    /**
     * Find zero or one XPBalance that matches the filter.
     * @param {XPBalanceFindUniqueArgs} args - Arguments to find a XPBalance
     * @example
     * // Get one XPBalance
     * const xPBalance = await prisma.xPBalance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends XPBalanceFindUniqueArgs>(args: SelectSubset<T, XPBalanceFindUniqueArgs<ExtArgs>>): Prisma__XPBalanceClient<$Result.GetResult<Prisma.$XPBalancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one XPBalance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {XPBalanceFindUniqueOrThrowArgs} args - Arguments to find a XPBalance
     * @example
     * // Get one XPBalance
     * const xPBalance = await prisma.xPBalance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends XPBalanceFindUniqueOrThrowArgs>(args: SelectSubset<T, XPBalanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__XPBalanceClient<$Result.GetResult<Prisma.$XPBalancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first XPBalance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XPBalanceFindFirstArgs} args - Arguments to find a XPBalance
     * @example
     * // Get one XPBalance
     * const xPBalance = await prisma.xPBalance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends XPBalanceFindFirstArgs>(args?: SelectSubset<T, XPBalanceFindFirstArgs<ExtArgs>>): Prisma__XPBalanceClient<$Result.GetResult<Prisma.$XPBalancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first XPBalance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XPBalanceFindFirstOrThrowArgs} args - Arguments to find a XPBalance
     * @example
     * // Get one XPBalance
     * const xPBalance = await prisma.xPBalance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends XPBalanceFindFirstOrThrowArgs>(args?: SelectSubset<T, XPBalanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__XPBalanceClient<$Result.GetResult<Prisma.$XPBalancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more XPBalances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XPBalanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all XPBalances
     * const xPBalances = await prisma.xPBalance.findMany()
     * 
     * // Get first 10 XPBalances
     * const xPBalances = await prisma.xPBalance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const xPBalanceWithIdOnly = await prisma.xPBalance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends XPBalanceFindManyArgs>(args?: SelectSubset<T, XPBalanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$XPBalancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a XPBalance.
     * @param {XPBalanceCreateArgs} args - Arguments to create a XPBalance.
     * @example
     * // Create one XPBalance
     * const XPBalance = await prisma.xPBalance.create({
     *   data: {
     *     // ... data to create a XPBalance
     *   }
     * })
     * 
     */
    create<T extends XPBalanceCreateArgs>(args: SelectSubset<T, XPBalanceCreateArgs<ExtArgs>>): Prisma__XPBalanceClient<$Result.GetResult<Prisma.$XPBalancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many XPBalances.
     * @param {XPBalanceCreateManyArgs} args - Arguments to create many XPBalances.
     * @example
     * // Create many XPBalances
     * const xPBalance = await prisma.xPBalance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends XPBalanceCreateManyArgs>(args?: SelectSubset<T, XPBalanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many XPBalances and returns the data saved in the database.
     * @param {XPBalanceCreateManyAndReturnArgs} args - Arguments to create many XPBalances.
     * @example
     * // Create many XPBalances
     * const xPBalance = await prisma.xPBalance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many XPBalances and only return the `id`
     * const xPBalanceWithIdOnly = await prisma.xPBalance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends XPBalanceCreateManyAndReturnArgs>(args?: SelectSubset<T, XPBalanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$XPBalancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a XPBalance.
     * @param {XPBalanceDeleteArgs} args - Arguments to delete one XPBalance.
     * @example
     * // Delete one XPBalance
     * const XPBalance = await prisma.xPBalance.delete({
     *   where: {
     *     // ... filter to delete one XPBalance
     *   }
     * })
     * 
     */
    delete<T extends XPBalanceDeleteArgs>(args: SelectSubset<T, XPBalanceDeleteArgs<ExtArgs>>): Prisma__XPBalanceClient<$Result.GetResult<Prisma.$XPBalancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one XPBalance.
     * @param {XPBalanceUpdateArgs} args - Arguments to update one XPBalance.
     * @example
     * // Update one XPBalance
     * const xPBalance = await prisma.xPBalance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends XPBalanceUpdateArgs>(args: SelectSubset<T, XPBalanceUpdateArgs<ExtArgs>>): Prisma__XPBalanceClient<$Result.GetResult<Prisma.$XPBalancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more XPBalances.
     * @param {XPBalanceDeleteManyArgs} args - Arguments to filter XPBalances to delete.
     * @example
     * // Delete a few XPBalances
     * const { count } = await prisma.xPBalance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends XPBalanceDeleteManyArgs>(args?: SelectSubset<T, XPBalanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more XPBalances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XPBalanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many XPBalances
     * const xPBalance = await prisma.xPBalance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends XPBalanceUpdateManyArgs>(args: SelectSubset<T, XPBalanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more XPBalances and returns the data updated in the database.
     * @param {XPBalanceUpdateManyAndReturnArgs} args - Arguments to update many XPBalances.
     * @example
     * // Update many XPBalances
     * const xPBalance = await prisma.xPBalance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more XPBalances and only return the `id`
     * const xPBalanceWithIdOnly = await prisma.xPBalance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends XPBalanceUpdateManyAndReturnArgs>(args: SelectSubset<T, XPBalanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$XPBalancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one XPBalance.
     * @param {XPBalanceUpsertArgs} args - Arguments to update or create a XPBalance.
     * @example
     * // Update or create a XPBalance
     * const xPBalance = await prisma.xPBalance.upsert({
     *   create: {
     *     // ... data to create a XPBalance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the XPBalance we want to update
     *   }
     * })
     */
    upsert<T extends XPBalanceUpsertArgs>(args: SelectSubset<T, XPBalanceUpsertArgs<ExtArgs>>): Prisma__XPBalanceClient<$Result.GetResult<Prisma.$XPBalancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of XPBalances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XPBalanceCountArgs} args - Arguments to filter XPBalances to count.
     * @example
     * // Count the number of XPBalances
     * const count = await prisma.xPBalance.count({
     *   where: {
     *     // ... the filter for the XPBalances we want to count
     *   }
     * })
    **/
    count<T extends XPBalanceCountArgs>(
      args?: Subset<T, XPBalanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], XPBalanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a XPBalance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XPBalanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends XPBalanceAggregateArgs>(args: Subset<T, XPBalanceAggregateArgs>): Prisma.PrismaPromise<GetXPBalanceAggregateType<T>>

    /**
     * Group by XPBalance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XPBalanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends XPBalanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: XPBalanceGroupByArgs['orderBy'] }
        : { orderBy?: XPBalanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, XPBalanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetXPBalanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the XPBalance model
   */
  readonly fields: XPBalanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for XPBalance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__XPBalanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the XPBalance model
   */
  interface XPBalanceFieldRefs {
    readonly id: FieldRef<"XPBalance", 'String'>
    readonly userId: FieldRef<"XPBalance", 'String'>
    readonly currentXP: FieldRef<"XPBalance", 'Int'>
    readonly totalEarned: FieldRef<"XPBalance", 'Int'>
    readonly totalSpent: FieldRef<"XPBalance", 'Int'>
    readonly reserveXP: FieldRef<"XPBalance", 'Int'>
    readonly pendingLoans: FieldRef<"XPBalance", 'Int'>
    readonly createdAt: FieldRef<"XPBalance", 'DateTime'>
    readonly updatedAt: FieldRef<"XPBalance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * XPBalance findUnique
   */
  export type XPBalanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XPBalance
     */
    select?: XPBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XPBalance
     */
    omit?: XPBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XPBalanceInclude<ExtArgs> | null
    /**
     * Filter, which XPBalance to fetch.
     */
    where: XPBalanceWhereUniqueInput
  }

  /**
   * XPBalance findUniqueOrThrow
   */
  export type XPBalanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XPBalance
     */
    select?: XPBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XPBalance
     */
    omit?: XPBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XPBalanceInclude<ExtArgs> | null
    /**
     * Filter, which XPBalance to fetch.
     */
    where: XPBalanceWhereUniqueInput
  }

  /**
   * XPBalance findFirst
   */
  export type XPBalanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XPBalance
     */
    select?: XPBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XPBalance
     */
    omit?: XPBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XPBalanceInclude<ExtArgs> | null
    /**
     * Filter, which XPBalance to fetch.
     */
    where?: XPBalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of XPBalances to fetch.
     */
    orderBy?: XPBalanceOrderByWithRelationInput | XPBalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for XPBalances.
     */
    cursor?: XPBalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` XPBalances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` XPBalances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of XPBalances.
     */
    distinct?: XPBalanceScalarFieldEnum | XPBalanceScalarFieldEnum[]
  }

  /**
   * XPBalance findFirstOrThrow
   */
  export type XPBalanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XPBalance
     */
    select?: XPBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XPBalance
     */
    omit?: XPBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XPBalanceInclude<ExtArgs> | null
    /**
     * Filter, which XPBalance to fetch.
     */
    where?: XPBalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of XPBalances to fetch.
     */
    orderBy?: XPBalanceOrderByWithRelationInput | XPBalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for XPBalances.
     */
    cursor?: XPBalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` XPBalances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` XPBalances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of XPBalances.
     */
    distinct?: XPBalanceScalarFieldEnum | XPBalanceScalarFieldEnum[]
  }

  /**
   * XPBalance findMany
   */
  export type XPBalanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XPBalance
     */
    select?: XPBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XPBalance
     */
    omit?: XPBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XPBalanceInclude<ExtArgs> | null
    /**
     * Filter, which XPBalances to fetch.
     */
    where?: XPBalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of XPBalances to fetch.
     */
    orderBy?: XPBalanceOrderByWithRelationInput | XPBalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing XPBalances.
     */
    cursor?: XPBalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` XPBalances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` XPBalances.
     */
    skip?: number
    distinct?: XPBalanceScalarFieldEnum | XPBalanceScalarFieldEnum[]
  }

  /**
   * XPBalance create
   */
  export type XPBalanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XPBalance
     */
    select?: XPBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XPBalance
     */
    omit?: XPBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XPBalanceInclude<ExtArgs> | null
    /**
     * The data needed to create a XPBalance.
     */
    data: XOR<XPBalanceCreateInput, XPBalanceUncheckedCreateInput>
  }

  /**
   * XPBalance createMany
   */
  export type XPBalanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many XPBalances.
     */
    data: XPBalanceCreateManyInput | XPBalanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * XPBalance createManyAndReturn
   */
  export type XPBalanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XPBalance
     */
    select?: XPBalanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the XPBalance
     */
    omit?: XPBalanceOmit<ExtArgs> | null
    /**
     * The data used to create many XPBalances.
     */
    data: XPBalanceCreateManyInput | XPBalanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XPBalanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * XPBalance update
   */
  export type XPBalanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XPBalance
     */
    select?: XPBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XPBalance
     */
    omit?: XPBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XPBalanceInclude<ExtArgs> | null
    /**
     * The data needed to update a XPBalance.
     */
    data: XOR<XPBalanceUpdateInput, XPBalanceUncheckedUpdateInput>
    /**
     * Choose, which XPBalance to update.
     */
    where: XPBalanceWhereUniqueInput
  }

  /**
   * XPBalance updateMany
   */
  export type XPBalanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update XPBalances.
     */
    data: XOR<XPBalanceUpdateManyMutationInput, XPBalanceUncheckedUpdateManyInput>
    /**
     * Filter which XPBalances to update
     */
    where?: XPBalanceWhereInput
    /**
     * Limit how many XPBalances to update.
     */
    limit?: number
  }

  /**
   * XPBalance updateManyAndReturn
   */
  export type XPBalanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XPBalance
     */
    select?: XPBalanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the XPBalance
     */
    omit?: XPBalanceOmit<ExtArgs> | null
    /**
     * The data used to update XPBalances.
     */
    data: XOR<XPBalanceUpdateManyMutationInput, XPBalanceUncheckedUpdateManyInput>
    /**
     * Filter which XPBalances to update
     */
    where?: XPBalanceWhereInput
    /**
     * Limit how many XPBalances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XPBalanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * XPBalance upsert
   */
  export type XPBalanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XPBalance
     */
    select?: XPBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XPBalance
     */
    omit?: XPBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XPBalanceInclude<ExtArgs> | null
    /**
     * The filter to search for the XPBalance to update in case it exists.
     */
    where: XPBalanceWhereUniqueInput
    /**
     * In case the XPBalance found by the `where` argument doesn't exist, create a new XPBalance with this data.
     */
    create: XOR<XPBalanceCreateInput, XPBalanceUncheckedCreateInput>
    /**
     * In case the XPBalance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<XPBalanceUpdateInput, XPBalanceUncheckedUpdateInput>
  }

  /**
   * XPBalance delete
   */
  export type XPBalanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XPBalance
     */
    select?: XPBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XPBalance
     */
    omit?: XPBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XPBalanceInclude<ExtArgs> | null
    /**
     * Filter which XPBalance to delete.
     */
    where: XPBalanceWhereUniqueInput
  }

  /**
   * XPBalance deleteMany
   */
  export type XPBalanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which XPBalances to delete
     */
    where?: XPBalanceWhereInput
    /**
     * Limit how many XPBalances to delete.
     */
    limit?: number
  }

  /**
   * XPBalance without action
   */
  export type XPBalanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XPBalance
     */
    select?: XPBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XPBalance
     */
    omit?: XPBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XPBalanceInclude<ExtArgs> | null
  }


  /**
   * Model XPPurchase
   */

  export type AggregateXPPurchase = {
    _count: XPPurchaseCountAggregateOutputType | null
    _avg: XPPurchaseAvgAggregateOutputType | null
    _sum: XPPurchaseSumAggregateOutputType | null
    _min: XPPurchaseMinAggregateOutputType | null
    _max: XPPurchaseMaxAggregateOutputType | null
  }

  export type XPPurchaseAvgAggregateOutputType = {
    xpSpent: number | null
    actualPrice: number | null
    satisfactionRating: number | null
    guiltLevel: number | null
  }

  export type XPPurchaseSumAggregateOutputType = {
    xpSpent: number | null
    actualPrice: number | null
    satisfactionRating: number | null
    guiltLevel: number | null
  }

  export type XPPurchaseMinAggregateOutputType = {
    id: string | null
    userId: string | null
    rewardId: string | null
    xpSpent: number | null
    actualPrice: number | null
    purchaseType: string | null
    notes: string | null
    satisfactionRating: number | null
    guiltLevel: number | null
    wasPlanned: boolean | null
    celebrationLevel: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type XPPurchaseMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    rewardId: string | null
    xpSpent: number | null
    actualPrice: number | null
    purchaseType: string | null
    notes: string | null
    satisfactionRating: number | null
    guiltLevel: number | null
    wasPlanned: boolean | null
    celebrationLevel: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type XPPurchaseCountAggregateOutputType = {
    id: number
    userId: number
    rewardId: number
    xpSpent: number
    actualPrice: number
    purchaseType: number
    notes: number
    satisfactionRating: number
    guiltLevel: number
    wasPlanned: number
    celebrationLevel: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type XPPurchaseAvgAggregateInputType = {
    xpSpent?: true
    actualPrice?: true
    satisfactionRating?: true
    guiltLevel?: true
  }

  export type XPPurchaseSumAggregateInputType = {
    xpSpent?: true
    actualPrice?: true
    satisfactionRating?: true
    guiltLevel?: true
  }

  export type XPPurchaseMinAggregateInputType = {
    id?: true
    userId?: true
    rewardId?: true
    xpSpent?: true
    actualPrice?: true
    purchaseType?: true
    notes?: true
    satisfactionRating?: true
    guiltLevel?: true
    wasPlanned?: true
    celebrationLevel?: true
    createdAt?: true
    updatedAt?: true
  }

  export type XPPurchaseMaxAggregateInputType = {
    id?: true
    userId?: true
    rewardId?: true
    xpSpent?: true
    actualPrice?: true
    purchaseType?: true
    notes?: true
    satisfactionRating?: true
    guiltLevel?: true
    wasPlanned?: true
    celebrationLevel?: true
    createdAt?: true
    updatedAt?: true
  }

  export type XPPurchaseCountAggregateInputType = {
    id?: true
    userId?: true
    rewardId?: true
    xpSpent?: true
    actualPrice?: true
    purchaseType?: true
    notes?: true
    satisfactionRating?: true
    guiltLevel?: true
    wasPlanned?: true
    celebrationLevel?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type XPPurchaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which XPPurchase to aggregate.
     */
    where?: XPPurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of XPPurchases to fetch.
     */
    orderBy?: XPPurchaseOrderByWithRelationInput | XPPurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: XPPurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` XPPurchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` XPPurchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned XPPurchases
    **/
    _count?: true | XPPurchaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: XPPurchaseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: XPPurchaseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: XPPurchaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: XPPurchaseMaxAggregateInputType
  }

  export type GetXPPurchaseAggregateType<T extends XPPurchaseAggregateArgs> = {
        [P in keyof T & keyof AggregateXPPurchase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateXPPurchase[P]>
      : GetScalarType<T[P], AggregateXPPurchase[P]>
  }




  export type XPPurchaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: XPPurchaseWhereInput
    orderBy?: XPPurchaseOrderByWithAggregationInput | XPPurchaseOrderByWithAggregationInput[]
    by: XPPurchaseScalarFieldEnum[] | XPPurchaseScalarFieldEnum
    having?: XPPurchaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: XPPurchaseCountAggregateInputType | true
    _avg?: XPPurchaseAvgAggregateInputType
    _sum?: XPPurchaseSumAggregateInputType
    _min?: XPPurchaseMinAggregateInputType
    _max?: XPPurchaseMaxAggregateInputType
  }

  export type XPPurchaseGroupByOutputType = {
    id: string
    userId: string
    rewardId: string
    xpSpent: number
    actualPrice: number
    purchaseType: string
    notes: string | null
    satisfactionRating: number | null
    guiltLevel: number | null
    wasPlanned: boolean
    celebrationLevel: string | null
    createdAt: Date
    updatedAt: Date
    _count: XPPurchaseCountAggregateOutputType | null
    _avg: XPPurchaseAvgAggregateOutputType | null
    _sum: XPPurchaseSumAggregateOutputType | null
    _min: XPPurchaseMinAggregateOutputType | null
    _max: XPPurchaseMaxAggregateOutputType | null
  }

  type GetXPPurchaseGroupByPayload<T extends XPPurchaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<XPPurchaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof XPPurchaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], XPPurchaseGroupByOutputType[P]>
            : GetScalarType<T[P], XPPurchaseGroupByOutputType[P]>
        }
      >
    >


  export type XPPurchaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    rewardId?: boolean
    xpSpent?: boolean
    actualPrice?: boolean
    purchaseType?: boolean
    notes?: boolean
    satisfactionRating?: boolean
    guiltLevel?: boolean
    wasPlanned?: boolean
    celebrationLevel?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    reward?: boolean | RewardDefinitionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["xPPurchase"]>

  export type XPPurchaseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    rewardId?: boolean
    xpSpent?: boolean
    actualPrice?: boolean
    purchaseType?: boolean
    notes?: boolean
    satisfactionRating?: boolean
    guiltLevel?: boolean
    wasPlanned?: boolean
    celebrationLevel?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    reward?: boolean | RewardDefinitionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["xPPurchase"]>

  export type XPPurchaseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    rewardId?: boolean
    xpSpent?: boolean
    actualPrice?: boolean
    purchaseType?: boolean
    notes?: boolean
    satisfactionRating?: boolean
    guiltLevel?: boolean
    wasPlanned?: boolean
    celebrationLevel?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    reward?: boolean | RewardDefinitionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["xPPurchase"]>

  export type XPPurchaseSelectScalar = {
    id?: boolean
    userId?: boolean
    rewardId?: boolean
    xpSpent?: boolean
    actualPrice?: boolean
    purchaseType?: boolean
    notes?: boolean
    satisfactionRating?: boolean
    guiltLevel?: boolean
    wasPlanned?: boolean
    celebrationLevel?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type XPPurchaseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "rewardId" | "xpSpent" | "actualPrice" | "purchaseType" | "notes" | "satisfactionRating" | "guiltLevel" | "wasPlanned" | "celebrationLevel" | "createdAt" | "updatedAt", ExtArgs["result"]["xPPurchase"]>
  export type XPPurchaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    reward?: boolean | RewardDefinitionDefaultArgs<ExtArgs>
  }
  export type XPPurchaseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    reward?: boolean | RewardDefinitionDefaultArgs<ExtArgs>
  }
  export type XPPurchaseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    reward?: boolean | RewardDefinitionDefaultArgs<ExtArgs>
  }

  export type $XPPurchasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "XPPurchase"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      reward: Prisma.$RewardDefinitionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      rewardId: string
      xpSpent: number
      actualPrice: number
      purchaseType: string
      notes: string | null
      satisfactionRating: number | null
      guiltLevel: number | null
      wasPlanned: boolean
      celebrationLevel: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["xPPurchase"]>
    composites: {}
  }

  type XPPurchaseGetPayload<S extends boolean | null | undefined | XPPurchaseDefaultArgs> = $Result.GetResult<Prisma.$XPPurchasePayload, S>

  type XPPurchaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<XPPurchaseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: XPPurchaseCountAggregateInputType | true
    }

  export interface XPPurchaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['XPPurchase'], meta: { name: 'XPPurchase' } }
    /**
     * Find zero or one XPPurchase that matches the filter.
     * @param {XPPurchaseFindUniqueArgs} args - Arguments to find a XPPurchase
     * @example
     * // Get one XPPurchase
     * const xPPurchase = await prisma.xPPurchase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends XPPurchaseFindUniqueArgs>(args: SelectSubset<T, XPPurchaseFindUniqueArgs<ExtArgs>>): Prisma__XPPurchaseClient<$Result.GetResult<Prisma.$XPPurchasePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one XPPurchase that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {XPPurchaseFindUniqueOrThrowArgs} args - Arguments to find a XPPurchase
     * @example
     * // Get one XPPurchase
     * const xPPurchase = await prisma.xPPurchase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends XPPurchaseFindUniqueOrThrowArgs>(args: SelectSubset<T, XPPurchaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__XPPurchaseClient<$Result.GetResult<Prisma.$XPPurchasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first XPPurchase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XPPurchaseFindFirstArgs} args - Arguments to find a XPPurchase
     * @example
     * // Get one XPPurchase
     * const xPPurchase = await prisma.xPPurchase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends XPPurchaseFindFirstArgs>(args?: SelectSubset<T, XPPurchaseFindFirstArgs<ExtArgs>>): Prisma__XPPurchaseClient<$Result.GetResult<Prisma.$XPPurchasePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first XPPurchase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XPPurchaseFindFirstOrThrowArgs} args - Arguments to find a XPPurchase
     * @example
     * // Get one XPPurchase
     * const xPPurchase = await prisma.xPPurchase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends XPPurchaseFindFirstOrThrowArgs>(args?: SelectSubset<T, XPPurchaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__XPPurchaseClient<$Result.GetResult<Prisma.$XPPurchasePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more XPPurchases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XPPurchaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all XPPurchases
     * const xPPurchases = await prisma.xPPurchase.findMany()
     * 
     * // Get first 10 XPPurchases
     * const xPPurchases = await prisma.xPPurchase.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const xPPurchaseWithIdOnly = await prisma.xPPurchase.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends XPPurchaseFindManyArgs>(args?: SelectSubset<T, XPPurchaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$XPPurchasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a XPPurchase.
     * @param {XPPurchaseCreateArgs} args - Arguments to create a XPPurchase.
     * @example
     * // Create one XPPurchase
     * const XPPurchase = await prisma.xPPurchase.create({
     *   data: {
     *     // ... data to create a XPPurchase
     *   }
     * })
     * 
     */
    create<T extends XPPurchaseCreateArgs>(args: SelectSubset<T, XPPurchaseCreateArgs<ExtArgs>>): Prisma__XPPurchaseClient<$Result.GetResult<Prisma.$XPPurchasePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many XPPurchases.
     * @param {XPPurchaseCreateManyArgs} args - Arguments to create many XPPurchases.
     * @example
     * // Create many XPPurchases
     * const xPPurchase = await prisma.xPPurchase.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends XPPurchaseCreateManyArgs>(args?: SelectSubset<T, XPPurchaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many XPPurchases and returns the data saved in the database.
     * @param {XPPurchaseCreateManyAndReturnArgs} args - Arguments to create many XPPurchases.
     * @example
     * // Create many XPPurchases
     * const xPPurchase = await prisma.xPPurchase.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many XPPurchases and only return the `id`
     * const xPPurchaseWithIdOnly = await prisma.xPPurchase.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends XPPurchaseCreateManyAndReturnArgs>(args?: SelectSubset<T, XPPurchaseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$XPPurchasePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a XPPurchase.
     * @param {XPPurchaseDeleteArgs} args - Arguments to delete one XPPurchase.
     * @example
     * // Delete one XPPurchase
     * const XPPurchase = await prisma.xPPurchase.delete({
     *   where: {
     *     // ... filter to delete one XPPurchase
     *   }
     * })
     * 
     */
    delete<T extends XPPurchaseDeleteArgs>(args: SelectSubset<T, XPPurchaseDeleteArgs<ExtArgs>>): Prisma__XPPurchaseClient<$Result.GetResult<Prisma.$XPPurchasePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one XPPurchase.
     * @param {XPPurchaseUpdateArgs} args - Arguments to update one XPPurchase.
     * @example
     * // Update one XPPurchase
     * const xPPurchase = await prisma.xPPurchase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends XPPurchaseUpdateArgs>(args: SelectSubset<T, XPPurchaseUpdateArgs<ExtArgs>>): Prisma__XPPurchaseClient<$Result.GetResult<Prisma.$XPPurchasePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more XPPurchases.
     * @param {XPPurchaseDeleteManyArgs} args - Arguments to filter XPPurchases to delete.
     * @example
     * // Delete a few XPPurchases
     * const { count } = await prisma.xPPurchase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends XPPurchaseDeleteManyArgs>(args?: SelectSubset<T, XPPurchaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more XPPurchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XPPurchaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many XPPurchases
     * const xPPurchase = await prisma.xPPurchase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends XPPurchaseUpdateManyArgs>(args: SelectSubset<T, XPPurchaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more XPPurchases and returns the data updated in the database.
     * @param {XPPurchaseUpdateManyAndReturnArgs} args - Arguments to update many XPPurchases.
     * @example
     * // Update many XPPurchases
     * const xPPurchase = await prisma.xPPurchase.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more XPPurchases and only return the `id`
     * const xPPurchaseWithIdOnly = await prisma.xPPurchase.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends XPPurchaseUpdateManyAndReturnArgs>(args: SelectSubset<T, XPPurchaseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$XPPurchasePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one XPPurchase.
     * @param {XPPurchaseUpsertArgs} args - Arguments to update or create a XPPurchase.
     * @example
     * // Update or create a XPPurchase
     * const xPPurchase = await prisma.xPPurchase.upsert({
     *   create: {
     *     // ... data to create a XPPurchase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the XPPurchase we want to update
     *   }
     * })
     */
    upsert<T extends XPPurchaseUpsertArgs>(args: SelectSubset<T, XPPurchaseUpsertArgs<ExtArgs>>): Prisma__XPPurchaseClient<$Result.GetResult<Prisma.$XPPurchasePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of XPPurchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XPPurchaseCountArgs} args - Arguments to filter XPPurchases to count.
     * @example
     * // Count the number of XPPurchases
     * const count = await prisma.xPPurchase.count({
     *   where: {
     *     // ... the filter for the XPPurchases we want to count
     *   }
     * })
    **/
    count<T extends XPPurchaseCountArgs>(
      args?: Subset<T, XPPurchaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], XPPurchaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a XPPurchase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XPPurchaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends XPPurchaseAggregateArgs>(args: Subset<T, XPPurchaseAggregateArgs>): Prisma.PrismaPromise<GetXPPurchaseAggregateType<T>>

    /**
     * Group by XPPurchase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XPPurchaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends XPPurchaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: XPPurchaseGroupByArgs['orderBy'] }
        : { orderBy?: XPPurchaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, XPPurchaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetXPPurchaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the XPPurchase model
   */
  readonly fields: XPPurchaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for XPPurchase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__XPPurchaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reward<T extends RewardDefinitionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RewardDefinitionDefaultArgs<ExtArgs>>): Prisma__RewardDefinitionClient<$Result.GetResult<Prisma.$RewardDefinitionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the XPPurchase model
   */
  interface XPPurchaseFieldRefs {
    readonly id: FieldRef<"XPPurchase", 'String'>
    readonly userId: FieldRef<"XPPurchase", 'String'>
    readonly rewardId: FieldRef<"XPPurchase", 'String'>
    readonly xpSpent: FieldRef<"XPPurchase", 'Int'>
    readonly actualPrice: FieldRef<"XPPurchase", 'Int'>
    readonly purchaseType: FieldRef<"XPPurchase", 'String'>
    readonly notes: FieldRef<"XPPurchase", 'String'>
    readonly satisfactionRating: FieldRef<"XPPurchase", 'Int'>
    readonly guiltLevel: FieldRef<"XPPurchase", 'Int'>
    readonly wasPlanned: FieldRef<"XPPurchase", 'Boolean'>
    readonly celebrationLevel: FieldRef<"XPPurchase", 'String'>
    readonly createdAt: FieldRef<"XPPurchase", 'DateTime'>
    readonly updatedAt: FieldRef<"XPPurchase", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * XPPurchase findUnique
   */
  export type XPPurchaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XPPurchase
     */
    select?: XPPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XPPurchase
     */
    omit?: XPPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XPPurchaseInclude<ExtArgs> | null
    /**
     * Filter, which XPPurchase to fetch.
     */
    where: XPPurchaseWhereUniqueInput
  }

  /**
   * XPPurchase findUniqueOrThrow
   */
  export type XPPurchaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XPPurchase
     */
    select?: XPPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XPPurchase
     */
    omit?: XPPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XPPurchaseInclude<ExtArgs> | null
    /**
     * Filter, which XPPurchase to fetch.
     */
    where: XPPurchaseWhereUniqueInput
  }

  /**
   * XPPurchase findFirst
   */
  export type XPPurchaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XPPurchase
     */
    select?: XPPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XPPurchase
     */
    omit?: XPPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XPPurchaseInclude<ExtArgs> | null
    /**
     * Filter, which XPPurchase to fetch.
     */
    where?: XPPurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of XPPurchases to fetch.
     */
    orderBy?: XPPurchaseOrderByWithRelationInput | XPPurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for XPPurchases.
     */
    cursor?: XPPurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` XPPurchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` XPPurchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of XPPurchases.
     */
    distinct?: XPPurchaseScalarFieldEnum | XPPurchaseScalarFieldEnum[]
  }

  /**
   * XPPurchase findFirstOrThrow
   */
  export type XPPurchaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XPPurchase
     */
    select?: XPPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XPPurchase
     */
    omit?: XPPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XPPurchaseInclude<ExtArgs> | null
    /**
     * Filter, which XPPurchase to fetch.
     */
    where?: XPPurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of XPPurchases to fetch.
     */
    orderBy?: XPPurchaseOrderByWithRelationInput | XPPurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for XPPurchases.
     */
    cursor?: XPPurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` XPPurchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` XPPurchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of XPPurchases.
     */
    distinct?: XPPurchaseScalarFieldEnum | XPPurchaseScalarFieldEnum[]
  }

  /**
   * XPPurchase findMany
   */
  export type XPPurchaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XPPurchase
     */
    select?: XPPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XPPurchase
     */
    omit?: XPPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XPPurchaseInclude<ExtArgs> | null
    /**
     * Filter, which XPPurchases to fetch.
     */
    where?: XPPurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of XPPurchases to fetch.
     */
    orderBy?: XPPurchaseOrderByWithRelationInput | XPPurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing XPPurchases.
     */
    cursor?: XPPurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` XPPurchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` XPPurchases.
     */
    skip?: number
    distinct?: XPPurchaseScalarFieldEnum | XPPurchaseScalarFieldEnum[]
  }

  /**
   * XPPurchase create
   */
  export type XPPurchaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XPPurchase
     */
    select?: XPPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XPPurchase
     */
    omit?: XPPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XPPurchaseInclude<ExtArgs> | null
    /**
     * The data needed to create a XPPurchase.
     */
    data: XOR<XPPurchaseCreateInput, XPPurchaseUncheckedCreateInput>
  }

  /**
   * XPPurchase createMany
   */
  export type XPPurchaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many XPPurchases.
     */
    data: XPPurchaseCreateManyInput | XPPurchaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * XPPurchase createManyAndReturn
   */
  export type XPPurchaseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XPPurchase
     */
    select?: XPPurchaseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the XPPurchase
     */
    omit?: XPPurchaseOmit<ExtArgs> | null
    /**
     * The data used to create many XPPurchases.
     */
    data: XPPurchaseCreateManyInput | XPPurchaseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XPPurchaseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * XPPurchase update
   */
  export type XPPurchaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XPPurchase
     */
    select?: XPPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XPPurchase
     */
    omit?: XPPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XPPurchaseInclude<ExtArgs> | null
    /**
     * The data needed to update a XPPurchase.
     */
    data: XOR<XPPurchaseUpdateInput, XPPurchaseUncheckedUpdateInput>
    /**
     * Choose, which XPPurchase to update.
     */
    where: XPPurchaseWhereUniqueInput
  }

  /**
   * XPPurchase updateMany
   */
  export type XPPurchaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update XPPurchases.
     */
    data: XOR<XPPurchaseUpdateManyMutationInput, XPPurchaseUncheckedUpdateManyInput>
    /**
     * Filter which XPPurchases to update
     */
    where?: XPPurchaseWhereInput
    /**
     * Limit how many XPPurchases to update.
     */
    limit?: number
  }

  /**
   * XPPurchase updateManyAndReturn
   */
  export type XPPurchaseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XPPurchase
     */
    select?: XPPurchaseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the XPPurchase
     */
    omit?: XPPurchaseOmit<ExtArgs> | null
    /**
     * The data used to update XPPurchases.
     */
    data: XOR<XPPurchaseUpdateManyMutationInput, XPPurchaseUncheckedUpdateManyInput>
    /**
     * Filter which XPPurchases to update
     */
    where?: XPPurchaseWhereInput
    /**
     * Limit how many XPPurchases to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XPPurchaseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * XPPurchase upsert
   */
  export type XPPurchaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XPPurchase
     */
    select?: XPPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XPPurchase
     */
    omit?: XPPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XPPurchaseInclude<ExtArgs> | null
    /**
     * The filter to search for the XPPurchase to update in case it exists.
     */
    where: XPPurchaseWhereUniqueInput
    /**
     * In case the XPPurchase found by the `where` argument doesn't exist, create a new XPPurchase with this data.
     */
    create: XOR<XPPurchaseCreateInput, XPPurchaseUncheckedCreateInput>
    /**
     * In case the XPPurchase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<XPPurchaseUpdateInput, XPPurchaseUncheckedUpdateInput>
  }

  /**
   * XPPurchase delete
   */
  export type XPPurchaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XPPurchase
     */
    select?: XPPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XPPurchase
     */
    omit?: XPPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XPPurchaseInclude<ExtArgs> | null
    /**
     * Filter which XPPurchase to delete.
     */
    where: XPPurchaseWhereUniqueInput
  }

  /**
   * XPPurchase deleteMany
   */
  export type XPPurchaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which XPPurchases to delete
     */
    where?: XPPurchaseWhereInput
    /**
     * Limit how many XPPurchases to delete.
     */
    limit?: number
  }

  /**
   * XPPurchase without action
   */
  export type XPPurchaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XPPurchase
     */
    select?: XPPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XPPurchase
     */
    omit?: XPPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XPPurchaseInclude<ExtArgs> | null
  }


  /**
   * Model XPEarningLog
   */

  export type AggregateXPEarningLog = {
    _count: XPEarningLogCountAggregateOutputType | null
    _avg: XPEarningLogAvgAggregateOutputType | null
    _sum: XPEarningLogSumAggregateOutputType | null
    _min: XPEarningLogMinAggregateOutputType | null
    _max: XPEarningLogMaxAggregateOutputType | null
  }

  export type XPEarningLogAvgAggregateOutputType = {
    baseXP: number | null
    finalXP: number | null
  }

  export type XPEarningLogSumAggregateOutputType = {
    baseXP: number | null
    finalXP: number | null
  }

  export type XPEarningLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    source: string | null
    sourceId: string | null
    baseXP: number | null
    finalXP: number | null
    createdAt: Date | null
  }

  export type XPEarningLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    source: string | null
    sourceId: string | null
    baseXP: number | null
    finalXP: number | null
    createdAt: Date | null
  }

  export type XPEarningLogCountAggregateOutputType = {
    id: number
    userId: number
    source: number
    sourceId: number
    baseXP: number
    finalXP: number
    multipliers: number
    createdAt: number
    _all: number
  }


  export type XPEarningLogAvgAggregateInputType = {
    baseXP?: true
    finalXP?: true
  }

  export type XPEarningLogSumAggregateInputType = {
    baseXP?: true
    finalXP?: true
  }

  export type XPEarningLogMinAggregateInputType = {
    id?: true
    userId?: true
    source?: true
    sourceId?: true
    baseXP?: true
    finalXP?: true
    createdAt?: true
  }

  export type XPEarningLogMaxAggregateInputType = {
    id?: true
    userId?: true
    source?: true
    sourceId?: true
    baseXP?: true
    finalXP?: true
    createdAt?: true
  }

  export type XPEarningLogCountAggregateInputType = {
    id?: true
    userId?: true
    source?: true
    sourceId?: true
    baseXP?: true
    finalXP?: true
    multipliers?: true
    createdAt?: true
    _all?: true
  }

  export type XPEarningLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which XPEarningLog to aggregate.
     */
    where?: XPEarningLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of XPEarningLogs to fetch.
     */
    orderBy?: XPEarningLogOrderByWithRelationInput | XPEarningLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: XPEarningLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` XPEarningLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` XPEarningLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned XPEarningLogs
    **/
    _count?: true | XPEarningLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: XPEarningLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: XPEarningLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: XPEarningLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: XPEarningLogMaxAggregateInputType
  }

  export type GetXPEarningLogAggregateType<T extends XPEarningLogAggregateArgs> = {
        [P in keyof T & keyof AggregateXPEarningLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateXPEarningLog[P]>
      : GetScalarType<T[P], AggregateXPEarningLog[P]>
  }




  export type XPEarningLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: XPEarningLogWhereInput
    orderBy?: XPEarningLogOrderByWithAggregationInput | XPEarningLogOrderByWithAggregationInput[]
    by: XPEarningLogScalarFieldEnum[] | XPEarningLogScalarFieldEnum
    having?: XPEarningLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: XPEarningLogCountAggregateInputType | true
    _avg?: XPEarningLogAvgAggregateInputType
    _sum?: XPEarningLogSumAggregateInputType
    _min?: XPEarningLogMinAggregateInputType
    _max?: XPEarningLogMaxAggregateInputType
  }

  export type XPEarningLogGroupByOutputType = {
    id: string
    userId: string
    source: string
    sourceId: string | null
    baseXP: number
    finalXP: number
    multipliers: JsonValue
    createdAt: Date
    _count: XPEarningLogCountAggregateOutputType | null
    _avg: XPEarningLogAvgAggregateOutputType | null
    _sum: XPEarningLogSumAggregateOutputType | null
    _min: XPEarningLogMinAggregateOutputType | null
    _max: XPEarningLogMaxAggregateOutputType | null
  }

  type GetXPEarningLogGroupByPayload<T extends XPEarningLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<XPEarningLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof XPEarningLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], XPEarningLogGroupByOutputType[P]>
            : GetScalarType<T[P], XPEarningLogGroupByOutputType[P]>
        }
      >
    >


  export type XPEarningLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    source?: boolean
    sourceId?: boolean
    baseXP?: boolean
    finalXP?: boolean
    multipliers?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["xPEarningLog"]>

  export type XPEarningLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    source?: boolean
    sourceId?: boolean
    baseXP?: boolean
    finalXP?: boolean
    multipliers?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["xPEarningLog"]>

  export type XPEarningLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    source?: boolean
    sourceId?: boolean
    baseXP?: boolean
    finalXP?: boolean
    multipliers?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["xPEarningLog"]>

  export type XPEarningLogSelectScalar = {
    id?: boolean
    userId?: boolean
    source?: boolean
    sourceId?: boolean
    baseXP?: boolean
    finalXP?: boolean
    multipliers?: boolean
    createdAt?: boolean
  }

  export type XPEarningLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "source" | "sourceId" | "baseXP" | "finalXP" | "multipliers" | "createdAt", ExtArgs["result"]["xPEarningLog"]>
  export type XPEarningLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type XPEarningLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type XPEarningLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $XPEarningLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "XPEarningLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      source: string
      sourceId: string | null
      baseXP: number
      finalXP: number
      multipliers: Prisma.JsonValue
      createdAt: Date
    }, ExtArgs["result"]["xPEarningLog"]>
    composites: {}
  }

  type XPEarningLogGetPayload<S extends boolean | null | undefined | XPEarningLogDefaultArgs> = $Result.GetResult<Prisma.$XPEarningLogPayload, S>

  type XPEarningLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<XPEarningLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: XPEarningLogCountAggregateInputType | true
    }

  export interface XPEarningLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['XPEarningLog'], meta: { name: 'XPEarningLog' } }
    /**
     * Find zero or one XPEarningLog that matches the filter.
     * @param {XPEarningLogFindUniqueArgs} args - Arguments to find a XPEarningLog
     * @example
     * // Get one XPEarningLog
     * const xPEarningLog = await prisma.xPEarningLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends XPEarningLogFindUniqueArgs>(args: SelectSubset<T, XPEarningLogFindUniqueArgs<ExtArgs>>): Prisma__XPEarningLogClient<$Result.GetResult<Prisma.$XPEarningLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one XPEarningLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {XPEarningLogFindUniqueOrThrowArgs} args - Arguments to find a XPEarningLog
     * @example
     * // Get one XPEarningLog
     * const xPEarningLog = await prisma.xPEarningLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends XPEarningLogFindUniqueOrThrowArgs>(args: SelectSubset<T, XPEarningLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__XPEarningLogClient<$Result.GetResult<Prisma.$XPEarningLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first XPEarningLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XPEarningLogFindFirstArgs} args - Arguments to find a XPEarningLog
     * @example
     * // Get one XPEarningLog
     * const xPEarningLog = await prisma.xPEarningLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends XPEarningLogFindFirstArgs>(args?: SelectSubset<T, XPEarningLogFindFirstArgs<ExtArgs>>): Prisma__XPEarningLogClient<$Result.GetResult<Prisma.$XPEarningLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first XPEarningLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XPEarningLogFindFirstOrThrowArgs} args - Arguments to find a XPEarningLog
     * @example
     * // Get one XPEarningLog
     * const xPEarningLog = await prisma.xPEarningLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends XPEarningLogFindFirstOrThrowArgs>(args?: SelectSubset<T, XPEarningLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__XPEarningLogClient<$Result.GetResult<Prisma.$XPEarningLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more XPEarningLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XPEarningLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all XPEarningLogs
     * const xPEarningLogs = await prisma.xPEarningLog.findMany()
     * 
     * // Get first 10 XPEarningLogs
     * const xPEarningLogs = await prisma.xPEarningLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const xPEarningLogWithIdOnly = await prisma.xPEarningLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends XPEarningLogFindManyArgs>(args?: SelectSubset<T, XPEarningLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$XPEarningLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a XPEarningLog.
     * @param {XPEarningLogCreateArgs} args - Arguments to create a XPEarningLog.
     * @example
     * // Create one XPEarningLog
     * const XPEarningLog = await prisma.xPEarningLog.create({
     *   data: {
     *     // ... data to create a XPEarningLog
     *   }
     * })
     * 
     */
    create<T extends XPEarningLogCreateArgs>(args: SelectSubset<T, XPEarningLogCreateArgs<ExtArgs>>): Prisma__XPEarningLogClient<$Result.GetResult<Prisma.$XPEarningLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many XPEarningLogs.
     * @param {XPEarningLogCreateManyArgs} args - Arguments to create many XPEarningLogs.
     * @example
     * // Create many XPEarningLogs
     * const xPEarningLog = await prisma.xPEarningLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends XPEarningLogCreateManyArgs>(args?: SelectSubset<T, XPEarningLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many XPEarningLogs and returns the data saved in the database.
     * @param {XPEarningLogCreateManyAndReturnArgs} args - Arguments to create many XPEarningLogs.
     * @example
     * // Create many XPEarningLogs
     * const xPEarningLog = await prisma.xPEarningLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many XPEarningLogs and only return the `id`
     * const xPEarningLogWithIdOnly = await prisma.xPEarningLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends XPEarningLogCreateManyAndReturnArgs>(args?: SelectSubset<T, XPEarningLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$XPEarningLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a XPEarningLog.
     * @param {XPEarningLogDeleteArgs} args - Arguments to delete one XPEarningLog.
     * @example
     * // Delete one XPEarningLog
     * const XPEarningLog = await prisma.xPEarningLog.delete({
     *   where: {
     *     // ... filter to delete one XPEarningLog
     *   }
     * })
     * 
     */
    delete<T extends XPEarningLogDeleteArgs>(args: SelectSubset<T, XPEarningLogDeleteArgs<ExtArgs>>): Prisma__XPEarningLogClient<$Result.GetResult<Prisma.$XPEarningLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one XPEarningLog.
     * @param {XPEarningLogUpdateArgs} args - Arguments to update one XPEarningLog.
     * @example
     * // Update one XPEarningLog
     * const xPEarningLog = await prisma.xPEarningLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends XPEarningLogUpdateArgs>(args: SelectSubset<T, XPEarningLogUpdateArgs<ExtArgs>>): Prisma__XPEarningLogClient<$Result.GetResult<Prisma.$XPEarningLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more XPEarningLogs.
     * @param {XPEarningLogDeleteManyArgs} args - Arguments to filter XPEarningLogs to delete.
     * @example
     * // Delete a few XPEarningLogs
     * const { count } = await prisma.xPEarningLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends XPEarningLogDeleteManyArgs>(args?: SelectSubset<T, XPEarningLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more XPEarningLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XPEarningLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many XPEarningLogs
     * const xPEarningLog = await prisma.xPEarningLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends XPEarningLogUpdateManyArgs>(args: SelectSubset<T, XPEarningLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more XPEarningLogs and returns the data updated in the database.
     * @param {XPEarningLogUpdateManyAndReturnArgs} args - Arguments to update many XPEarningLogs.
     * @example
     * // Update many XPEarningLogs
     * const xPEarningLog = await prisma.xPEarningLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more XPEarningLogs and only return the `id`
     * const xPEarningLogWithIdOnly = await prisma.xPEarningLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends XPEarningLogUpdateManyAndReturnArgs>(args: SelectSubset<T, XPEarningLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$XPEarningLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one XPEarningLog.
     * @param {XPEarningLogUpsertArgs} args - Arguments to update or create a XPEarningLog.
     * @example
     * // Update or create a XPEarningLog
     * const xPEarningLog = await prisma.xPEarningLog.upsert({
     *   create: {
     *     // ... data to create a XPEarningLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the XPEarningLog we want to update
     *   }
     * })
     */
    upsert<T extends XPEarningLogUpsertArgs>(args: SelectSubset<T, XPEarningLogUpsertArgs<ExtArgs>>): Prisma__XPEarningLogClient<$Result.GetResult<Prisma.$XPEarningLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of XPEarningLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XPEarningLogCountArgs} args - Arguments to filter XPEarningLogs to count.
     * @example
     * // Count the number of XPEarningLogs
     * const count = await prisma.xPEarningLog.count({
     *   where: {
     *     // ... the filter for the XPEarningLogs we want to count
     *   }
     * })
    **/
    count<T extends XPEarningLogCountArgs>(
      args?: Subset<T, XPEarningLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], XPEarningLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a XPEarningLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XPEarningLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends XPEarningLogAggregateArgs>(args: Subset<T, XPEarningLogAggregateArgs>): Prisma.PrismaPromise<GetXPEarningLogAggregateType<T>>

    /**
     * Group by XPEarningLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XPEarningLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends XPEarningLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: XPEarningLogGroupByArgs['orderBy'] }
        : { orderBy?: XPEarningLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, XPEarningLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetXPEarningLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the XPEarningLog model
   */
  readonly fields: XPEarningLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for XPEarningLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__XPEarningLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the XPEarningLog model
   */
  interface XPEarningLogFieldRefs {
    readonly id: FieldRef<"XPEarningLog", 'String'>
    readonly userId: FieldRef<"XPEarningLog", 'String'>
    readonly source: FieldRef<"XPEarningLog", 'String'>
    readonly sourceId: FieldRef<"XPEarningLog", 'String'>
    readonly baseXP: FieldRef<"XPEarningLog", 'Int'>
    readonly finalXP: FieldRef<"XPEarningLog", 'Int'>
    readonly multipliers: FieldRef<"XPEarningLog", 'Json'>
    readonly createdAt: FieldRef<"XPEarningLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * XPEarningLog findUnique
   */
  export type XPEarningLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XPEarningLog
     */
    select?: XPEarningLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XPEarningLog
     */
    omit?: XPEarningLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XPEarningLogInclude<ExtArgs> | null
    /**
     * Filter, which XPEarningLog to fetch.
     */
    where: XPEarningLogWhereUniqueInput
  }

  /**
   * XPEarningLog findUniqueOrThrow
   */
  export type XPEarningLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XPEarningLog
     */
    select?: XPEarningLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XPEarningLog
     */
    omit?: XPEarningLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XPEarningLogInclude<ExtArgs> | null
    /**
     * Filter, which XPEarningLog to fetch.
     */
    where: XPEarningLogWhereUniqueInput
  }

  /**
   * XPEarningLog findFirst
   */
  export type XPEarningLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XPEarningLog
     */
    select?: XPEarningLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XPEarningLog
     */
    omit?: XPEarningLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XPEarningLogInclude<ExtArgs> | null
    /**
     * Filter, which XPEarningLog to fetch.
     */
    where?: XPEarningLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of XPEarningLogs to fetch.
     */
    orderBy?: XPEarningLogOrderByWithRelationInput | XPEarningLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for XPEarningLogs.
     */
    cursor?: XPEarningLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` XPEarningLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` XPEarningLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of XPEarningLogs.
     */
    distinct?: XPEarningLogScalarFieldEnum | XPEarningLogScalarFieldEnum[]
  }

  /**
   * XPEarningLog findFirstOrThrow
   */
  export type XPEarningLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XPEarningLog
     */
    select?: XPEarningLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XPEarningLog
     */
    omit?: XPEarningLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XPEarningLogInclude<ExtArgs> | null
    /**
     * Filter, which XPEarningLog to fetch.
     */
    where?: XPEarningLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of XPEarningLogs to fetch.
     */
    orderBy?: XPEarningLogOrderByWithRelationInput | XPEarningLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for XPEarningLogs.
     */
    cursor?: XPEarningLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` XPEarningLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` XPEarningLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of XPEarningLogs.
     */
    distinct?: XPEarningLogScalarFieldEnum | XPEarningLogScalarFieldEnum[]
  }

  /**
   * XPEarningLog findMany
   */
  export type XPEarningLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XPEarningLog
     */
    select?: XPEarningLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XPEarningLog
     */
    omit?: XPEarningLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XPEarningLogInclude<ExtArgs> | null
    /**
     * Filter, which XPEarningLogs to fetch.
     */
    where?: XPEarningLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of XPEarningLogs to fetch.
     */
    orderBy?: XPEarningLogOrderByWithRelationInput | XPEarningLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing XPEarningLogs.
     */
    cursor?: XPEarningLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` XPEarningLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` XPEarningLogs.
     */
    skip?: number
    distinct?: XPEarningLogScalarFieldEnum | XPEarningLogScalarFieldEnum[]
  }

  /**
   * XPEarningLog create
   */
  export type XPEarningLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XPEarningLog
     */
    select?: XPEarningLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XPEarningLog
     */
    omit?: XPEarningLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XPEarningLogInclude<ExtArgs> | null
    /**
     * The data needed to create a XPEarningLog.
     */
    data: XOR<XPEarningLogCreateInput, XPEarningLogUncheckedCreateInput>
  }

  /**
   * XPEarningLog createMany
   */
  export type XPEarningLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many XPEarningLogs.
     */
    data: XPEarningLogCreateManyInput | XPEarningLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * XPEarningLog createManyAndReturn
   */
  export type XPEarningLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XPEarningLog
     */
    select?: XPEarningLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the XPEarningLog
     */
    omit?: XPEarningLogOmit<ExtArgs> | null
    /**
     * The data used to create many XPEarningLogs.
     */
    data: XPEarningLogCreateManyInput | XPEarningLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XPEarningLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * XPEarningLog update
   */
  export type XPEarningLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XPEarningLog
     */
    select?: XPEarningLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XPEarningLog
     */
    omit?: XPEarningLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XPEarningLogInclude<ExtArgs> | null
    /**
     * The data needed to update a XPEarningLog.
     */
    data: XOR<XPEarningLogUpdateInput, XPEarningLogUncheckedUpdateInput>
    /**
     * Choose, which XPEarningLog to update.
     */
    where: XPEarningLogWhereUniqueInput
  }

  /**
   * XPEarningLog updateMany
   */
  export type XPEarningLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update XPEarningLogs.
     */
    data: XOR<XPEarningLogUpdateManyMutationInput, XPEarningLogUncheckedUpdateManyInput>
    /**
     * Filter which XPEarningLogs to update
     */
    where?: XPEarningLogWhereInput
    /**
     * Limit how many XPEarningLogs to update.
     */
    limit?: number
  }

  /**
   * XPEarningLog updateManyAndReturn
   */
  export type XPEarningLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XPEarningLog
     */
    select?: XPEarningLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the XPEarningLog
     */
    omit?: XPEarningLogOmit<ExtArgs> | null
    /**
     * The data used to update XPEarningLogs.
     */
    data: XOR<XPEarningLogUpdateManyMutationInput, XPEarningLogUncheckedUpdateManyInput>
    /**
     * Filter which XPEarningLogs to update
     */
    where?: XPEarningLogWhereInput
    /**
     * Limit how many XPEarningLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XPEarningLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * XPEarningLog upsert
   */
  export type XPEarningLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XPEarningLog
     */
    select?: XPEarningLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XPEarningLog
     */
    omit?: XPEarningLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XPEarningLogInclude<ExtArgs> | null
    /**
     * The filter to search for the XPEarningLog to update in case it exists.
     */
    where: XPEarningLogWhereUniqueInput
    /**
     * In case the XPEarningLog found by the `where` argument doesn't exist, create a new XPEarningLog with this data.
     */
    create: XOR<XPEarningLogCreateInput, XPEarningLogUncheckedCreateInput>
    /**
     * In case the XPEarningLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<XPEarningLogUpdateInput, XPEarningLogUncheckedUpdateInput>
  }

  /**
   * XPEarningLog delete
   */
  export type XPEarningLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XPEarningLog
     */
    select?: XPEarningLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XPEarningLog
     */
    omit?: XPEarningLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XPEarningLogInclude<ExtArgs> | null
    /**
     * Filter which XPEarningLog to delete.
     */
    where: XPEarningLogWhereUniqueInput
  }

  /**
   * XPEarningLog deleteMany
   */
  export type XPEarningLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which XPEarningLogs to delete
     */
    where?: XPEarningLogWhereInput
    /**
     * Limit how many XPEarningLogs to delete.
     */
    limit?: number
  }

  /**
   * XPEarningLog without action
   */
  export type XPEarningLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XPEarningLog
     */
    select?: XPEarningLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XPEarningLog
     */
    omit?: XPEarningLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XPEarningLogInclude<ExtArgs> | null
  }


  /**
   * Model RewardDefinition
   */

  export type AggregateRewardDefinition = {
    _count: RewardDefinitionCountAggregateOutputType | null
    _avg: RewardDefinitionAvgAggregateOutputType | null
    _sum: RewardDefinitionSumAggregateOutputType | null
    _min: RewardDefinitionMinAggregateOutputType | null
    _max: RewardDefinitionMaxAggregateOutputType | null
  }

  export type RewardDefinitionAvgAggregateOutputType = {
    basePrice: number | null
    requiresStreak: number | null
    maxDailyUse: number | null
  }

  export type RewardDefinitionSumAggregateOutputType = {
    basePrice: number | null
    requiresStreak: number | null
    maxDailyUse: number | null
  }

  export type RewardDefinitionMinAggregateOutputType = {
    id: string | null
    category: string | null
    name: string | null
    description: string | null
    basePrice: number | null
    iconEmoji: string | null
    isActive: boolean | null
    requiresStreak: number | null
    maxDailyUse: number | null
    availabilityWindow: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RewardDefinitionMaxAggregateOutputType = {
    id: string | null
    category: string | null
    name: string | null
    description: string | null
    basePrice: number | null
    iconEmoji: string | null
    isActive: boolean | null
    requiresStreak: number | null
    maxDailyUse: number | null
    availabilityWindow: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RewardDefinitionCountAggregateOutputType = {
    id: number
    category: number
    name: number
    description: number
    basePrice: number
    iconEmoji: number
    isActive: number
    requiresStreak: number
    maxDailyUse: number
    availabilityWindow: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RewardDefinitionAvgAggregateInputType = {
    basePrice?: true
    requiresStreak?: true
    maxDailyUse?: true
  }

  export type RewardDefinitionSumAggregateInputType = {
    basePrice?: true
    requiresStreak?: true
    maxDailyUse?: true
  }

  export type RewardDefinitionMinAggregateInputType = {
    id?: true
    category?: true
    name?: true
    description?: true
    basePrice?: true
    iconEmoji?: true
    isActive?: true
    requiresStreak?: true
    maxDailyUse?: true
    availabilityWindow?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RewardDefinitionMaxAggregateInputType = {
    id?: true
    category?: true
    name?: true
    description?: true
    basePrice?: true
    iconEmoji?: true
    isActive?: true
    requiresStreak?: true
    maxDailyUse?: true
    availabilityWindow?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RewardDefinitionCountAggregateInputType = {
    id?: true
    category?: true
    name?: true
    description?: true
    basePrice?: true
    iconEmoji?: true
    isActive?: true
    requiresStreak?: true
    maxDailyUse?: true
    availabilityWindow?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RewardDefinitionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RewardDefinition to aggregate.
     */
    where?: RewardDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RewardDefinitions to fetch.
     */
    orderBy?: RewardDefinitionOrderByWithRelationInput | RewardDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RewardDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RewardDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RewardDefinitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RewardDefinitions
    **/
    _count?: true | RewardDefinitionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RewardDefinitionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RewardDefinitionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RewardDefinitionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RewardDefinitionMaxAggregateInputType
  }

  export type GetRewardDefinitionAggregateType<T extends RewardDefinitionAggregateArgs> = {
        [P in keyof T & keyof AggregateRewardDefinition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRewardDefinition[P]>
      : GetScalarType<T[P], AggregateRewardDefinition[P]>
  }




  export type RewardDefinitionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RewardDefinitionWhereInput
    orderBy?: RewardDefinitionOrderByWithAggregationInput | RewardDefinitionOrderByWithAggregationInput[]
    by: RewardDefinitionScalarFieldEnum[] | RewardDefinitionScalarFieldEnum
    having?: RewardDefinitionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RewardDefinitionCountAggregateInputType | true
    _avg?: RewardDefinitionAvgAggregateInputType
    _sum?: RewardDefinitionSumAggregateInputType
    _min?: RewardDefinitionMinAggregateInputType
    _max?: RewardDefinitionMaxAggregateInputType
  }

  export type RewardDefinitionGroupByOutputType = {
    id: string
    category: string
    name: string
    description: string
    basePrice: number
    iconEmoji: string
    isActive: boolean
    requiresStreak: number | null
    maxDailyUse: number
    availabilityWindow: string | null
    createdAt: Date
    updatedAt: Date
    _count: RewardDefinitionCountAggregateOutputType | null
    _avg: RewardDefinitionAvgAggregateOutputType | null
    _sum: RewardDefinitionSumAggregateOutputType | null
    _min: RewardDefinitionMinAggregateOutputType | null
    _max: RewardDefinitionMaxAggregateOutputType | null
  }

  type GetRewardDefinitionGroupByPayload<T extends RewardDefinitionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RewardDefinitionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RewardDefinitionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RewardDefinitionGroupByOutputType[P]>
            : GetScalarType<T[P], RewardDefinitionGroupByOutputType[P]>
        }
      >
    >


  export type RewardDefinitionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    name?: boolean
    description?: boolean
    basePrice?: boolean
    iconEmoji?: boolean
    isActive?: boolean
    requiresStreak?: boolean
    maxDailyUse?: boolean
    availabilityWindow?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    purchases?: boolean | RewardDefinition$purchasesArgs<ExtArgs>
    _count?: boolean | RewardDefinitionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rewardDefinition"]>

  export type RewardDefinitionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    name?: boolean
    description?: boolean
    basePrice?: boolean
    iconEmoji?: boolean
    isActive?: boolean
    requiresStreak?: boolean
    maxDailyUse?: boolean
    availabilityWindow?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["rewardDefinition"]>

  export type RewardDefinitionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    name?: boolean
    description?: boolean
    basePrice?: boolean
    iconEmoji?: boolean
    isActive?: boolean
    requiresStreak?: boolean
    maxDailyUse?: boolean
    availabilityWindow?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["rewardDefinition"]>

  export type RewardDefinitionSelectScalar = {
    id?: boolean
    category?: boolean
    name?: boolean
    description?: boolean
    basePrice?: boolean
    iconEmoji?: boolean
    isActive?: boolean
    requiresStreak?: boolean
    maxDailyUse?: boolean
    availabilityWindow?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RewardDefinitionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "category" | "name" | "description" | "basePrice" | "iconEmoji" | "isActive" | "requiresStreak" | "maxDailyUse" | "availabilityWindow" | "createdAt" | "updatedAt", ExtArgs["result"]["rewardDefinition"]>
  export type RewardDefinitionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchases?: boolean | RewardDefinition$purchasesArgs<ExtArgs>
    _count?: boolean | RewardDefinitionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RewardDefinitionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RewardDefinitionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RewardDefinitionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RewardDefinition"
    objects: {
      purchases: Prisma.$XPPurchasePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      category: string
      name: string
      description: string
      basePrice: number
      iconEmoji: string
      isActive: boolean
      requiresStreak: number | null
      maxDailyUse: number
      availabilityWindow: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["rewardDefinition"]>
    composites: {}
  }

  type RewardDefinitionGetPayload<S extends boolean | null | undefined | RewardDefinitionDefaultArgs> = $Result.GetResult<Prisma.$RewardDefinitionPayload, S>

  type RewardDefinitionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RewardDefinitionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RewardDefinitionCountAggregateInputType | true
    }

  export interface RewardDefinitionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RewardDefinition'], meta: { name: 'RewardDefinition' } }
    /**
     * Find zero or one RewardDefinition that matches the filter.
     * @param {RewardDefinitionFindUniqueArgs} args - Arguments to find a RewardDefinition
     * @example
     * // Get one RewardDefinition
     * const rewardDefinition = await prisma.rewardDefinition.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RewardDefinitionFindUniqueArgs>(args: SelectSubset<T, RewardDefinitionFindUniqueArgs<ExtArgs>>): Prisma__RewardDefinitionClient<$Result.GetResult<Prisma.$RewardDefinitionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RewardDefinition that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RewardDefinitionFindUniqueOrThrowArgs} args - Arguments to find a RewardDefinition
     * @example
     * // Get one RewardDefinition
     * const rewardDefinition = await prisma.rewardDefinition.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RewardDefinitionFindUniqueOrThrowArgs>(args: SelectSubset<T, RewardDefinitionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RewardDefinitionClient<$Result.GetResult<Prisma.$RewardDefinitionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RewardDefinition that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardDefinitionFindFirstArgs} args - Arguments to find a RewardDefinition
     * @example
     * // Get one RewardDefinition
     * const rewardDefinition = await prisma.rewardDefinition.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RewardDefinitionFindFirstArgs>(args?: SelectSubset<T, RewardDefinitionFindFirstArgs<ExtArgs>>): Prisma__RewardDefinitionClient<$Result.GetResult<Prisma.$RewardDefinitionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RewardDefinition that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardDefinitionFindFirstOrThrowArgs} args - Arguments to find a RewardDefinition
     * @example
     * // Get one RewardDefinition
     * const rewardDefinition = await prisma.rewardDefinition.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RewardDefinitionFindFirstOrThrowArgs>(args?: SelectSubset<T, RewardDefinitionFindFirstOrThrowArgs<ExtArgs>>): Prisma__RewardDefinitionClient<$Result.GetResult<Prisma.$RewardDefinitionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RewardDefinitions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardDefinitionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RewardDefinitions
     * const rewardDefinitions = await prisma.rewardDefinition.findMany()
     * 
     * // Get first 10 RewardDefinitions
     * const rewardDefinitions = await prisma.rewardDefinition.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rewardDefinitionWithIdOnly = await prisma.rewardDefinition.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RewardDefinitionFindManyArgs>(args?: SelectSubset<T, RewardDefinitionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RewardDefinitionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RewardDefinition.
     * @param {RewardDefinitionCreateArgs} args - Arguments to create a RewardDefinition.
     * @example
     * // Create one RewardDefinition
     * const RewardDefinition = await prisma.rewardDefinition.create({
     *   data: {
     *     // ... data to create a RewardDefinition
     *   }
     * })
     * 
     */
    create<T extends RewardDefinitionCreateArgs>(args: SelectSubset<T, RewardDefinitionCreateArgs<ExtArgs>>): Prisma__RewardDefinitionClient<$Result.GetResult<Prisma.$RewardDefinitionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RewardDefinitions.
     * @param {RewardDefinitionCreateManyArgs} args - Arguments to create many RewardDefinitions.
     * @example
     * // Create many RewardDefinitions
     * const rewardDefinition = await prisma.rewardDefinition.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RewardDefinitionCreateManyArgs>(args?: SelectSubset<T, RewardDefinitionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RewardDefinitions and returns the data saved in the database.
     * @param {RewardDefinitionCreateManyAndReturnArgs} args - Arguments to create many RewardDefinitions.
     * @example
     * // Create many RewardDefinitions
     * const rewardDefinition = await prisma.rewardDefinition.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RewardDefinitions and only return the `id`
     * const rewardDefinitionWithIdOnly = await prisma.rewardDefinition.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RewardDefinitionCreateManyAndReturnArgs>(args?: SelectSubset<T, RewardDefinitionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RewardDefinitionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RewardDefinition.
     * @param {RewardDefinitionDeleteArgs} args - Arguments to delete one RewardDefinition.
     * @example
     * // Delete one RewardDefinition
     * const RewardDefinition = await prisma.rewardDefinition.delete({
     *   where: {
     *     // ... filter to delete one RewardDefinition
     *   }
     * })
     * 
     */
    delete<T extends RewardDefinitionDeleteArgs>(args: SelectSubset<T, RewardDefinitionDeleteArgs<ExtArgs>>): Prisma__RewardDefinitionClient<$Result.GetResult<Prisma.$RewardDefinitionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RewardDefinition.
     * @param {RewardDefinitionUpdateArgs} args - Arguments to update one RewardDefinition.
     * @example
     * // Update one RewardDefinition
     * const rewardDefinition = await prisma.rewardDefinition.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RewardDefinitionUpdateArgs>(args: SelectSubset<T, RewardDefinitionUpdateArgs<ExtArgs>>): Prisma__RewardDefinitionClient<$Result.GetResult<Prisma.$RewardDefinitionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RewardDefinitions.
     * @param {RewardDefinitionDeleteManyArgs} args - Arguments to filter RewardDefinitions to delete.
     * @example
     * // Delete a few RewardDefinitions
     * const { count } = await prisma.rewardDefinition.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RewardDefinitionDeleteManyArgs>(args?: SelectSubset<T, RewardDefinitionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RewardDefinitions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardDefinitionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RewardDefinitions
     * const rewardDefinition = await prisma.rewardDefinition.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RewardDefinitionUpdateManyArgs>(args: SelectSubset<T, RewardDefinitionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RewardDefinitions and returns the data updated in the database.
     * @param {RewardDefinitionUpdateManyAndReturnArgs} args - Arguments to update many RewardDefinitions.
     * @example
     * // Update many RewardDefinitions
     * const rewardDefinition = await prisma.rewardDefinition.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RewardDefinitions and only return the `id`
     * const rewardDefinitionWithIdOnly = await prisma.rewardDefinition.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RewardDefinitionUpdateManyAndReturnArgs>(args: SelectSubset<T, RewardDefinitionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RewardDefinitionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RewardDefinition.
     * @param {RewardDefinitionUpsertArgs} args - Arguments to update or create a RewardDefinition.
     * @example
     * // Update or create a RewardDefinition
     * const rewardDefinition = await prisma.rewardDefinition.upsert({
     *   create: {
     *     // ... data to create a RewardDefinition
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RewardDefinition we want to update
     *   }
     * })
     */
    upsert<T extends RewardDefinitionUpsertArgs>(args: SelectSubset<T, RewardDefinitionUpsertArgs<ExtArgs>>): Prisma__RewardDefinitionClient<$Result.GetResult<Prisma.$RewardDefinitionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RewardDefinitions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardDefinitionCountArgs} args - Arguments to filter RewardDefinitions to count.
     * @example
     * // Count the number of RewardDefinitions
     * const count = await prisma.rewardDefinition.count({
     *   where: {
     *     // ... the filter for the RewardDefinitions we want to count
     *   }
     * })
    **/
    count<T extends RewardDefinitionCountArgs>(
      args?: Subset<T, RewardDefinitionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RewardDefinitionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RewardDefinition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardDefinitionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RewardDefinitionAggregateArgs>(args: Subset<T, RewardDefinitionAggregateArgs>): Prisma.PrismaPromise<GetRewardDefinitionAggregateType<T>>

    /**
     * Group by RewardDefinition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardDefinitionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RewardDefinitionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RewardDefinitionGroupByArgs['orderBy'] }
        : { orderBy?: RewardDefinitionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RewardDefinitionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRewardDefinitionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RewardDefinition model
   */
  readonly fields: RewardDefinitionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RewardDefinition.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RewardDefinitionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    purchases<T extends RewardDefinition$purchasesArgs<ExtArgs> = {}>(args?: Subset<T, RewardDefinition$purchasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$XPPurchasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RewardDefinition model
   */
  interface RewardDefinitionFieldRefs {
    readonly id: FieldRef<"RewardDefinition", 'String'>
    readonly category: FieldRef<"RewardDefinition", 'String'>
    readonly name: FieldRef<"RewardDefinition", 'String'>
    readonly description: FieldRef<"RewardDefinition", 'String'>
    readonly basePrice: FieldRef<"RewardDefinition", 'Int'>
    readonly iconEmoji: FieldRef<"RewardDefinition", 'String'>
    readonly isActive: FieldRef<"RewardDefinition", 'Boolean'>
    readonly requiresStreak: FieldRef<"RewardDefinition", 'Int'>
    readonly maxDailyUse: FieldRef<"RewardDefinition", 'Int'>
    readonly availabilityWindow: FieldRef<"RewardDefinition", 'String'>
    readonly createdAt: FieldRef<"RewardDefinition", 'DateTime'>
    readonly updatedAt: FieldRef<"RewardDefinition", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RewardDefinition findUnique
   */
  export type RewardDefinitionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardDefinition
     */
    select?: RewardDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardDefinition
     */
    omit?: RewardDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which RewardDefinition to fetch.
     */
    where: RewardDefinitionWhereUniqueInput
  }

  /**
   * RewardDefinition findUniqueOrThrow
   */
  export type RewardDefinitionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardDefinition
     */
    select?: RewardDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardDefinition
     */
    omit?: RewardDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which RewardDefinition to fetch.
     */
    where: RewardDefinitionWhereUniqueInput
  }

  /**
   * RewardDefinition findFirst
   */
  export type RewardDefinitionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardDefinition
     */
    select?: RewardDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardDefinition
     */
    omit?: RewardDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which RewardDefinition to fetch.
     */
    where?: RewardDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RewardDefinitions to fetch.
     */
    orderBy?: RewardDefinitionOrderByWithRelationInput | RewardDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RewardDefinitions.
     */
    cursor?: RewardDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RewardDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RewardDefinitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RewardDefinitions.
     */
    distinct?: RewardDefinitionScalarFieldEnum | RewardDefinitionScalarFieldEnum[]
  }

  /**
   * RewardDefinition findFirstOrThrow
   */
  export type RewardDefinitionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardDefinition
     */
    select?: RewardDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardDefinition
     */
    omit?: RewardDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which RewardDefinition to fetch.
     */
    where?: RewardDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RewardDefinitions to fetch.
     */
    orderBy?: RewardDefinitionOrderByWithRelationInput | RewardDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RewardDefinitions.
     */
    cursor?: RewardDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RewardDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RewardDefinitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RewardDefinitions.
     */
    distinct?: RewardDefinitionScalarFieldEnum | RewardDefinitionScalarFieldEnum[]
  }

  /**
   * RewardDefinition findMany
   */
  export type RewardDefinitionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardDefinition
     */
    select?: RewardDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardDefinition
     */
    omit?: RewardDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which RewardDefinitions to fetch.
     */
    where?: RewardDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RewardDefinitions to fetch.
     */
    orderBy?: RewardDefinitionOrderByWithRelationInput | RewardDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RewardDefinitions.
     */
    cursor?: RewardDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RewardDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RewardDefinitions.
     */
    skip?: number
    distinct?: RewardDefinitionScalarFieldEnum | RewardDefinitionScalarFieldEnum[]
  }

  /**
   * RewardDefinition create
   */
  export type RewardDefinitionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardDefinition
     */
    select?: RewardDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardDefinition
     */
    omit?: RewardDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardDefinitionInclude<ExtArgs> | null
    /**
     * The data needed to create a RewardDefinition.
     */
    data: XOR<RewardDefinitionCreateInput, RewardDefinitionUncheckedCreateInput>
  }

  /**
   * RewardDefinition createMany
   */
  export type RewardDefinitionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RewardDefinitions.
     */
    data: RewardDefinitionCreateManyInput | RewardDefinitionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RewardDefinition createManyAndReturn
   */
  export type RewardDefinitionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardDefinition
     */
    select?: RewardDefinitionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RewardDefinition
     */
    omit?: RewardDefinitionOmit<ExtArgs> | null
    /**
     * The data used to create many RewardDefinitions.
     */
    data: RewardDefinitionCreateManyInput | RewardDefinitionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RewardDefinition update
   */
  export type RewardDefinitionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardDefinition
     */
    select?: RewardDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardDefinition
     */
    omit?: RewardDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardDefinitionInclude<ExtArgs> | null
    /**
     * The data needed to update a RewardDefinition.
     */
    data: XOR<RewardDefinitionUpdateInput, RewardDefinitionUncheckedUpdateInput>
    /**
     * Choose, which RewardDefinition to update.
     */
    where: RewardDefinitionWhereUniqueInput
  }

  /**
   * RewardDefinition updateMany
   */
  export type RewardDefinitionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RewardDefinitions.
     */
    data: XOR<RewardDefinitionUpdateManyMutationInput, RewardDefinitionUncheckedUpdateManyInput>
    /**
     * Filter which RewardDefinitions to update
     */
    where?: RewardDefinitionWhereInput
    /**
     * Limit how many RewardDefinitions to update.
     */
    limit?: number
  }

  /**
   * RewardDefinition updateManyAndReturn
   */
  export type RewardDefinitionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardDefinition
     */
    select?: RewardDefinitionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RewardDefinition
     */
    omit?: RewardDefinitionOmit<ExtArgs> | null
    /**
     * The data used to update RewardDefinitions.
     */
    data: XOR<RewardDefinitionUpdateManyMutationInput, RewardDefinitionUncheckedUpdateManyInput>
    /**
     * Filter which RewardDefinitions to update
     */
    where?: RewardDefinitionWhereInput
    /**
     * Limit how many RewardDefinitions to update.
     */
    limit?: number
  }

  /**
   * RewardDefinition upsert
   */
  export type RewardDefinitionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardDefinition
     */
    select?: RewardDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardDefinition
     */
    omit?: RewardDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardDefinitionInclude<ExtArgs> | null
    /**
     * The filter to search for the RewardDefinition to update in case it exists.
     */
    where: RewardDefinitionWhereUniqueInput
    /**
     * In case the RewardDefinition found by the `where` argument doesn't exist, create a new RewardDefinition with this data.
     */
    create: XOR<RewardDefinitionCreateInput, RewardDefinitionUncheckedCreateInput>
    /**
     * In case the RewardDefinition was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RewardDefinitionUpdateInput, RewardDefinitionUncheckedUpdateInput>
  }

  /**
   * RewardDefinition delete
   */
  export type RewardDefinitionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardDefinition
     */
    select?: RewardDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardDefinition
     */
    omit?: RewardDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardDefinitionInclude<ExtArgs> | null
    /**
     * Filter which RewardDefinition to delete.
     */
    where: RewardDefinitionWhereUniqueInput
  }

  /**
   * RewardDefinition deleteMany
   */
  export type RewardDefinitionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RewardDefinitions to delete
     */
    where?: RewardDefinitionWhereInput
    /**
     * Limit how many RewardDefinitions to delete.
     */
    limit?: number
  }

  /**
   * RewardDefinition.purchases
   */
  export type RewardDefinition$purchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XPPurchase
     */
    select?: XPPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XPPurchase
     */
    omit?: XPPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XPPurchaseInclude<ExtArgs> | null
    where?: XPPurchaseWhereInput
    orderBy?: XPPurchaseOrderByWithRelationInput | XPPurchaseOrderByWithRelationInput[]
    cursor?: XPPurchaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: XPPurchaseScalarFieldEnum | XPPurchaseScalarFieldEnum[]
  }

  /**
   * RewardDefinition without action
   */
  export type RewardDefinitionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardDefinition
     */
    select?: RewardDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardDefinition
     */
    omit?: RewardDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardDefinitionInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    supabaseId: 'supabaseId',
    email: 'email',
    displayName: 'displayName',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const LightWorkTaskScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    description: 'description',
    priority: 'priority',
    completed: 'completed',
    originalDate: 'originalDate',
    currentDate: 'currentDate',
    estimatedDuration: 'estimatedDuration',
    rollovers: 'rollovers',
    tags: 'tags',
    category: 'category',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    completedAt: 'completedAt',
    startedAt: 'startedAt',
    actualDurationMin: 'actualDurationMin',
    timeEstimate: 'timeEstimate',
    aiAnalyzed: 'aiAnalyzed',
    aiReasoning: 'aiReasoning',
    analyzedAt: 'analyzedAt',
    xpReward: 'xpReward',
    complexity: 'complexity',
    confidence: 'confidence',
    contextualBonus: 'contextualBonus',
    difficulty: 'difficulty',
    learningValue: 'learningValue',
    priorityRank: 'priorityRank',
    strategicImportance: 'strategicImportance',
    timeAccuracy: 'timeAccuracy'
  };

  export type LightWorkTaskScalarFieldEnum = (typeof LightWorkTaskScalarFieldEnum)[keyof typeof LightWorkTaskScalarFieldEnum]


  export const LightWorkSubtaskScalarFieldEnum: {
    id: 'id',
    taskId: 'taskId',
    title: 'title',
    text: 'text',
    completed: 'completed',
    priority: 'priority',
    dueDate: 'dueDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    completedAt: 'completedAt',
    startedAt: 'startedAt',
    actualDurationMin: 'actualDurationMin',
    timeAccuracy: 'timeAccuracy',
    aiAnalyzed: 'aiAnalyzed',
    aiReasoning: 'aiReasoning',
    analyzedAt: 'analyzedAt',
    xpReward: 'xpReward',
    complexity: 'complexity',
    confidence: 'confidence',
    contextualBonus: 'contextualBonus',
    difficulty: 'difficulty',
    learningValue: 'learningValue',
    priorityRank: 'priorityRank',
    strategicImportance: 'strategicImportance'
  };

  export type LightWorkSubtaskScalarFieldEnum = (typeof LightWorkSubtaskScalarFieldEnum)[keyof typeof LightWorkSubtaskScalarFieldEnum]


  export const DeepWorkTaskScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    description: 'description',
    priority: 'priority',
    completed: 'completed',
    originalDate: 'originalDate',
    currentDate: 'currentDate',
    estimatedDuration: 'estimatedDuration',
    focusBlocks: 'focusBlocks',
    breakDuration: 'breakDuration',
    interruptionMode: 'interruptionMode',
    rollovers: 'rollovers',
    tags: 'tags',
    category: 'category',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    completedAt: 'completedAt',
    startedAt: 'startedAt',
    actualDurationMin: 'actualDurationMin',
    timeEstimate: 'timeEstimate',
    aiAnalyzed: 'aiAnalyzed',
    aiReasoning: 'aiReasoning',
    analyzedAt: 'analyzedAt',
    xpReward: 'xpReward',
    complexity: 'complexity',
    confidence: 'confidence',
    contextualBonus: 'contextualBonus',
    difficulty: 'difficulty',
    learningValue: 'learningValue',
    priorityRank: 'priorityRank',
    strategicImportance: 'strategicImportance',
    timeAccuracy: 'timeAccuracy'
  };

  export type DeepWorkTaskScalarFieldEnum = (typeof DeepWorkTaskScalarFieldEnum)[keyof typeof DeepWorkTaskScalarFieldEnum]


  export const DeepWorkSubtaskScalarFieldEnum: {
    id: 'id',
    taskId: 'taskId',
    title: 'title',
    text: 'text',
    completed: 'completed',
    priority: 'priority',
    dueDate: 'dueDate',
    requiresFocus: 'requiresFocus',
    complexityLevel: 'complexityLevel',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    completedAt: 'completedAt',
    startedAt: 'startedAt',
    actualDurationMin: 'actualDurationMin',
    timeAccuracy: 'timeAccuracy',
    aiAnalyzed: 'aiAnalyzed',
    aiReasoning: 'aiReasoning',
    analyzedAt: 'analyzedAt',
    xpReward: 'xpReward',
    complexity: 'complexity',
    confidence: 'confidence',
    contextualBonus: 'contextualBonus',
    difficulty: 'difficulty',
    learningValue: 'learningValue',
    priorityRank: 'priorityRank',
    strategicImportance: 'strategicImportance'
  };

  export type DeepWorkSubtaskScalarFieldEnum = (typeof DeepWorkSubtaskScalarFieldEnum)[keyof typeof DeepWorkSubtaskScalarFieldEnum]


  export const AutomationTaskScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    description: 'description',
    category: 'category',
    priority: 'priority',
    status: 'status',
    prompt: 'prompt',
    allowedTools: 'allowedTools',
    estimatedTokens: 'estimatedTokens',
    actualTokens: 'actualTokens',
    executionTimeMs: 'executionTimeMs',
    result: 'result',
    error: 'error',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    startedAt: 'startedAt',
    completedAt: 'completedAt'
  };

  export type AutomationTaskScalarFieldEnum = (typeof AutomationTaskScalarFieldEnum)[keyof typeof AutomationTaskScalarFieldEnum]


  export const DailyHabitsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    date: 'date',
    screenTimeMinutes: 'screenTimeMinutes',
    bullshitContentMinutes: 'bullshitContentMinutes',
    noWeed: 'noWeed',
    noScrolling: 'noScrolling',
    deepWorkHours: 'deepWorkHours',
    lightWorkHours: 'lightWorkHours',
    habitsData: 'habitsData',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DailyHabitsScalarFieldEnum = (typeof DailyHabitsScalarFieldEnum)[keyof typeof DailyHabitsScalarFieldEnum]


  export const DailyHealthScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    date: 'date',
    healthChecklist: 'healthChecklist',
    meals: 'meals',
    macros: 'macros',
    waterIntakeMl: 'waterIntakeMl',
    milkIntakeMl: 'milkIntakeMl',
    sleepHours: 'sleepHours',
    energyLevel: 'energyLevel',
    moodLevel: 'moodLevel',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DailyHealthScalarFieldEnum = (typeof DailyHealthScalarFieldEnum)[keyof typeof DailyHealthScalarFieldEnum]


  export const DailyWorkoutScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    date: 'date',
    exercises: 'exercises',
    totalExercises: 'totalExercises',
    completedExercises: 'completedExercises',
    completionPercentage: 'completionPercentage',
    durationMinutes: 'durationMinutes',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DailyWorkoutScalarFieldEnum = (typeof DailyWorkoutScalarFieldEnum)[keyof typeof DailyWorkoutScalarFieldEnum]


  export const DailyRoutineScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    date: 'date',
    routineType: 'routineType',
    items: 'items',
    completedCount: 'completedCount',
    totalCount: 'totalCount',
    completionPercentage: 'completionPercentage',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DailyRoutineScalarFieldEnum = (typeof DailyRoutineScalarFieldEnum)[keyof typeof DailyRoutineScalarFieldEnum]


  export const DailyReflectionsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    date: 'date',
    wentWell: 'wentWell',
    evenBetterIf: 'evenBetterIf',
    analysis: 'analysis',
    patterns: 'patterns',
    changes: 'changes',
    overallRating: 'overallRating',
    keyLearnings: 'keyLearnings',
    tomorrowFocus: 'tomorrowFocus',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DailyReflectionsScalarFieldEnum = (typeof DailyReflectionsScalarFieldEnum)[keyof typeof DailyReflectionsScalarFieldEnum]


  export const TimeBlockScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    date: 'date',
    startTime: 'startTime',
    endTime: 'endTime',
    title: 'title',
    description: 'description',
    category: 'category',
    completed: 'completed',
    actualStart: 'actualStart',
    actualEnd: 'actualEnd',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TimeBlockScalarFieldEnum = (typeof TimeBlockScalarFieldEnum)[keyof typeof TimeBlockScalarFieldEnum]


  export const PersonalContextScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    currentGoals: 'currentGoals',
    skillPriorities: 'skillPriorities',
    revenueTargets: 'revenueTargets',
    timeConstraints: 'timeConstraints',
    currentProjects: 'currentProjects',
    hatedTasks: 'hatedTasks',
    valuedTasks: 'valuedTasks',
    learningObjectives: 'learningObjectives',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PersonalContextScalarFieldEnum = (typeof PersonalContextScalarFieldEnum)[keyof typeof PersonalContextScalarFieldEnum]


  export const UserProgressScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    currentLevel: 'currentLevel',
    totalXP: 'totalXP',
    dailyXP: 'dailyXP',
    currentStreak: 'currentStreak',
    bestStreak: 'bestStreak',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserProgressScalarFieldEnum = (typeof UserProgressScalarFieldEnum)[keyof typeof UserProgressScalarFieldEnum]


  export const AchievementScalarFieldEnum: {
    id: 'id',
    progressId: 'progressId',
    name: 'name',
    description: 'description',
    badge: 'badge',
    category: 'category',
    requirement: 'requirement',
    unlocked: 'unlocked',
    progress: 'progress',
    maxProgress: 'maxProgress',
    unlockedAt: 'unlockedAt',
    createdAt: 'createdAt'
  };

  export type AchievementScalarFieldEnum = (typeof AchievementScalarFieldEnum)[keyof typeof AchievementScalarFieldEnum]


  export const DailyStatsScalarFieldEnum: {
    id: 'id',
    progressId: 'progressId',
    date: 'date',
    totalXP: 'totalXP',
    activitiesCompleted: 'activitiesCompleted',
    streakCount: 'streakCount',
    level: 'level',
    routineXP: 'routineXP',
    taskXP: 'taskXP',
    healthXP: 'healthXP',
    focusXP: 'focusXP',
    habitXP: 'habitXP',
    createdAt: 'createdAt'
  };

  export type DailyStatsScalarFieldEnum = (typeof DailyStatsScalarFieldEnum)[keyof typeof DailyStatsScalarFieldEnum]


  export const XPBalanceScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    currentXP: 'currentXP',
    totalEarned: 'totalEarned',
    totalSpent: 'totalSpent',
    reserveXP: 'reserveXP',
    pendingLoans: 'pendingLoans',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type XPBalanceScalarFieldEnum = (typeof XPBalanceScalarFieldEnum)[keyof typeof XPBalanceScalarFieldEnum]


  export const XPPurchaseScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    rewardId: 'rewardId',
    xpSpent: 'xpSpent',
    actualPrice: 'actualPrice',
    purchaseType: 'purchaseType',
    notes: 'notes',
    satisfactionRating: 'satisfactionRating',
    guiltLevel: 'guiltLevel',
    wasPlanned: 'wasPlanned',
    celebrationLevel: 'celebrationLevel',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type XPPurchaseScalarFieldEnum = (typeof XPPurchaseScalarFieldEnum)[keyof typeof XPPurchaseScalarFieldEnum]


  export const XPEarningLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    source: 'source',
    sourceId: 'sourceId',
    baseXP: 'baseXP',
    finalXP: 'finalXP',
    multipliers: 'multipliers',
    createdAt: 'createdAt'
  };

  export type XPEarningLogScalarFieldEnum = (typeof XPEarningLogScalarFieldEnum)[keyof typeof XPEarningLogScalarFieldEnum]


  export const RewardDefinitionScalarFieldEnum: {
    id: 'id',
    category: 'category',
    name: 'name',
    description: 'description',
    basePrice: 'basePrice',
    iconEmoji: 'iconEmoji',
    isActive: 'isActive',
    requiresStreak: 'requiresStreak',
    maxDailyUse: 'maxDailyUse',
    availabilityWindow: 'availabilityWindow',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RewardDefinitionScalarFieldEnum = (typeof RewardDefinitionScalarFieldEnum)[keyof typeof RewardDefinitionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Priority'
   */
  export type EnumPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Priority'>
    


  /**
   * Reference to a field of type 'Priority[]'
   */
  export type ListEnumPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Priority[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'AutomationCategory'
   */
  export type EnumAutomationCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AutomationCategory'>
    


  /**
   * Reference to a field of type 'AutomationCategory[]'
   */
  export type ListEnumAutomationCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AutomationCategory[]'>
    


  /**
   * Reference to a field of type 'AutomationStatus'
   */
  export type EnumAutomationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AutomationStatus'>
    


  /**
   * Reference to a field of type 'AutomationStatus[]'
   */
  export type ListEnumAutomationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AutomationStatus[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'RoutineType'
   */
  export type EnumRoutineTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoutineType'>
    


  /**
   * Reference to a field of type 'RoutineType[]'
   */
  export type ListEnumRoutineTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoutineType[]'>
    


  /**
   * Reference to a field of type 'TimeBlockCategory'
   */
  export type EnumTimeBlockCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TimeBlockCategory'>
    


  /**
   * Reference to a field of type 'TimeBlockCategory[]'
   */
  export type ListEnumTimeBlockCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TimeBlockCategory[]'>
    


  /**
   * Reference to a field of type 'AchievementCategory'
   */
  export type EnumAchievementCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AchievementCategory'>
    


  /**
   * Reference to a field of type 'AchievementCategory[]'
   */
  export type ListEnumAchievementCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AchievementCategory[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    supabaseId?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    displayName?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lightWorkTasks?: LightWorkTaskListRelationFilter
    deepWorkTasks?: DeepWorkTaskListRelationFilter
    personalContext?: PersonalContextListRelationFilter
    automationTasks?: AutomationTaskListRelationFilter
    dailyHabits?: DailyHabitsListRelationFilter
    dailyHealth?: DailyHealthListRelationFilter
    dailyWorkout?: DailyWorkoutListRelationFilter
    dailyRoutine?: DailyRoutineListRelationFilter
    dailyReflections?: DailyReflectionsListRelationFilter
    timeBlocks?: TimeBlockListRelationFilter
    userProgress?: UserProgressListRelationFilter
    xpBalance?: XPBalanceListRelationFilter
    xpPurchases?: XPPurchaseListRelationFilter
    xpEarningLog?: XPEarningLogListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    supabaseId?: SortOrder
    email?: SortOrder
    displayName?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lightWorkTasks?: LightWorkTaskOrderByRelationAggregateInput
    deepWorkTasks?: DeepWorkTaskOrderByRelationAggregateInput
    personalContext?: PersonalContextOrderByRelationAggregateInput
    automationTasks?: AutomationTaskOrderByRelationAggregateInput
    dailyHabits?: DailyHabitsOrderByRelationAggregateInput
    dailyHealth?: DailyHealthOrderByRelationAggregateInput
    dailyWorkout?: DailyWorkoutOrderByRelationAggregateInput
    dailyRoutine?: DailyRoutineOrderByRelationAggregateInput
    dailyReflections?: DailyReflectionsOrderByRelationAggregateInput
    timeBlocks?: TimeBlockOrderByRelationAggregateInput
    userProgress?: UserProgressOrderByRelationAggregateInput
    xpBalance?: XPBalanceOrderByRelationAggregateInput
    xpPurchases?: XPPurchaseOrderByRelationAggregateInput
    xpEarningLog?: XPEarningLogOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    supabaseId?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    displayName?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lightWorkTasks?: LightWorkTaskListRelationFilter
    deepWorkTasks?: DeepWorkTaskListRelationFilter
    personalContext?: PersonalContextListRelationFilter
    automationTasks?: AutomationTaskListRelationFilter
    dailyHabits?: DailyHabitsListRelationFilter
    dailyHealth?: DailyHealthListRelationFilter
    dailyWorkout?: DailyWorkoutListRelationFilter
    dailyRoutine?: DailyRoutineListRelationFilter
    dailyReflections?: DailyReflectionsListRelationFilter
    timeBlocks?: TimeBlockListRelationFilter
    userProgress?: UserProgressListRelationFilter
    xpBalance?: XPBalanceListRelationFilter
    xpPurchases?: XPPurchaseListRelationFilter
    xpEarningLog?: XPEarningLogListRelationFilter
  }, "id" | "supabaseId" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    supabaseId?: SortOrder
    email?: SortOrder
    displayName?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    supabaseId?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    displayName?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type LightWorkTaskWhereInput = {
    AND?: LightWorkTaskWhereInput | LightWorkTaskWhereInput[]
    OR?: LightWorkTaskWhereInput[]
    NOT?: LightWorkTaskWhereInput | LightWorkTaskWhereInput[]
    id?: StringFilter<"LightWorkTask"> | string
    userId?: StringFilter<"LightWorkTask"> | string
    title?: StringFilter<"LightWorkTask"> | string
    description?: StringNullableFilter<"LightWorkTask"> | string | null
    priority?: EnumPriorityFilter<"LightWorkTask"> | $Enums.Priority
    completed?: BoolFilter<"LightWorkTask"> | boolean
    originalDate?: StringFilter<"LightWorkTask"> | string
    currentDate?: StringFilter<"LightWorkTask"> | string
    estimatedDuration?: IntNullableFilter<"LightWorkTask"> | number | null
    rollovers?: IntFilter<"LightWorkTask"> | number
    tags?: StringNullableListFilter<"LightWorkTask">
    category?: StringNullableFilter<"LightWorkTask"> | string | null
    createdAt?: DateTimeFilter<"LightWorkTask"> | Date | string
    updatedAt?: DateTimeFilter<"LightWorkTask"> | Date | string
    completedAt?: DateTimeNullableFilter<"LightWorkTask"> | Date | string | null
    startedAt?: DateTimeNullableFilter<"LightWorkTask"> | Date | string | null
    actualDurationMin?: IntNullableFilter<"LightWorkTask"> | number | null
    timeEstimate?: StringNullableFilter<"LightWorkTask"> | string | null
    aiAnalyzed?: BoolFilter<"LightWorkTask"> | boolean
    aiReasoning?: StringNullableFilter<"LightWorkTask"> | string | null
    analyzedAt?: DateTimeNullableFilter<"LightWorkTask"> | Date | string | null
    xpReward?: IntNullableFilter<"LightWorkTask"> | number | null
    complexity?: IntNullableFilter<"LightWorkTask"> | number | null
    confidence?: FloatNullableFilter<"LightWorkTask"> | number | null
    contextualBonus?: FloatNullableFilter<"LightWorkTask"> | number | null
    difficulty?: IntNullableFilter<"LightWorkTask"> | number | null
    learningValue?: IntNullableFilter<"LightWorkTask"> | number | null
    priorityRank?: IntNullableFilter<"LightWorkTask"> | number | null
    strategicImportance?: IntNullableFilter<"LightWorkTask"> | number | null
    timeAccuracy?: FloatNullableFilter<"LightWorkTask"> | number | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    subtasks?: LightWorkSubtaskListRelationFilter
  }

  export type LightWorkTaskOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    priority?: SortOrder
    completed?: SortOrder
    originalDate?: SortOrder
    currentDate?: SortOrder
    estimatedDuration?: SortOrderInput | SortOrder
    rollovers?: SortOrder
    tags?: SortOrder
    category?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    actualDurationMin?: SortOrderInput | SortOrder
    timeEstimate?: SortOrderInput | SortOrder
    aiAnalyzed?: SortOrder
    aiReasoning?: SortOrderInput | SortOrder
    analyzedAt?: SortOrderInput | SortOrder
    xpReward?: SortOrderInput | SortOrder
    complexity?: SortOrderInput | SortOrder
    confidence?: SortOrderInput | SortOrder
    contextualBonus?: SortOrderInput | SortOrder
    difficulty?: SortOrderInput | SortOrder
    learningValue?: SortOrderInput | SortOrder
    priorityRank?: SortOrderInput | SortOrder
    strategicImportance?: SortOrderInput | SortOrder
    timeAccuracy?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    subtasks?: LightWorkSubtaskOrderByRelationAggregateInput
  }

  export type LightWorkTaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LightWorkTaskWhereInput | LightWorkTaskWhereInput[]
    OR?: LightWorkTaskWhereInput[]
    NOT?: LightWorkTaskWhereInput | LightWorkTaskWhereInput[]
    userId?: StringFilter<"LightWorkTask"> | string
    title?: StringFilter<"LightWorkTask"> | string
    description?: StringNullableFilter<"LightWorkTask"> | string | null
    priority?: EnumPriorityFilter<"LightWorkTask"> | $Enums.Priority
    completed?: BoolFilter<"LightWorkTask"> | boolean
    originalDate?: StringFilter<"LightWorkTask"> | string
    currentDate?: StringFilter<"LightWorkTask"> | string
    estimatedDuration?: IntNullableFilter<"LightWorkTask"> | number | null
    rollovers?: IntFilter<"LightWorkTask"> | number
    tags?: StringNullableListFilter<"LightWorkTask">
    category?: StringNullableFilter<"LightWorkTask"> | string | null
    createdAt?: DateTimeFilter<"LightWorkTask"> | Date | string
    updatedAt?: DateTimeFilter<"LightWorkTask"> | Date | string
    completedAt?: DateTimeNullableFilter<"LightWorkTask"> | Date | string | null
    startedAt?: DateTimeNullableFilter<"LightWorkTask"> | Date | string | null
    actualDurationMin?: IntNullableFilter<"LightWorkTask"> | number | null
    timeEstimate?: StringNullableFilter<"LightWorkTask"> | string | null
    aiAnalyzed?: BoolFilter<"LightWorkTask"> | boolean
    aiReasoning?: StringNullableFilter<"LightWorkTask"> | string | null
    analyzedAt?: DateTimeNullableFilter<"LightWorkTask"> | Date | string | null
    xpReward?: IntNullableFilter<"LightWorkTask"> | number | null
    complexity?: IntNullableFilter<"LightWorkTask"> | number | null
    confidence?: FloatNullableFilter<"LightWorkTask"> | number | null
    contextualBonus?: FloatNullableFilter<"LightWorkTask"> | number | null
    difficulty?: IntNullableFilter<"LightWorkTask"> | number | null
    learningValue?: IntNullableFilter<"LightWorkTask"> | number | null
    priorityRank?: IntNullableFilter<"LightWorkTask"> | number | null
    strategicImportance?: IntNullableFilter<"LightWorkTask"> | number | null
    timeAccuracy?: FloatNullableFilter<"LightWorkTask"> | number | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    subtasks?: LightWorkSubtaskListRelationFilter
  }, "id">

  export type LightWorkTaskOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    priority?: SortOrder
    completed?: SortOrder
    originalDate?: SortOrder
    currentDate?: SortOrder
    estimatedDuration?: SortOrderInput | SortOrder
    rollovers?: SortOrder
    tags?: SortOrder
    category?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    actualDurationMin?: SortOrderInput | SortOrder
    timeEstimate?: SortOrderInput | SortOrder
    aiAnalyzed?: SortOrder
    aiReasoning?: SortOrderInput | SortOrder
    analyzedAt?: SortOrderInput | SortOrder
    xpReward?: SortOrderInput | SortOrder
    complexity?: SortOrderInput | SortOrder
    confidence?: SortOrderInput | SortOrder
    contextualBonus?: SortOrderInput | SortOrder
    difficulty?: SortOrderInput | SortOrder
    learningValue?: SortOrderInput | SortOrder
    priorityRank?: SortOrderInput | SortOrder
    strategicImportance?: SortOrderInput | SortOrder
    timeAccuracy?: SortOrderInput | SortOrder
    _count?: LightWorkTaskCountOrderByAggregateInput
    _avg?: LightWorkTaskAvgOrderByAggregateInput
    _max?: LightWorkTaskMaxOrderByAggregateInput
    _min?: LightWorkTaskMinOrderByAggregateInput
    _sum?: LightWorkTaskSumOrderByAggregateInput
  }

  export type LightWorkTaskScalarWhereWithAggregatesInput = {
    AND?: LightWorkTaskScalarWhereWithAggregatesInput | LightWorkTaskScalarWhereWithAggregatesInput[]
    OR?: LightWorkTaskScalarWhereWithAggregatesInput[]
    NOT?: LightWorkTaskScalarWhereWithAggregatesInput | LightWorkTaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LightWorkTask"> | string
    userId?: StringWithAggregatesFilter<"LightWorkTask"> | string
    title?: StringWithAggregatesFilter<"LightWorkTask"> | string
    description?: StringNullableWithAggregatesFilter<"LightWorkTask"> | string | null
    priority?: EnumPriorityWithAggregatesFilter<"LightWorkTask"> | $Enums.Priority
    completed?: BoolWithAggregatesFilter<"LightWorkTask"> | boolean
    originalDate?: StringWithAggregatesFilter<"LightWorkTask"> | string
    currentDate?: StringWithAggregatesFilter<"LightWorkTask"> | string
    estimatedDuration?: IntNullableWithAggregatesFilter<"LightWorkTask"> | number | null
    rollovers?: IntWithAggregatesFilter<"LightWorkTask"> | number
    tags?: StringNullableListFilter<"LightWorkTask">
    category?: StringNullableWithAggregatesFilter<"LightWorkTask"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LightWorkTask"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LightWorkTask"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"LightWorkTask"> | Date | string | null
    startedAt?: DateTimeNullableWithAggregatesFilter<"LightWorkTask"> | Date | string | null
    actualDurationMin?: IntNullableWithAggregatesFilter<"LightWorkTask"> | number | null
    timeEstimate?: StringNullableWithAggregatesFilter<"LightWorkTask"> | string | null
    aiAnalyzed?: BoolWithAggregatesFilter<"LightWorkTask"> | boolean
    aiReasoning?: StringNullableWithAggregatesFilter<"LightWorkTask"> | string | null
    analyzedAt?: DateTimeNullableWithAggregatesFilter<"LightWorkTask"> | Date | string | null
    xpReward?: IntNullableWithAggregatesFilter<"LightWorkTask"> | number | null
    complexity?: IntNullableWithAggregatesFilter<"LightWorkTask"> | number | null
    confidence?: FloatNullableWithAggregatesFilter<"LightWorkTask"> | number | null
    contextualBonus?: FloatNullableWithAggregatesFilter<"LightWorkTask"> | number | null
    difficulty?: IntNullableWithAggregatesFilter<"LightWorkTask"> | number | null
    learningValue?: IntNullableWithAggregatesFilter<"LightWorkTask"> | number | null
    priorityRank?: IntNullableWithAggregatesFilter<"LightWorkTask"> | number | null
    strategicImportance?: IntNullableWithAggregatesFilter<"LightWorkTask"> | number | null
    timeAccuracy?: FloatNullableWithAggregatesFilter<"LightWorkTask"> | number | null
  }

  export type LightWorkSubtaskWhereInput = {
    AND?: LightWorkSubtaskWhereInput | LightWorkSubtaskWhereInput[]
    OR?: LightWorkSubtaskWhereInput[]
    NOT?: LightWorkSubtaskWhereInput | LightWorkSubtaskWhereInput[]
    id?: StringFilter<"LightWorkSubtask"> | string
    taskId?: StringFilter<"LightWorkSubtask"> | string
    title?: StringFilter<"LightWorkSubtask"> | string
    text?: StringFilter<"LightWorkSubtask"> | string
    completed?: BoolFilter<"LightWorkSubtask"> | boolean
    priority?: StringNullableFilter<"LightWorkSubtask"> | string | null
    dueDate?: DateTimeNullableFilter<"LightWorkSubtask"> | Date | string | null
    createdAt?: DateTimeFilter<"LightWorkSubtask"> | Date | string
    updatedAt?: DateTimeFilter<"LightWorkSubtask"> | Date | string
    completedAt?: DateTimeNullableFilter<"LightWorkSubtask"> | Date | string | null
    startedAt?: DateTimeNullableFilter<"LightWorkSubtask"> | Date | string | null
    actualDurationMin?: IntNullableFilter<"LightWorkSubtask"> | number | null
    timeAccuracy?: FloatNullableFilter<"LightWorkSubtask"> | number | null
    aiAnalyzed?: BoolFilter<"LightWorkSubtask"> | boolean
    aiReasoning?: StringNullableFilter<"LightWorkSubtask"> | string | null
    analyzedAt?: DateTimeNullableFilter<"LightWorkSubtask"> | Date | string | null
    xpReward?: IntNullableFilter<"LightWorkSubtask"> | number | null
    complexity?: IntNullableFilter<"LightWorkSubtask"> | number | null
    confidence?: FloatNullableFilter<"LightWorkSubtask"> | number | null
    contextualBonus?: FloatNullableFilter<"LightWorkSubtask"> | number | null
    difficulty?: IntNullableFilter<"LightWorkSubtask"> | number | null
    learningValue?: IntNullableFilter<"LightWorkSubtask"> | number | null
    priorityRank?: IntNullableFilter<"LightWorkSubtask"> | number | null
    strategicImportance?: IntNullableFilter<"LightWorkSubtask"> | number | null
    task?: XOR<LightWorkTaskScalarRelationFilter, LightWorkTaskWhereInput>
  }

  export type LightWorkSubtaskOrderByWithRelationInput = {
    id?: SortOrder
    taskId?: SortOrder
    title?: SortOrder
    text?: SortOrder
    completed?: SortOrder
    priority?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    actualDurationMin?: SortOrderInput | SortOrder
    timeAccuracy?: SortOrderInput | SortOrder
    aiAnalyzed?: SortOrder
    aiReasoning?: SortOrderInput | SortOrder
    analyzedAt?: SortOrderInput | SortOrder
    xpReward?: SortOrderInput | SortOrder
    complexity?: SortOrderInput | SortOrder
    confidence?: SortOrderInput | SortOrder
    contextualBonus?: SortOrderInput | SortOrder
    difficulty?: SortOrderInput | SortOrder
    learningValue?: SortOrderInput | SortOrder
    priorityRank?: SortOrderInput | SortOrder
    strategicImportance?: SortOrderInput | SortOrder
    task?: LightWorkTaskOrderByWithRelationInput
  }

  export type LightWorkSubtaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LightWorkSubtaskWhereInput | LightWorkSubtaskWhereInput[]
    OR?: LightWorkSubtaskWhereInput[]
    NOT?: LightWorkSubtaskWhereInput | LightWorkSubtaskWhereInput[]
    taskId?: StringFilter<"LightWorkSubtask"> | string
    title?: StringFilter<"LightWorkSubtask"> | string
    text?: StringFilter<"LightWorkSubtask"> | string
    completed?: BoolFilter<"LightWorkSubtask"> | boolean
    priority?: StringNullableFilter<"LightWorkSubtask"> | string | null
    dueDate?: DateTimeNullableFilter<"LightWorkSubtask"> | Date | string | null
    createdAt?: DateTimeFilter<"LightWorkSubtask"> | Date | string
    updatedAt?: DateTimeFilter<"LightWorkSubtask"> | Date | string
    completedAt?: DateTimeNullableFilter<"LightWorkSubtask"> | Date | string | null
    startedAt?: DateTimeNullableFilter<"LightWorkSubtask"> | Date | string | null
    actualDurationMin?: IntNullableFilter<"LightWorkSubtask"> | number | null
    timeAccuracy?: FloatNullableFilter<"LightWorkSubtask"> | number | null
    aiAnalyzed?: BoolFilter<"LightWorkSubtask"> | boolean
    aiReasoning?: StringNullableFilter<"LightWorkSubtask"> | string | null
    analyzedAt?: DateTimeNullableFilter<"LightWorkSubtask"> | Date | string | null
    xpReward?: IntNullableFilter<"LightWorkSubtask"> | number | null
    complexity?: IntNullableFilter<"LightWorkSubtask"> | number | null
    confidence?: FloatNullableFilter<"LightWorkSubtask"> | number | null
    contextualBonus?: FloatNullableFilter<"LightWorkSubtask"> | number | null
    difficulty?: IntNullableFilter<"LightWorkSubtask"> | number | null
    learningValue?: IntNullableFilter<"LightWorkSubtask"> | number | null
    priorityRank?: IntNullableFilter<"LightWorkSubtask"> | number | null
    strategicImportance?: IntNullableFilter<"LightWorkSubtask"> | number | null
    task?: XOR<LightWorkTaskScalarRelationFilter, LightWorkTaskWhereInput>
  }, "id">

  export type LightWorkSubtaskOrderByWithAggregationInput = {
    id?: SortOrder
    taskId?: SortOrder
    title?: SortOrder
    text?: SortOrder
    completed?: SortOrder
    priority?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    actualDurationMin?: SortOrderInput | SortOrder
    timeAccuracy?: SortOrderInput | SortOrder
    aiAnalyzed?: SortOrder
    aiReasoning?: SortOrderInput | SortOrder
    analyzedAt?: SortOrderInput | SortOrder
    xpReward?: SortOrderInput | SortOrder
    complexity?: SortOrderInput | SortOrder
    confidence?: SortOrderInput | SortOrder
    contextualBonus?: SortOrderInput | SortOrder
    difficulty?: SortOrderInput | SortOrder
    learningValue?: SortOrderInput | SortOrder
    priorityRank?: SortOrderInput | SortOrder
    strategicImportance?: SortOrderInput | SortOrder
    _count?: LightWorkSubtaskCountOrderByAggregateInput
    _avg?: LightWorkSubtaskAvgOrderByAggregateInput
    _max?: LightWorkSubtaskMaxOrderByAggregateInput
    _min?: LightWorkSubtaskMinOrderByAggregateInput
    _sum?: LightWorkSubtaskSumOrderByAggregateInput
  }

  export type LightWorkSubtaskScalarWhereWithAggregatesInput = {
    AND?: LightWorkSubtaskScalarWhereWithAggregatesInput | LightWorkSubtaskScalarWhereWithAggregatesInput[]
    OR?: LightWorkSubtaskScalarWhereWithAggregatesInput[]
    NOT?: LightWorkSubtaskScalarWhereWithAggregatesInput | LightWorkSubtaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LightWorkSubtask"> | string
    taskId?: StringWithAggregatesFilter<"LightWorkSubtask"> | string
    title?: StringWithAggregatesFilter<"LightWorkSubtask"> | string
    text?: StringWithAggregatesFilter<"LightWorkSubtask"> | string
    completed?: BoolWithAggregatesFilter<"LightWorkSubtask"> | boolean
    priority?: StringNullableWithAggregatesFilter<"LightWorkSubtask"> | string | null
    dueDate?: DateTimeNullableWithAggregatesFilter<"LightWorkSubtask"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LightWorkSubtask"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LightWorkSubtask"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"LightWorkSubtask"> | Date | string | null
    startedAt?: DateTimeNullableWithAggregatesFilter<"LightWorkSubtask"> | Date | string | null
    actualDurationMin?: IntNullableWithAggregatesFilter<"LightWorkSubtask"> | number | null
    timeAccuracy?: FloatNullableWithAggregatesFilter<"LightWorkSubtask"> | number | null
    aiAnalyzed?: BoolWithAggregatesFilter<"LightWorkSubtask"> | boolean
    aiReasoning?: StringNullableWithAggregatesFilter<"LightWorkSubtask"> | string | null
    analyzedAt?: DateTimeNullableWithAggregatesFilter<"LightWorkSubtask"> | Date | string | null
    xpReward?: IntNullableWithAggregatesFilter<"LightWorkSubtask"> | number | null
    complexity?: IntNullableWithAggregatesFilter<"LightWorkSubtask"> | number | null
    confidence?: FloatNullableWithAggregatesFilter<"LightWorkSubtask"> | number | null
    contextualBonus?: FloatNullableWithAggregatesFilter<"LightWorkSubtask"> | number | null
    difficulty?: IntNullableWithAggregatesFilter<"LightWorkSubtask"> | number | null
    learningValue?: IntNullableWithAggregatesFilter<"LightWorkSubtask"> | number | null
    priorityRank?: IntNullableWithAggregatesFilter<"LightWorkSubtask"> | number | null
    strategicImportance?: IntNullableWithAggregatesFilter<"LightWorkSubtask"> | number | null
  }

  export type DeepWorkTaskWhereInput = {
    AND?: DeepWorkTaskWhereInput | DeepWorkTaskWhereInput[]
    OR?: DeepWorkTaskWhereInput[]
    NOT?: DeepWorkTaskWhereInput | DeepWorkTaskWhereInput[]
    id?: StringFilter<"DeepWorkTask"> | string
    userId?: StringFilter<"DeepWorkTask"> | string
    title?: StringFilter<"DeepWorkTask"> | string
    description?: StringNullableFilter<"DeepWorkTask"> | string | null
    priority?: EnumPriorityFilter<"DeepWorkTask"> | $Enums.Priority
    completed?: BoolFilter<"DeepWorkTask"> | boolean
    originalDate?: StringFilter<"DeepWorkTask"> | string
    currentDate?: StringFilter<"DeepWorkTask"> | string
    estimatedDuration?: IntNullableFilter<"DeepWorkTask"> | number | null
    focusBlocks?: IntFilter<"DeepWorkTask"> | number
    breakDuration?: IntFilter<"DeepWorkTask"> | number
    interruptionMode?: BoolFilter<"DeepWorkTask"> | boolean
    rollovers?: IntFilter<"DeepWorkTask"> | number
    tags?: StringNullableListFilter<"DeepWorkTask">
    category?: StringNullableFilter<"DeepWorkTask"> | string | null
    createdAt?: DateTimeFilter<"DeepWorkTask"> | Date | string
    updatedAt?: DateTimeFilter<"DeepWorkTask"> | Date | string
    completedAt?: DateTimeNullableFilter<"DeepWorkTask"> | Date | string | null
    startedAt?: DateTimeNullableFilter<"DeepWorkTask"> | Date | string | null
    actualDurationMin?: IntNullableFilter<"DeepWorkTask"> | number | null
    timeEstimate?: StringNullableFilter<"DeepWorkTask"> | string | null
    aiAnalyzed?: BoolFilter<"DeepWorkTask"> | boolean
    aiReasoning?: StringNullableFilter<"DeepWorkTask"> | string | null
    analyzedAt?: DateTimeNullableFilter<"DeepWorkTask"> | Date | string | null
    xpReward?: IntNullableFilter<"DeepWorkTask"> | number | null
    complexity?: IntNullableFilter<"DeepWorkTask"> | number | null
    confidence?: FloatNullableFilter<"DeepWorkTask"> | number | null
    contextualBonus?: FloatNullableFilter<"DeepWorkTask"> | number | null
    difficulty?: IntNullableFilter<"DeepWorkTask"> | number | null
    learningValue?: IntNullableFilter<"DeepWorkTask"> | number | null
    priorityRank?: IntNullableFilter<"DeepWorkTask"> | number | null
    strategicImportance?: IntNullableFilter<"DeepWorkTask"> | number | null
    timeAccuracy?: FloatNullableFilter<"DeepWorkTask"> | number | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    subtasks?: DeepWorkSubtaskListRelationFilter
  }

  export type DeepWorkTaskOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    priority?: SortOrder
    completed?: SortOrder
    originalDate?: SortOrder
    currentDate?: SortOrder
    estimatedDuration?: SortOrderInput | SortOrder
    focusBlocks?: SortOrder
    breakDuration?: SortOrder
    interruptionMode?: SortOrder
    rollovers?: SortOrder
    tags?: SortOrder
    category?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    actualDurationMin?: SortOrderInput | SortOrder
    timeEstimate?: SortOrderInput | SortOrder
    aiAnalyzed?: SortOrder
    aiReasoning?: SortOrderInput | SortOrder
    analyzedAt?: SortOrderInput | SortOrder
    xpReward?: SortOrderInput | SortOrder
    complexity?: SortOrderInput | SortOrder
    confidence?: SortOrderInput | SortOrder
    contextualBonus?: SortOrderInput | SortOrder
    difficulty?: SortOrderInput | SortOrder
    learningValue?: SortOrderInput | SortOrder
    priorityRank?: SortOrderInput | SortOrder
    strategicImportance?: SortOrderInput | SortOrder
    timeAccuracy?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    subtasks?: DeepWorkSubtaskOrderByRelationAggregateInput
  }

  export type DeepWorkTaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DeepWorkTaskWhereInput | DeepWorkTaskWhereInput[]
    OR?: DeepWorkTaskWhereInput[]
    NOT?: DeepWorkTaskWhereInput | DeepWorkTaskWhereInput[]
    userId?: StringFilter<"DeepWorkTask"> | string
    title?: StringFilter<"DeepWorkTask"> | string
    description?: StringNullableFilter<"DeepWorkTask"> | string | null
    priority?: EnumPriorityFilter<"DeepWorkTask"> | $Enums.Priority
    completed?: BoolFilter<"DeepWorkTask"> | boolean
    originalDate?: StringFilter<"DeepWorkTask"> | string
    currentDate?: StringFilter<"DeepWorkTask"> | string
    estimatedDuration?: IntNullableFilter<"DeepWorkTask"> | number | null
    focusBlocks?: IntFilter<"DeepWorkTask"> | number
    breakDuration?: IntFilter<"DeepWorkTask"> | number
    interruptionMode?: BoolFilter<"DeepWorkTask"> | boolean
    rollovers?: IntFilter<"DeepWorkTask"> | number
    tags?: StringNullableListFilter<"DeepWorkTask">
    category?: StringNullableFilter<"DeepWorkTask"> | string | null
    createdAt?: DateTimeFilter<"DeepWorkTask"> | Date | string
    updatedAt?: DateTimeFilter<"DeepWorkTask"> | Date | string
    completedAt?: DateTimeNullableFilter<"DeepWorkTask"> | Date | string | null
    startedAt?: DateTimeNullableFilter<"DeepWorkTask"> | Date | string | null
    actualDurationMin?: IntNullableFilter<"DeepWorkTask"> | number | null
    timeEstimate?: StringNullableFilter<"DeepWorkTask"> | string | null
    aiAnalyzed?: BoolFilter<"DeepWorkTask"> | boolean
    aiReasoning?: StringNullableFilter<"DeepWorkTask"> | string | null
    analyzedAt?: DateTimeNullableFilter<"DeepWorkTask"> | Date | string | null
    xpReward?: IntNullableFilter<"DeepWorkTask"> | number | null
    complexity?: IntNullableFilter<"DeepWorkTask"> | number | null
    confidence?: FloatNullableFilter<"DeepWorkTask"> | number | null
    contextualBonus?: FloatNullableFilter<"DeepWorkTask"> | number | null
    difficulty?: IntNullableFilter<"DeepWorkTask"> | number | null
    learningValue?: IntNullableFilter<"DeepWorkTask"> | number | null
    priorityRank?: IntNullableFilter<"DeepWorkTask"> | number | null
    strategicImportance?: IntNullableFilter<"DeepWorkTask"> | number | null
    timeAccuracy?: FloatNullableFilter<"DeepWorkTask"> | number | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    subtasks?: DeepWorkSubtaskListRelationFilter
  }, "id">

  export type DeepWorkTaskOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    priority?: SortOrder
    completed?: SortOrder
    originalDate?: SortOrder
    currentDate?: SortOrder
    estimatedDuration?: SortOrderInput | SortOrder
    focusBlocks?: SortOrder
    breakDuration?: SortOrder
    interruptionMode?: SortOrder
    rollovers?: SortOrder
    tags?: SortOrder
    category?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    actualDurationMin?: SortOrderInput | SortOrder
    timeEstimate?: SortOrderInput | SortOrder
    aiAnalyzed?: SortOrder
    aiReasoning?: SortOrderInput | SortOrder
    analyzedAt?: SortOrderInput | SortOrder
    xpReward?: SortOrderInput | SortOrder
    complexity?: SortOrderInput | SortOrder
    confidence?: SortOrderInput | SortOrder
    contextualBonus?: SortOrderInput | SortOrder
    difficulty?: SortOrderInput | SortOrder
    learningValue?: SortOrderInput | SortOrder
    priorityRank?: SortOrderInput | SortOrder
    strategicImportance?: SortOrderInput | SortOrder
    timeAccuracy?: SortOrderInput | SortOrder
    _count?: DeepWorkTaskCountOrderByAggregateInput
    _avg?: DeepWorkTaskAvgOrderByAggregateInput
    _max?: DeepWorkTaskMaxOrderByAggregateInput
    _min?: DeepWorkTaskMinOrderByAggregateInput
    _sum?: DeepWorkTaskSumOrderByAggregateInput
  }

  export type DeepWorkTaskScalarWhereWithAggregatesInput = {
    AND?: DeepWorkTaskScalarWhereWithAggregatesInput | DeepWorkTaskScalarWhereWithAggregatesInput[]
    OR?: DeepWorkTaskScalarWhereWithAggregatesInput[]
    NOT?: DeepWorkTaskScalarWhereWithAggregatesInput | DeepWorkTaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DeepWorkTask"> | string
    userId?: StringWithAggregatesFilter<"DeepWorkTask"> | string
    title?: StringWithAggregatesFilter<"DeepWorkTask"> | string
    description?: StringNullableWithAggregatesFilter<"DeepWorkTask"> | string | null
    priority?: EnumPriorityWithAggregatesFilter<"DeepWorkTask"> | $Enums.Priority
    completed?: BoolWithAggregatesFilter<"DeepWorkTask"> | boolean
    originalDate?: StringWithAggregatesFilter<"DeepWorkTask"> | string
    currentDate?: StringWithAggregatesFilter<"DeepWorkTask"> | string
    estimatedDuration?: IntNullableWithAggregatesFilter<"DeepWorkTask"> | number | null
    focusBlocks?: IntWithAggregatesFilter<"DeepWorkTask"> | number
    breakDuration?: IntWithAggregatesFilter<"DeepWorkTask"> | number
    interruptionMode?: BoolWithAggregatesFilter<"DeepWorkTask"> | boolean
    rollovers?: IntWithAggregatesFilter<"DeepWorkTask"> | number
    tags?: StringNullableListFilter<"DeepWorkTask">
    category?: StringNullableWithAggregatesFilter<"DeepWorkTask"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DeepWorkTask"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DeepWorkTask"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"DeepWorkTask"> | Date | string | null
    startedAt?: DateTimeNullableWithAggregatesFilter<"DeepWorkTask"> | Date | string | null
    actualDurationMin?: IntNullableWithAggregatesFilter<"DeepWorkTask"> | number | null
    timeEstimate?: StringNullableWithAggregatesFilter<"DeepWorkTask"> | string | null
    aiAnalyzed?: BoolWithAggregatesFilter<"DeepWorkTask"> | boolean
    aiReasoning?: StringNullableWithAggregatesFilter<"DeepWorkTask"> | string | null
    analyzedAt?: DateTimeNullableWithAggregatesFilter<"DeepWorkTask"> | Date | string | null
    xpReward?: IntNullableWithAggregatesFilter<"DeepWorkTask"> | number | null
    complexity?: IntNullableWithAggregatesFilter<"DeepWorkTask"> | number | null
    confidence?: FloatNullableWithAggregatesFilter<"DeepWorkTask"> | number | null
    contextualBonus?: FloatNullableWithAggregatesFilter<"DeepWorkTask"> | number | null
    difficulty?: IntNullableWithAggregatesFilter<"DeepWorkTask"> | number | null
    learningValue?: IntNullableWithAggregatesFilter<"DeepWorkTask"> | number | null
    priorityRank?: IntNullableWithAggregatesFilter<"DeepWorkTask"> | number | null
    strategicImportance?: IntNullableWithAggregatesFilter<"DeepWorkTask"> | number | null
    timeAccuracy?: FloatNullableWithAggregatesFilter<"DeepWorkTask"> | number | null
  }

  export type DeepWorkSubtaskWhereInput = {
    AND?: DeepWorkSubtaskWhereInput | DeepWorkSubtaskWhereInput[]
    OR?: DeepWorkSubtaskWhereInput[]
    NOT?: DeepWorkSubtaskWhereInput | DeepWorkSubtaskWhereInput[]
    id?: StringFilter<"DeepWorkSubtask"> | string
    taskId?: StringFilter<"DeepWorkSubtask"> | string
    title?: StringFilter<"DeepWorkSubtask"> | string
    text?: StringFilter<"DeepWorkSubtask"> | string
    completed?: BoolFilter<"DeepWorkSubtask"> | boolean
    priority?: StringNullableFilter<"DeepWorkSubtask"> | string | null
    dueDate?: DateTimeNullableFilter<"DeepWorkSubtask"> | Date | string | null
    requiresFocus?: BoolFilter<"DeepWorkSubtask"> | boolean
    complexityLevel?: IntNullableFilter<"DeepWorkSubtask"> | number | null
    createdAt?: DateTimeFilter<"DeepWorkSubtask"> | Date | string
    updatedAt?: DateTimeFilter<"DeepWorkSubtask"> | Date | string
    completedAt?: DateTimeNullableFilter<"DeepWorkSubtask"> | Date | string | null
    startedAt?: DateTimeNullableFilter<"DeepWorkSubtask"> | Date | string | null
    actualDurationMin?: IntNullableFilter<"DeepWorkSubtask"> | number | null
    timeAccuracy?: FloatNullableFilter<"DeepWorkSubtask"> | number | null
    aiAnalyzed?: BoolFilter<"DeepWorkSubtask"> | boolean
    aiReasoning?: StringNullableFilter<"DeepWorkSubtask"> | string | null
    analyzedAt?: DateTimeNullableFilter<"DeepWorkSubtask"> | Date | string | null
    xpReward?: IntNullableFilter<"DeepWorkSubtask"> | number | null
    complexity?: IntNullableFilter<"DeepWorkSubtask"> | number | null
    confidence?: FloatNullableFilter<"DeepWorkSubtask"> | number | null
    contextualBonus?: FloatNullableFilter<"DeepWorkSubtask"> | number | null
    difficulty?: IntNullableFilter<"DeepWorkSubtask"> | number | null
    learningValue?: IntNullableFilter<"DeepWorkSubtask"> | number | null
    priorityRank?: IntNullableFilter<"DeepWorkSubtask"> | number | null
    strategicImportance?: IntNullableFilter<"DeepWorkSubtask"> | number | null
    task?: XOR<DeepWorkTaskScalarRelationFilter, DeepWorkTaskWhereInput>
  }

  export type DeepWorkSubtaskOrderByWithRelationInput = {
    id?: SortOrder
    taskId?: SortOrder
    title?: SortOrder
    text?: SortOrder
    completed?: SortOrder
    priority?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    requiresFocus?: SortOrder
    complexityLevel?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    actualDurationMin?: SortOrderInput | SortOrder
    timeAccuracy?: SortOrderInput | SortOrder
    aiAnalyzed?: SortOrder
    aiReasoning?: SortOrderInput | SortOrder
    analyzedAt?: SortOrderInput | SortOrder
    xpReward?: SortOrderInput | SortOrder
    complexity?: SortOrderInput | SortOrder
    confidence?: SortOrderInput | SortOrder
    contextualBonus?: SortOrderInput | SortOrder
    difficulty?: SortOrderInput | SortOrder
    learningValue?: SortOrderInput | SortOrder
    priorityRank?: SortOrderInput | SortOrder
    strategicImportance?: SortOrderInput | SortOrder
    task?: DeepWorkTaskOrderByWithRelationInput
  }

  export type DeepWorkSubtaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DeepWorkSubtaskWhereInput | DeepWorkSubtaskWhereInput[]
    OR?: DeepWorkSubtaskWhereInput[]
    NOT?: DeepWorkSubtaskWhereInput | DeepWorkSubtaskWhereInput[]
    taskId?: StringFilter<"DeepWorkSubtask"> | string
    title?: StringFilter<"DeepWorkSubtask"> | string
    text?: StringFilter<"DeepWorkSubtask"> | string
    completed?: BoolFilter<"DeepWorkSubtask"> | boolean
    priority?: StringNullableFilter<"DeepWorkSubtask"> | string | null
    dueDate?: DateTimeNullableFilter<"DeepWorkSubtask"> | Date | string | null
    requiresFocus?: BoolFilter<"DeepWorkSubtask"> | boolean
    complexityLevel?: IntNullableFilter<"DeepWorkSubtask"> | number | null
    createdAt?: DateTimeFilter<"DeepWorkSubtask"> | Date | string
    updatedAt?: DateTimeFilter<"DeepWorkSubtask"> | Date | string
    completedAt?: DateTimeNullableFilter<"DeepWorkSubtask"> | Date | string | null
    startedAt?: DateTimeNullableFilter<"DeepWorkSubtask"> | Date | string | null
    actualDurationMin?: IntNullableFilter<"DeepWorkSubtask"> | number | null
    timeAccuracy?: FloatNullableFilter<"DeepWorkSubtask"> | number | null
    aiAnalyzed?: BoolFilter<"DeepWorkSubtask"> | boolean
    aiReasoning?: StringNullableFilter<"DeepWorkSubtask"> | string | null
    analyzedAt?: DateTimeNullableFilter<"DeepWorkSubtask"> | Date | string | null
    xpReward?: IntNullableFilter<"DeepWorkSubtask"> | number | null
    complexity?: IntNullableFilter<"DeepWorkSubtask"> | number | null
    confidence?: FloatNullableFilter<"DeepWorkSubtask"> | number | null
    contextualBonus?: FloatNullableFilter<"DeepWorkSubtask"> | number | null
    difficulty?: IntNullableFilter<"DeepWorkSubtask"> | number | null
    learningValue?: IntNullableFilter<"DeepWorkSubtask"> | number | null
    priorityRank?: IntNullableFilter<"DeepWorkSubtask"> | number | null
    strategicImportance?: IntNullableFilter<"DeepWorkSubtask"> | number | null
    task?: XOR<DeepWorkTaskScalarRelationFilter, DeepWorkTaskWhereInput>
  }, "id">

  export type DeepWorkSubtaskOrderByWithAggregationInput = {
    id?: SortOrder
    taskId?: SortOrder
    title?: SortOrder
    text?: SortOrder
    completed?: SortOrder
    priority?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    requiresFocus?: SortOrder
    complexityLevel?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    actualDurationMin?: SortOrderInput | SortOrder
    timeAccuracy?: SortOrderInput | SortOrder
    aiAnalyzed?: SortOrder
    aiReasoning?: SortOrderInput | SortOrder
    analyzedAt?: SortOrderInput | SortOrder
    xpReward?: SortOrderInput | SortOrder
    complexity?: SortOrderInput | SortOrder
    confidence?: SortOrderInput | SortOrder
    contextualBonus?: SortOrderInput | SortOrder
    difficulty?: SortOrderInput | SortOrder
    learningValue?: SortOrderInput | SortOrder
    priorityRank?: SortOrderInput | SortOrder
    strategicImportance?: SortOrderInput | SortOrder
    _count?: DeepWorkSubtaskCountOrderByAggregateInput
    _avg?: DeepWorkSubtaskAvgOrderByAggregateInput
    _max?: DeepWorkSubtaskMaxOrderByAggregateInput
    _min?: DeepWorkSubtaskMinOrderByAggregateInput
    _sum?: DeepWorkSubtaskSumOrderByAggregateInput
  }

  export type DeepWorkSubtaskScalarWhereWithAggregatesInput = {
    AND?: DeepWorkSubtaskScalarWhereWithAggregatesInput | DeepWorkSubtaskScalarWhereWithAggregatesInput[]
    OR?: DeepWorkSubtaskScalarWhereWithAggregatesInput[]
    NOT?: DeepWorkSubtaskScalarWhereWithAggregatesInput | DeepWorkSubtaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DeepWorkSubtask"> | string
    taskId?: StringWithAggregatesFilter<"DeepWorkSubtask"> | string
    title?: StringWithAggregatesFilter<"DeepWorkSubtask"> | string
    text?: StringWithAggregatesFilter<"DeepWorkSubtask"> | string
    completed?: BoolWithAggregatesFilter<"DeepWorkSubtask"> | boolean
    priority?: StringNullableWithAggregatesFilter<"DeepWorkSubtask"> | string | null
    dueDate?: DateTimeNullableWithAggregatesFilter<"DeepWorkSubtask"> | Date | string | null
    requiresFocus?: BoolWithAggregatesFilter<"DeepWorkSubtask"> | boolean
    complexityLevel?: IntNullableWithAggregatesFilter<"DeepWorkSubtask"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"DeepWorkSubtask"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DeepWorkSubtask"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"DeepWorkSubtask"> | Date | string | null
    startedAt?: DateTimeNullableWithAggregatesFilter<"DeepWorkSubtask"> | Date | string | null
    actualDurationMin?: IntNullableWithAggregatesFilter<"DeepWorkSubtask"> | number | null
    timeAccuracy?: FloatNullableWithAggregatesFilter<"DeepWorkSubtask"> | number | null
    aiAnalyzed?: BoolWithAggregatesFilter<"DeepWorkSubtask"> | boolean
    aiReasoning?: StringNullableWithAggregatesFilter<"DeepWorkSubtask"> | string | null
    analyzedAt?: DateTimeNullableWithAggregatesFilter<"DeepWorkSubtask"> | Date | string | null
    xpReward?: IntNullableWithAggregatesFilter<"DeepWorkSubtask"> | number | null
    complexity?: IntNullableWithAggregatesFilter<"DeepWorkSubtask"> | number | null
    confidence?: FloatNullableWithAggregatesFilter<"DeepWorkSubtask"> | number | null
    contextualBonus?: FloatNullableWithAggregatesFilter<"DeepWorkSubtask"> | number | null
    difficulty?: IntNullableWithAggregatesFilter<"DeepWorkSubtask"> | number | null
    learningValue?: IntNullableWithAggregatesFilter<"DeepWorkSubtask"> | number | null
    priorityRank?: IntNullableWithAggregatesFilter<"DeepWorkSubtask"> | number | null
    strategicImportance?: IntNullableWithAggregatesFilter<"DeepWorkSubtask"> | number | null
  }

  export type AutomationTaskWhereInput = {
    AND?: AutomationTaskWhereInput | AutomationTaskWhereInput[]
    OR?: AutomationTaskWhereInput[]
    NOT?: AutomationTaskWhereInput | AutomationTaskWhereInput[]
    id?: StringFilter<"AutomationTask"> | string
    userId?: StringFilter<"AutomationTask"> | string
    name?: StringFilter<"AutomationTask"> | string
    description?: StringNullableFilter<"AutomationTask"> | string | null
    category?: EnumAutomationCategoryFilter<"AutomationTask"> | $Enums.AutomationCategory
    priority?: EnumPriorityFilter<"AutomationTask"> | $Enums.Priority
    status?: EnumAutomationStatusFilter<"AutomationTask"> | $Enums.AutomationStatus
    prompt?: StringFilter<"AutomationTask"> | string
    allowedTools?: JsonFilter<"AutomationTask">
    estimatedTokens?: IntFilter<"AutomationTask"> | number
    actualTokens?: IntNullableFilter<"AutomationTask"> | number | null
    executionTimeMs?: IntNullableFilter<"AutomationTask"> | number | null
    result?: StringNullableFilter<"AutomationTask"> | string | null
    error?: StringNullableFilter<"AutomationTask"> | string | null
    metadata?: JsonFilter<"AutomationTask">
    createdAt?: DateTimeFilter<"AutomationTask"> | Date | string
    updatedAt?: DateTimeFilter<"AutomationTask"> | Date | string
    startedAt?: DateTimeNullableFilter<"AutomationTask"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"AutomationTask"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AutomationTaskOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    prompt?: SortOrder
    allowedTools?: SortOrder
    estimatedTokens?: SortOrder
    actualTokens?: SortOrderInput | SortOrder
    executionTimeMs?: SortOrderInput | SortOrder
    result?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AutomationTaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AutomationTaskWhereInput | AutomationTaskWhereInput[]
    OR?: AutomationTaskWhereInput[]
    NOT?: AutomationTaskWhereInput | AutomationTaskWhereInput[]
    userId?: StringFilter<"AutomationTask"> | string
    name?: StringFilter<"AutomationTask"> | string
    description?: StringNullableFilter<"AutomationTask"> | string | null
    category?: EnumAutomationCategoryFilter<"AutomationTask"> | $Enums.AutomationCategory
    priority?: EnumPriorityFilter<"AutomationTask"> | $Enums.Priority
    status?: EnumAutomationStatusFilter<"AutomationTask"> | $Enums.AutomationStatus
    prompt?: StringFilter<"AutomationTask"> | string
    allowedTools?: JsonFilter<"AutomationTask">
    estimatedTokens?: IntFilter<"AutomationTask"> | number
    actualTokens?: IntNullableFilter<"AutomationTask"> | number | null
    executionTimeMs?: IntNullableFilter<"AutomationTask"> | number | null
    result?: StringNullableFilter<"AutomationTask"> | string | null
    error?: StringNullableFilter<"AutomationTask"> | string | null
    metadata?: JsonFilter<"AutomationTask">
    createdAt?: DateTimeFilter<"AutomationTask"> | Date | string
    updatedAt?: DateTimeFilter<"AutomationTask"> | Date | string
    startedAt?: DateTimeNullableFilter<"AutomationTask"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"AutomationTask"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AutomationTaskOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    prompt?: SortOrder
    allowedTools?: SortOrder
    estimatedTokens?: SortOrder
    actualTokens?: SortOrderInput | SortOrder
    executionTimeMs?: SortOrderInput | SortOrder
    result?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: AutomationTaskCountOrderByAggregateInput
    _avg?: AutomationTaskAvgOrderByAggregateInput
    _max?: AutomationTaskMaxOrderByAggregateInput
    _min?: AutomationTaskMinOrderByAggregateInput
    _sum?: AutomationTaskSumOrderByAggregateInput
  }

  export type AutomationTaskScalarWhereWithAggregatesInput = {
    AND?: AutomationTaskScalarWhereWithAggregatesInput | AutomationTaskScalarWhereWithAggregatesInput[]
    OR?: AutomationTaskScalarWhereWithAggregatesInput[]
    NOT?: AutomationTaskScalarWhereWithAggregatesInput | AutomationTaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AutomationTask"> | string
    userId?: StringWithAggregatesFilter<"AutomationTask"> | string
    name?: StringWithAggregatesFilter<"AutomationTask"> | string
    description?: StringNullableWithAggregatesFilter<"AutomationTask"> | string | null
    category?: EnumAutomationCategoryWithAggregatesFilter<"AutomationTask"> | $Enums.AutomationCategory
    priority?: EnumPriorityWithAggregatesFilter<"AutomationTask"> | $Enums.Priority
    status?: EnumAutomationStatusWithAggregatesFilter<"AutomationTask"> | $Enums.AutomationStatus
    prompt?: StringWithAggregatesFilter<"AutomationTask"> | string
    allowedTools?: JsonWithAggregatesFilter<"AutomationTask">
    estimatedTokens?: IntWithAggregatesFilter<"AutomationTask"> | number
    actualTokens?: IntNullableWithAggregatesFilter<"AutomationTask"> | number | null
    executionTimeMs?: IntNullableWithAggregatesFilter<"AutomationTask"> | number | null
    result?: StringNullableWithAggregatesFilter<"AutomationTask"> | string | null
    error?: StringNullableWithAggregatesFilter<"AutomationTask"> | string | null
    metadata?: JsonWithAggregatesFilter<"AutomationTask">
    createdAt?: DateTimeWithAggregatesFilter<"AutomationTask"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AutomationTask"> | Date | string
    startedAt?: DateTimeNullableWithAggregatesFilter<"AutomationTask"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"AutomationTask"> | Date | string | null
  }

  export type DailyHabitsWhereInput = {
    AND?: DailyHabitsWhereInput | DailyHabitsWhereInput[]
    OR?: DailyHabitsWhereInput[]
    NOT?: DailyHabitsWhereInput | DailyHabitsWhereInput[]
    id?: StringFilter<"DailyHabits"> | string
    userId?: StringFilter<"DailyHabits"> | string
    date?: StringFilter<"DailyHabits"> | string
    screenTimeMinutes?: IntFilter<"DailyHabits"> | number
    bullshitContentMinutes?: IntFilter<"DailyHabits"> | number
    noWeed?: BoolFilter<"DailyHabits"> | boolean
    noScrolling?: BoolFilter<"DailyHabits"> | boolean
    deepWorkHours?: FloatFilter<"DailyHabits"> | number
    lightWorkHours?: FloatFilter<"DailyHabits"> | number
    habitsData?: JsonFilter<"DailyHabits">
    createdAt?: DateTimeFilter<"DailyHabits"> | Date | string
    updatedAt?: DateTimeFilter<"DailyHabits"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type DailyHabitsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    screenTimeMinutes?: SortOrder
    bullshitContentMinutes?: SortOrder
    noWeed?: SortOrder
    noScrolling?: SortOrder
    deepWorkHours?: SortOrder
    lightWorkHours?: SortOrder
    habitsData?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type DailyHabitsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_date?: DailyHabitsUserIdDateCompoundUniqueInput
    AND?: DailyHabitsWhereInput | DailyHabitsWhereInput[]
    OR?: DailyHabitsWhereInput[]
    NOT?: DailyHabitsWhereInput | DailyHabitsWhereInput[]
    userId?: StringFilter<"DailyHabits"> | string
    date?: StringFilter<"DailyHabits"> | string
    screenTimeMinutes?: IntFilter<"DailyHabits"> | number
    bullshitContentMinutes?: IntFilter<"DailyHabits"> | number
    noWeed?: BoolFilter<"DailyHabits"> | boolean
    noScrolling?: BoolFilter<"DailyHabits"> | boolean
    deepWorkHours?: FloatFilter<"DailyHabits"> | number
    lightWorkHours?: FloatFilter<"DailyHabits"> | number
    habitsData?: JsonFilter<"DailyHabits">
    createdAt?: DateTimeFilter<"DailyHabits"> | Date | string
    updatedAt?: DateTimeFilter<"DailyHabits"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_date">

  export type DailyHabitsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    screenTimeMinutes?: SortOrder
    bullshitContentMinutes?: SortOrder
    noWeed?: SortOrder
    noScrolling?: SortOrder
    deepWorkHours?: SortOrder
    lightWorkHours?: SortOrder
    habitsData?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DailyHabitsCountOrderByAggregateInput
    _avg?: DailyHabitsAvgOrderByAggregateInput
    _max?: DailyHabitsMaxOrderByAggregateInput
    _min?: DailyHabitsMinOrderByAggregateInput
    _sum?: DailyHabitsSumOrderByAggregateInput
  }

  export type DailyHabitsScalarWhereWithAggregatesInput = {
    AND?: DailyHabitsScalarWhereWithAggregatesInput | DailyHabitsScalarWhereWithAggregatesInput[]
    OR?: DailyHabitsScalarWhereWithAggregatesInput[]
    NOT?: DailyHabitsScalarWhereWithAggregatesInput | DailyHabitsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DailyHabits"> | string
    userId?: StringWithAggregatesFilter<"DailyHabits"> | string
    date?: StringWithAggregatesFilter<"DailyHabits"> | string
    screenTimeMinutes?: IntWithAggregatesFilter<"DailyHabits"> | number
    bullshitContentMinutes?: IntWithAggregatesFilter<"DailyHabits"> | number
    noWeed?: BoolWithAggregatesFilter<"DailyHabits"> | boolean
    noScrolling?: BoolWithAggregatesFilter<"DailyHabits"> | boolean
    deepWorkHours?: FloatWithAggregatesFilter<"DailyHabits"> | number
    lightWorkHours?: FloatWithAggregatesFilter<"DailyHabits"> | number
    habitsData?: JsonWithAggregatesFilter<"DailyHabits">
    createdAt?: DateTimeWithAggregatesFilter<"DailyHabits"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DailyHabits"> | Date | string
  }

  export type DailyHealthWhereInput = {
    AND?: DailyHealthWhereInput | DailyHealthWhereInput[]
    OR?: DailyHealthWhereInput[]
    NOT?: DailyHealthWhereInput | DailyHealthWhereInput[]
    id?: StringFilter<"DailyHealth"> | string
    userId?: StringFilter<"DailyHealth"> | string
    date?: StringFilter<"DailyHealth"> | string
    healthChecklist?: JsonFilter<"DailyHealth">
    meals?: JsonFilter<"DailyHealth">
    macros?: JsonFilter<"DailyHealth">
    waterIntakeMl?: IntFilter<"DailyHealth"> | number
    milkIntakeMl?: IntFilter<"DailyHealth"> | number
    sleepHours?: FloatFilter<"DailyHealth"> | number
    energyLevel?: IntNullableFilter<"DailyHealth"> | number | null
    moodLevel?: IntNullableFilter<"DailyHealth"> | number | null
    notes?: StringNullableFilter<"DailyHealth"> | string | null
    createdAt?: DateTimeFilter<"DailyHealth"> | Date | string
    updatedAt?: DateTimeFilter<"DailyHealth"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type DailyHealthOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    healthChecklist?: SortOrder
    meals?: SortOrder
    macros?: SortOrder
    waterIntakeMl?: SortOrder
    milkIntakeMl?: SortOrder
    sleepHours?: SortOrder
    energyLevel?: SortOrderInput | SortOrder
    moodLevel?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type DailyHealthWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_date?: DailyHealthUserIdDateCompoundUniqueInput
    AND?: DailyHealthWhereInput | DailyHealthWhereInput[]
    OR?: DailyHealthWhereInput[]
    NOT?: DailyHealthWhereInput | DailyHealthWhereInput[]
    userId?: StringFilter<"DailyHealth"> | string
    date?: StringFilter<"DailyHealth"> | string
    healthChecklist?: JsonFilter<"DailyHealth">
    meals?: JsonFilter<"DailyHealth">
    macros?: JsonFilter<"DailyHealth">
    waterIntakeMl?: IntFilter<"DailyHealth"> | number
    milkIntakeMl?: IntFilter<"DailyHealth"> | number
    sleepHours?: FloatFilter<"DailyHealth"> | number
    energyLevel?: IntNullableFilter<"DailyHealth"> | number | null
    moodLevel?: IntNullableFilter<"DailyHealth"> | number | null
    notes?: StringNullableFilter<"DailyHealth"> | string | null
    createdAt?: DateTimeFilter<"DailyHealth"> | Date | string
    updatedAt?: DateTimeFilter<"DailyHealth"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_date">

  export type DailyHealthOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    healthChecklist?: SortOrder
    meals?: SortOrder
    macros?: SortOrder
    waterIntakeMl?: SortOrder
    milkIntakeMl?: SortOrder
    sleepHours?: SortOrder
    energyLevel?: SortOrderInput | SortOrder
    moodLevel?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DailyHealthCountOrderByAggregateInput
    _avg?: DailyHealthAvgOrderByAggregateInput
    _max?: DailyHealthMaxOrderByAggregateInput
    _min?: DailyHealthMinOrderByAggregateInput
    _sum?: DailyHealthSumOrderByAggregateInput
  }

  export type DailyHealthScalarWhereWithAggregatesInput = {
    AND?: DailyHealthScalarWhereWithAggregatesInput | DailyHealthScalarWhereWithAggregatesInput[]
    OR?: DailyHealthScalarWhereWithAggregatesInput[]
    NOT?: DailyHealthScalarWhereWithAggregatesInput | DailyHealthScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DailyHealth"> | string
    userId?: StringWithAggregatesFilter<"DailyHealth"> | string
    date?: StringWithAggregatesFilter<"DailyHealth"> | string
    healthChecklist?: JsonWithAggregatesFilter<"DailyHealth">
    meals?: JsonWithAggregatesFilter<"DailyHealth">
    macros?: JsonWithAggregatesFilter<"DailyHealth">
    waterIntakeMl?: IntWithAggregatesFilter<"DailyHealth"> | number
    milkIntakeMl?: IntWithAggregatesFilter<"DailyHealth"> | number
    sleepHours?: FloatWithAggregatesFilter<"DailyHealth"> | number
    energyLevel?: IntNullableWithAggregatesFilter<"DailyHealth"> | number | null
    moodLevel?: IntNullableWithAggregatesFilter<"DailyHealth"> | number | null
    notes?: StringNullableWithAggregatesFilter<"DailyHealth"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DailyHealth"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DailyHealth"> | Date | string
  }

  export type DailyWorkoutWhereInput = {
    AND?: DailyWorkoutWhereInput | DailyWorkoutWhereInput[]
    OR?: DailyWorkoutWhereInput[]
    NOT?: DailyWorkoutWhereInput | DailyWorkoutWhereInput[]
    id?: StringFilter<"DailyWorkout"> | string
    userId?: StringFilter<"DailyWorkout"> | string
    date?: StringFilter<"DailyWorkout"> | string
    exercises?: JsonFilter<"DailyWorkout">
    totalExercises?: IntFilter<"DailyWorkout"> | number
    completedExercises?: IntFilter<"DailyWorkout"> | number
    completionPercentage?: FloatFilter<"DailyWorkout"> | number
    durationMinutes?: IntNullableFilter<"DailyWorkout"> | number | null
    notes?: StringNullableFilter<"DailyWorkout"> | string | null
    createdAt?: DateTimeFilter<"DailyWorkout"> | Date | string
    updatedAt?: DateTimeFilter<"DailyWorkout"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type DailyWorkoutOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    exercises?: SortOrder
    totalExercises?: SortOrder
    completedExercises?: SortOrder
    completionPercentage?: SortOrder
    durationMinutes?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type DailyWorkoutWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_date?: DailyWorkoutUserIdDateCompoundUniqueInput
    AND?: DailyWorkoutWhereInput | DailyWorkoutWhereInput[]
    OR?: DailyWorkoutWhereInput[]
    NOT?: DailyWorkoutWhereInput | DailyWorkoutWhereInput[]
    userId?: StringFilter<"DailyWorkout"> | string
    date?: StringFilter<"DailyWorkout"> | string
    exercises?: JsonFilter<"DailyWorkout">
    totalExercises?: IntFilter<"DailyWorkout"> | number
    completedExercises?: IntFilter<"DailyWorkout"> | number
    completionPercentage?: FloatFilter<"DailyWorkout"> | number
    durationMinutes?: IntNullableFilter<"DailyWorkout"> | number | null
    notes?: StringNullableFilter<"DailyWorkout"> | string | null
    createdAt?: DateTimeFilter<"DailyWorkout"> | Date | string
    updatedAt?: DateTimeFilter<"DailyWorkout"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_date">

  export type DailyWorkoutOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    exercises?: SortOrder
    totalExercises?: SortOrder
    completedExercises?: SortOrder
    completionPercentage?: SortOrder
    durationMinutes?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DailyWorkoutCountOrderByAggregateInput
    _avg?: DailyWorkoutAvgOrderByAggregateInput
    _max?: DailyWorkoutMaxOrderByAggregateInput
    _min?: DailyWorkoutMinOrderByAggregateInput
    _sum?: DailyWorkoutSumOrderByAggregateInput
  }

  export type DailyWorkoutScalarWhereWithAggregatesInput = {
    AND?: DailyWorkoutScalarWhereWithAggregatesInput | DailyWorkoutScalarWhereWithAggregatesInput[]
    OR?: DailyWorkoutScalarWhereWithAggregatesInput[]
    NOT?: DailyWorkoutScalarWhereWithAggregatesInput | DailyWorkoutScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DailyWorkout"> | string
    userId?: StringWithAggregatesFilter<"DailyWorkout"> | string
    date?: StringWithAggregatesFilter<"DailyWorkout"> | string
    exercises?: JsonWithAggregatesFilter<"DailyWorkout">
    totalExercises?: IntWithAggregatesFilter<"DailyWorkout"> | number
    completedExercises?: IntWithAggregatesFilter<"DailyWorkout"> | number
    completionPercentage?: FloatWithAggregatesFilter<"DailyWorkout"> | number
    durationMinutes?: IntNullableWithAggregatesFilter<"DailyWorkout"> | number | null
    notes?: StringNullableWithAggregatesFilter<"DailyWorkout"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DailyWorkout"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DailyWorkout"> | Date | string
  }

  export type DailyRoutineWhereInput = {
    AND?: DailyRoutineWhereInput | DailyRoutineWhereInput[]
    OR?: DailyRoutineWhereInput[]
    NOT?: DailyRoutineWhereInput | DailyRoutineWhereInput[]
    id?: StringFilter<"DailyRoutine"> | string
    userId?: StringFilter<"DailyRoutine"> | string
    date?: StringFilter<"DailyRoutine"> | string
    routineType?: EnumRoutineTypeFilter<"DailyRoutine"> | $Enums.RoutineType
    items?: JsonFilter<"DailyRoutine">
    completedCount?: IntFilter<"DailyRoutine"> | number
    totalCount?: IntFilter<"DailyRoutine"> | number
    completionPercentage?: FloatFilter<"DailyRoutine"> | number
    createdAt?: DateTimeFilter<"DailyRoutine"> | Date | string
    updatedAt?: DateTimeFilter<"DailyRoutine"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type DailyRoutineOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    routineType?: SortOrder
    items?: SortOrder
    completedCount?: SortOrder
    totalCount?: SortOrder
    completionPercentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type DailyRoutineWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_date_routineType?: DailyRoutineUserIdDateRoutineTypeCompoundUniqueInput
    AND?: DailyRoutineWhereInput | DailyRoutineWhereInput[]
    OR?: DailyRoutineWhereInput[]
    NOT?: DailyRoutineWhereInput | DailyRoutineWhereInput[]
    userId?: StringFilter<"DailyRoutine"> | string
    date?: StringFilter<"DailyRoutine"> | string
    routineType?: EnumRoutineTypeFilter<"DailyRoutine"> | $Enums.RoutineType
    items?: JsonFilter<"DailyRoutine">
    completedCount?: IntFilter<"DailyRoutine"> | number
    totalCount?: IntFilter<"DailyRoutine"> | number
    completionPercentage?: FloatFilter<"DailyRoutine"> | number
    createdAt?: DateTimeFilter<"DailyRoutine"> | Date | string
    updatedAt?: DateTimeFilter<"DailyRoutine"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_date_routineType">

  export type DailyRoutineOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    routineType?: SortOrder
    items?: SortOrder
    completedCount?: SortOrder
    totalCount?: SortOrder
    completionPercentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DailyRoutineCountOrderByAggregateInput
    _avg?: DailyRoutineAvgOrderByAggregateInput
    _max?: DailyRoutineMaxOrderByAggregateInput
    _min?: DailyRoutineMinOrderByAggregateInput
    _sum?: DailyRoutineSumOrderByAggregateInput
  }

  export type DailyRoutineScalarWhereWithAggregatesInput = {
    AND?: DailyRoutineScalarWhereWithAggregatesInput | DailyRoutineScalarWhereWithAggregatesInput[]
    OR?: DailyRoutineScalarWhereWithAggregatesInput[]
    NOT?: DailyRoutineScalarWhereWithAggregatesInput | DailyRoutineScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DailyRoutine"> | string
    userId?: StringWithAggregatesFilter<"DailyRoutine"> | string
    date?: StringWithAggregatesFilter<"DailyRoutine"> | string
    routineType?: EnumRoutineTypeWithAggregatesFilter<"DailyRoutine"> | $Enums.RoutineType
    items?: JsonWithAggregatesFilter<"DailyRoutine">
    completedCount?: IntWithAggregatesFilter<"DailyRoutine"> | number
    totalCount?: IntWithAggregatesFilter<"DailyRoutine"> | number
    completionPercentage?: FloatWithAggregatesFilter<"DailyRoutine"> | number
    createdAt?: DateTimeWithAggregatesFilter<"DailyRoutine"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DailyRoutine"> | Date | string
  }

  export type DailyReflectionsWhereInput = {
    AND?: DailyReflectionsWhereInput | DailyReflectionsWhereInput[]
    OR?: DailyReflectionsWhereInput[]
    NOT?: DailyReflectionsWhereInput | DailyReflectionsWhereInput[]
    id?: StringFilter<"DailyReflections"> | string
    userId?: StringFilter<"DailyReflections"> | string
    date?: StringFilter<"DailyReflections"> | string
    wentWell?: StringNullableListFilter<"DailyReflections">
    evenBetterIf?: StringNullableListFilter<"DailyReflections">
    analysis?: StringNullableListFilter<"DailyReflections">
    patterns?: StringNullableListFilter<"DailyReflections">
    changes?: StringNullableListFilter<"DailyReflections">
    overallRating?: IntNullableFilter<"DailyReflections"> | number | null
    keyLearnings?: StringNullableFilter<"DailyReflections"> | string | null
    tomorrowFocus?: StringNullableFilter<"DailyReflections"> | string | null
    createdAt?: DateTimeFilter<"DailyReflections"> | Date | string
    updatedAt?: DateTimeFilter<"DailyReflections"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type DailyReflectionsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    wentWell?: SortOrder
    evenBetterIf?: SortOrder
    analysis?: SortOrder
    patterns?: SortOrder
    changes?: SortOrder
    overallRating?: SortOrderInput | SortOrder
    keyLearnings?: SortOrderInput | SortOrder
    tomorrowFocus?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type DailyReflectionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_date?: DailyReflectionsUserIdDateCompoundUniqueInput
    AND?: DailyReflectionsWhereInput | DailyReflectionsWhereInput[]
    OR?: DailyReflectionsWhereInput[]
    NOT?: DailyReflectionsWhereInput | DailyReflectionsWhereInput[]
    userId?: StringFilter<"DailyReflections"> | string
    date?: StringFilter<"DailyReflections"> | string
    wentWell?: StringNullableListFilter<"DailyReflections">
    evenBetterIf?: StringNullableListFilter<"DailyReflections">
    analysis?: StringNullableListFilter<"DailyReflections">
    patterns?: StringNullableListFilter<"DailyReflections">
    changes?: StringNullableListFilter<"DailyReflections">
    overallRating?: IntNullableFilter<"DailyReflections"> | number | null
    keyLearnings?: StringNullableFilter<"DailyReflections"> | string | null
    tomorrowFocus?: StringNullableFilter<"DailyReflections"> | string | null
    createdAt?: DateTimeFilter<"DailyReflections"> | Date | string
    updatedAt?: DateTimeFilter<"DailyReflections"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_date">

  export type DailyReflectionsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    wentWell?: SortOrder
    evenBetterIf?: SortOrder
    analysis?: SortOrder
    patterns?: SortOrder
    changes?: SortOrder
    overallRating?: SortOrderInput | SortOrder
    keyLearnings?: SortOrderInput | SortOrder
    tomorrowFocus?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DailyReflectionsCountOrderByAggregateInput
    _avg?: DailyReflectionsAvgOrderByAggregateInput
    _max?: DailyReflectionsMaxOrderByAggregateInput
    _min?: DailyReflectionsMinOrderByAggregateInput
    _sum?: DailyReflectionsSumOrderByAggregateInput
  }

  export type DailyReflectionsScalarWhereWithAggregatesInput = {
    AND?: DailyReflectionsScalarWhereWithAggregatesInput | DailyReflectionsScalarWhereWithAggregatesInput[]
    OR?: DailyReflectionsScalarWhereWithAggregatesInput[]
    NOT?: DailyReflectionsScalarWhereWithAggregatesInput | DailyReflectionsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DailyReflections"> | string
    userId?: StringWithAggregatesFilter<"DailyReflections"> | string
    date?: StringWithAggregatesFilter<"DailyReflections"> | string
    wentWell?: StringNullableListFilter<"DailyReflections">
    evenBetterIf?: StringNullableListFilter<"DailyReflections">
    analysis?: StringNullableListFilter<"DailyReflections">
    patterns?: StringNullableListFilter<"DailyReflections">
    changes?: StringNullableListFilter<"DailyReflections">
    overallRating?: IntNullableWithAggregatesFilter<"DailyReflections"> | number | null
    keyLearnings?: StringNullableWithAggregatesFilter<"DailyReflections"> | string | null
    tomorrowFocus?: StringNullableWithAggregatesFilter<"DailyReflections"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DailyReflections"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DailyReflections"> | Date | string
  }

  export type TimeBlockWhereInput = {
    AND?: TimeBlockWhereInput | TimeBlockWhereInput[]
    OR?: TimeBlockWhereInput[]
    NOT?: TimeBlockWhereInput | TimeBlockWhereInput[]
    id?: StringFilter<"TimeBlock"> | string
    userId?: StringFilter<"TimeBlock"> | string
    date?: StringFilter<"TimeBlock"> | string
    startTime?: StringFilter<"TimeBlock"> | string
    endTime?: StringFilter<"TimeBlock"> | string
    title?: StringFilter<"TimeBlock"> | string
    description?: StringNullableFilter<"TimeBlock"> | string | null
    category?: EnumTimeBlockCategoryFilter<"TimeBlock"> | $Enums.TimeBlockCategory
    completed?: BoolFilter<"TimeBlock"> | boolean
    actualStart?: StringNullableFilter<"TimeBlock"> | string | null
    actualEnd?: StringNullableFilter<"TimeBlock"> | string | null
    notes?: StringNullableFilter<"TimeBlock"> | string | null
    createdAt?: DateTimeFilter<"TimeBlock"> | Date | string
    updatedAt?: DateTimeFilter<"TimeBlock"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TimeBlockOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    completed?: SortOrder
    actualStart?: SortOrderInput | SortOrder
    actualEnd?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type TimeBlockWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TimeBlockWhereInput | TimeBlockWhereInput[]
    OR?: TimeBlockWhereInput[]
    NOT?: TimeBlockWhereInput | TimeBlockWhereInput[]
    userId?: StringFilter<"TimeBlock"> | string
    date?: StringFilter<"TimeBlock"> | string
    startTime?: StringFilter<"TimeBlock"> | string
    endTime?: StringFilter<"TimeBlock"> | string
    title?: StringFilter<"TimeBlock"> | string
    description?: StringNullableFilter<"TimeBlock"> | string | null
    category?: EnumTimeBlockCategoryFilter<"TimeBlock"> | $Enums.TimeBlockCategory
    completed?: BoolFilter<"TimeBlock"> | boolean
    actualStart?: StringNullableFilter<"TimeBlock"> | string | null
    actualEnd?: StringNullableFilter<"TimeBlock"> | string | null
    notes?: StringNullableFilter<"TimeBlock"> | string | null
    createdAt?: DateTimeFilter<"TimeBlock"> | Date | string
    updatedAt?: DateTimeFilter<"TimeBlock"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type TimeBlockOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    completed?: SortOrder
    actualStart?: SortOrderInput | SortOrder
    actualEnd?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TimeBlockCountOrderByAggregateInput
    _max?: TimeBlockMaxOrderByAggregateInput
    _min?: TimeBlockMinOrderByAggregateInput
  }

  export type TimeBlockScalarWhereWithAggregatesInput = {
    AND?: TimeBlockScalarWhereWithAggregatesInput | TimeBlockScalarWhereWithAggregatesInput[]
    OR?: TimeBlockScalarWhereWithAggregatesInput[]
    NOT?: TimeBlockScalarWhereWithAggregatesInput | TimeBlockScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TimeBlock"> | string
    userId?: StringWithAggregatesFilter<"TimeBlock"> | string
    date?: StringWithAggregatesFilter<"TimeBlock"> | string
    startTime?: StringWithAggregatesFilter<"TimeBlock"> | string
    endTime?: StringWithAggregatesFilter<"TimeBlock"> | string
    title?: StringWithAggregatesFilter<"TimeBlock"> | string
    description?: StringNullableWithAggregatesFilter<"TimeBlock"> | string | null
    category?: EnumTimeBlockCategoryWithAggregatesFilter<"TimeBlock"> | $Enums.TimeBlockCategory
    completed?: BoolWithAggregatesFilter<"TimeBlock"> | boolean
    actualStart?: StringNullableWithAggregatesFilter<"TimeBlock"> | string | null
    actualEnd?: StringNullableWithAggregatesFilter<"TimeBlock"> | string | null
    notes?: StringNullableWithAggregatesFilter<"TimeBlock"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TimeBlock"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TimeBlock"> | Date | string
  }

  export type PersonalContextWhereInput = {
    AND?: PersonalContextWhereInput | PersonalContextWhereInput[]
    OR?: PersonalContextWhereInput[]
    NOT?: PersonalContextWhereInput | PersonalContextWhereInput[]
    id?: StringFilter<"PersonalContext"> | string
    userId?: StringFilter<"PersonalContext"> | string
    currentGoals?: StringNullableFilter<"PersonalContext"> | string | null
    skillPriorities?: StringNullableFilter<"PersonalContext"> | string | null
    revenueTargets?: StringNullableFilter<"PersonalContext"> | string | null
    timeConstraints?: StringNullableFilter<"PersonalContext"> | string | null
    currentProjects?: StringNullableFilter<"PersonalContext"> | string | null
    hatedTasks?: StringNullableFilter<"PersonalContext"> | string | null
    valuedTasks?: StringNullableFilter<"PersonalContext"> | string | null
    learningObjectives?: StringNullableFilter<"PersonalContext"> | string | null
    createdAt?: DateTimeFilter<"PersonalContext"> | Date | string
    updatedAt?: DateTimeFilter<"PersonalContext"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PersonalContextOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    currentGoals?: SortOrderInput | SortOrder
    skillPriorities?: SortOrderInput | SortOrder
    revenueTargets?: SortOrderInput | SortOrder
    timeConstraints?: SortOrderInput | SortOrder
    currentProjects?: SortOrderInput | SortOrder
    hatedTasks?: SortOrderInput | SortOrder
    valuedTasks?: SortOrderInput | SortOrder
    learningObjectives?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PersonalContextWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PersonalContextWhereInput | PersonalContextWhereInput[]
    OR?: PersonalContextWhereInput[]
    NOT?: PersonalContextWhereInput | PersonalContextWhereInput[]
    userId?: StringFilter<"PersonalContext"> | string
    currentGoals?: StringNullableFilter<"PersonalContext"> | string | null
    skillPriorities?: StringNullableFilter<"PersonalContext"> | string | null
    revenueTargets?: StringNullableFilter<"PersonalContext"> | string | null
    timeConstraints?: StringNullableFilter<"PersonalContext"> | string | null
    currentProjects?: StringNullableFilter<"PersonalContext"> | string | null
    hatedTasks?: StringNullableFilter<"PersonalContext"> | string | null
    valuedTasks?: StringNullableFilter<"PersonalContext"> | string | null
    learningObjectives?: StringNullableFilter<"PersonalContext"> | string | null
    createdAt?: DateTimeFilter<"PersonalContext"> | Date | string
    updatedAt?: DateTimeFilter<"PersonalContext"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type PersonalContextOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    currentGoals?: SortOrderInput | SortOrder
    skillPriorities?: SortOrderInput | SortOrder
    revenueTargets?: SortOrderInput | SortOrder
    timeConstraints?: SortOrderInput | SortOrder
    currentProjects?: SortOrderInput | SortOrder
    hatedTasks?: SortOrderInput | SortOrder
    valuedTasks?: SortOrderInput | SortOrder
    learningObjectives?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PersonalContextCountOrderByAggregateInput
    _max?: PersonalContextMaxOrderByAggregateInput
    _min?: PersonalContextMinOrderByAggregateInput
  }

  export type PersonalContextScalarWhereWithAggregatesInput = {
    AND?: PersonalContextScalarWhereWithAggregatesInput | PersonalContextScalarWhereWithAggregatesInput[]
    OR?: PersonalContextScalarWhereWithAggregatesInput[]
    NOT?: PersonalContextScalarWhereWithAggregatesInput | PersonalContextScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PersonalContext"> | string
    userId?: StringWithAggregatesFilter<"PersonalContext"> | string
    currentGoals?: StringNullableWithAggregatesFilter<"PersonalContext"> | string | null
    skillPriorities?: StringNullableWithAggregatesFilter<"PersonalContext"> | string | null
    revenueTargets?: StringNullableWithAggregatesFilter<"PersonalContext"> | string | null
    timeConstraints?: StringNullableWithAggregatesFilter<"PersonalContext"> | string | null
    currentProjects?: StringNullableWithAggregatesFilter<"PersonalContext"> | string | null
    hatedTasks?: StringNullableWithAggregatesFilter<"PersonalContext"> | string | null
    valuedTasks?: StringNullableWithAggregatesFilter<"PersonalContext"> | string | null
    learningObjectives?: StringNullableWithAggregatesFilter<"PersonalContext"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PersonalContext"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PersonalContext"> | Date | string
  }

  export type UserProgressWhereInput = {
    AND?: UserProgressWhereInput | UserProgressWhereInput[]
    OR?: UserProgressWhereInput[]
    NOT?: UserProgressWhereInput | UserProgressWhereInput[]
    id?: StringFilter<"UserProgress"> | string
    userId?: StringFilter<"UserProgress"> | string
    currentLevel?: IntFilter<"UserProgress"> | number
    totalXP?: IntFilter<"UserProgress"> | number
    dailyXP?: IntFilter<"UserProgress"> | number
    currentStreak?: IntFilter<"UserProgress"> | number
    bestStreak?: IntFilter<"UserProgress"> | number
    createdAt?: DateTimeFilter<"UserProgress"> | Date | string
    updatedAt?: DateTimeFilter<"UserProgress"> | Date | string
    achievements?: AchievementListRelationFilter
    dailyStats?: DailyStatsListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserProgressOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    currentLevel?: SortOrder
    totalXP?: SortOrder
    dailyXP?: SortOrder
    currentStreak?: SortOrder
    bestStreak?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    achievements?: AchievementOrderByRelationAggregateInput
    dailyStats?: DailyStatsOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
  }

  export type UserProgressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: UserProgressWhereInput | UserProgressWhereInput[]
    OR?: UserProgressWhereInput[]
    NOT?: UserProgressWhereInput | UserProgressWhereInput[]
    currentLevel?: IntFilter<"UserProgress"> | number
    totalXP?: IntFilter<"UserProgress"> | number
    dailyXP?: IntFilter<"UserProgress"> | number
    currentStreak?: IntFilter<"UserProgress"> | number
    bestStreak?: IntFilter<"UserProgress"> | number
    createdAt?: DateTimeFilter<"UserProgress"> | Date | string
    updatedAt?: DateTimeFilter<"UserProgress"> | Date | string
    achievements?: AchievementListRelationFilter
    dailyStats?: DailyStatsListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type UserProgressOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    currentLevel?: SortOrder
    totalXP?: SortOrder
    dailyXP?: SortOrder
    currentStreak?: SortOrder
    bestStreak?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserProgressCountOrderByAggregateInput
    _avg?: UserProgressAvgOrderByAggregateInput
    _max?: UserProgressMaxOrderByAggregateInput
    _min?: UserProgressMinOrderByAggregateInput
    _sum?: UserProgressSumOrderByAggregateInput
  }

  export type UserProgressScalarWhereWithAggregatesInput = {
    AND?: UserProgressScalarWhereWithAggregatesInput | UserProgressScalarWhereWithAggregatesInput[]
    OR?: UserProgressScalarWhereWithAggregatesInput[]
    NOT?: UserProgressScalarWhereWithAggregatesInput | UserProgressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserProgress"> | string
    userId?: StringWithAggregatesFilter<"UserProgress"> | string
    currentLevel?: IntWithAggregatesFilter<"UserProgress"> | number
    totalXP?: IntWithAggregatesFilter<"UserProgress"> | number
    dailyXP?: IntWithAggregatesFilter<"UserProgress"> | number
    currentStreak?: IntWithAggregatesFilter<"UserProgress"> | number
    bestStreak?: IntWithAggregatesFilter<"UserProgress"> | number
    createdAt?: DateTimeWithAggregatesFilter<"UserProgress"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserProgress"> | Date | string
  }

  export type AchievementWhereInput = {
    AND?: AchievementWhereInput | AchievementWhereInput[]
    OR?: AchievementWhereInput[]
    NOT?: AchievementWhereInput | AchievementWhereInput[]
    id?: StringFilter<"Achievement"> | string
    progressId?: StringFilter<"Achievement"> | string
    name?: StringFilter<"Achievement"> | string
    description?: StringFilter<"Achievement"> | string
    badge?: StringFilter<"Achievement"> | string
    category?: EnumAchievementCategoryFilter<"Achievement"> | $Enums.AchievementCategory
    requirement?: IntFilter<"Achievement"> | number
    unlocked?: BoolFilter<"Achievement"> | boolean
    progress?: IntFilter<"Achievement"> | number
    maxProgress?: IntFilter<"Achievement"> | number
    unlockedAt?: DateTimeNullableFilter<"Achievement"> | Date | string | null
    createdAt?: DateTimeFilter<"Achievement"> | Date | string
    userProgress?: XOR<UserProgressScalarRelationFilter, UserProgressWhereInput>
  }

  export type AchievementOrderByWithRelationInput = {
    id?: SortOrder
    progressId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    badge?: SortOrder
    category?: SortOrder
    requirement?: SortOrder
    unlocked?: SortOrder
    progress?: SortOrder
    maxProgress?: SortOrder
    unlockedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    userProgress?: UserProgressOrderByWithRelationInput
  }

  export type AchievementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AchievementWhereInput | AchievementWhereInput[]
    OR?: AchievementWhereInput[]
    NOT?: AchievementWhereInput | AchievementWhereInput[]
    progressId?: StringFilter<"Achievement"> | string
    name?: StringFilter<"Achievement"> | string
    description?: StringFilter<"Achievement"> | string
    badge?: StringFilter<"Achievement"> | string
    category?: EnumAchievementCategoryFilter<"Achievement"> | $Enums.AchievementCategory
    requirement?: IntFilter<"Achievement"> | number
    unlocked?: BoolFilter<"Achievement"> | boolean
    progress?: IntFilter<"Achievement"> | number
    maxProgress?: IntFilter<"Achievement"> | number
    unlockedAt?: DateTimeNullableFilter<"Achievement"> | Date | string | null
    createdAt?: DateTimeFilter<"Achievement"> | Date | string
    userProgress?: XOR<UserProgressScalarRelationFilter, UserProgressWhereInput>
  }, "id">

  export type AchievementOrderByWithAggregationInput = {
    id?: SortOrder
    progressId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    badge?: SortOrder
    category?: SortOrder
    requirement?: SortOrder
    unlocked?: SortOrder
    progress?: SortOrder
    maxProgress?: SortOrder
    unlockedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AchievementCountOrderByAggregateInput
    _avg?: AchievementAvgOrderByAggregateInput
    _max?: AchievementMaxOrderByAggregateInput
    _min?: AchievementMinOrderByAggregateInput
    _sum?: AchievementSumOrderByAggregateInput
  }

  export type AchievementScalarWhereWithAggregatesInput = {
    AND?: AchievementScalarWhereWithAggregatesInput | AchievementScalarWhereWithAggregatesInput[]
    OR?: AchievementScalarWhereWithAggregatesInput[]
    NOT?: AchievementScalarWhereWithAggregatesInput | AchievementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Achievement"> | string
    progressId?: StringWithAggregatesFilter<"Achievement"> | string
    name?: StringWithAggregatesFilter<"Achievement"> | string
    description?: StringWithAggregatesFilter<"Achievement"> | string
    badge?: StringWithAggregatesFilter<"Achievement"> | string
    category?: EnumAchievementCategoryWithAggregatesFilter<"Achievement"> | $Enums.AchievementCategory
    requirement?: IntWithAggregatesFilter<"Achievement"> | number
    unlocked?: BoolWithAggregatesFilter<"Achievement"> | boolean
    progress?: IntWithAggregatesFilter<"Achievement"> | number
    maxProgress?: IntWithAggregatesFilter<"Achievement"> | number
    unlockedAt?: DateTimeNullableWithAggregatesFilter<"Achievement"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Achievement"> | Date | string
  }

  export type DailyStatsWhereInput = {
    AND?: DailyStatsWhereInput | DailyStatsWhereInput[]
    OR?: DailyStatsWhereInput[]
    NOT?: DailyStatsWhereInput | DailyStatsWhereInput[]
    id?: StringFilter<"DailyStats"> | string
    progressId?: StringFilter<"DailyStats"> | string
    date?: StringFilter<"DailyStats"> | string
    totalXP?: IntFilter<"DailyStats"> | number
    activitiesCompleted?: IntFilter<"DailyStats"> | number
    streakCount?: IntFilter<"DailyStats"> | number
    level?: IntFilter<"DailyStats"> | number
    routineXP?: IntFilter<"DailyStats"> | number
    taskXP?: IntFilter<"DailyStats"> | number
    healthXP?: IntFilter<"DailyStats"> | number
    focusXP?: IntFilter<"DailyStats"> | number
    habitXP?: IntFilter<"DailyStats"> | number
    createdAt?: DateTimeFilter<"DailyStats"> | Date | string
    userProgress?: XOR<UserProgressScalarRelationFilter, UserProgressWhereInput>
  }

  export type DailyStatsOrderByWithRelationInput = {
    id?: SortOrder
    progressId?: SortOrder
    date?: SortOrder
    totalXP?: SortOrder
    activitiesCompleted?: SortOrder
    streakCount?: SortOrder
    level?: SortOrder
    routineXP?: SortOrder
    taskXP?: SortOrder
    healthXP?: SortOrder
    focusXP?: SortOrder
    habitXP?: SortOrder
    createdAt?: SortOrder
    userProgress?: UserProgressOrderByWithRelationInput
  }

  export type DailyStatsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    progressId_date?: DailyStatsProgressIdDateCompoundUniqueInput
    AND?: DailyStatsWhereInput | DailyStatsWhereInput[]
    OR?: DailyStatsWhereInput[]
    NOT?: DailyStatsWhereInput | DailyStatsWhereInput[]
    progressId?: StringFilter<"DailyStats"> | string
    date?: StringFilter<"DailyStats"> | string
    totalXP?: IntFilter<"DailyStats"> | number
    activitiesCompleted?: IntFilter<"DailyStats"> | number
    streakCount?: IntFilter<"DailyStats"> | number
    level?: IntFilter<"DailyStats"> | number
    routineXP?: IntFilter<"DailyStats"> | number
    taskXP?: IntFilter<"DailyStats"> | number
    healthXP?: IntFilter<"DailyStats"> | number
    focusXP?: IntFilter<"DailyStats"> | number
    habitXP?: IntFilter<"DailyStats"> | number
    createdAt?: DateTimeFilter<"DailyStats"> | Date | string
    userProgress?: XOR<UserProgressScalarRelationFilter, UserProgressWhereInput>
  }, "id" | "progressId_date">

  export type DailyStatsOrderByWithAggregationInput = {
    id?: SortOrder
    progressId?: SortOrder
    date?: SortOrder
    totalXP?: SortOrder
    activitiesCompleted?: SortOrder
    streakCount?: SortOrder
    level?: SortOrder
    routineXP?: SortOrder
    taskXP?: SortOrder
    healthXP?: SortOrder
    focusXP?: SortOrder
    habitXP?: SortOrder
    createdAt?: SortOrder
    _count?: DailyStatsCountOrderByAggregateInput
    _avg?: DailyStatsAvgOrderByAggregateInput
    _max?: DailyStatsMaxOrderByAggregateInput
    _min?: DailyStatsMinOrderByAggregateInput
    _sum?: DailyStatsSumOrderByAggregateInput
  }

  export type DailyStatsScalarWhereWithAggregatesInput = {
    AND?: DailyStatsScalarWhereWithAggregatesInput | DailyStatsScalarWhereWithAggregatesInput[]
    OR?: DailyStatsScalarWhereWithAggregatesInput[]
    NOT?: DailyStatsScalarWhereWithAggregatesInput | DailyStatsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DailyStats"> | string
    progressId?: StringWithAggregatesFilter<"DailyStats"> | string
    date?: StringWithAggregatesFilter<"DailyStats"> | string
    totalXP?: IntWithAggregatesFilter<"DailyStats"> | number
    activitiesCompleted?: IntWithAggregatesFilter<"DailyStats"> | number
    streakCount?: IntWithAggregatesFilter<"DailyStats"> | number
    level?: IntWithAggregatesFilter<"DailyStats"> | number
    routineXP?: IntWithAggregatesFilter<"DailyStats"> | number
    taskXP?: IntWithAggregatesFilter<"DailyStats"> | number
    healthXP?: IntWithAggregatesFilter<"DailyStats"> | number
    focusXP?: IntWithAggregatesFilter<"DailyStats"> | number
    habitXP?: IntWithAggregatesFilter<"DailyStats"> | number
    createdAt?: DateTimeWithAggregatesFilter<"DailyStats"> | Date | string
  }

  export type XPBalanceWhereInput = {
    AND?: XPBalanceWhereInput | XPBalanceWhereInput[]
    OR?: XPBalanceWhereInput[]
    NOT?: XPBalanceWhereInput | XPBalanceWhereInput[]
    id?: StringFilter<"XPBalance"> | string
    userId?: StringFilter<"XPBalance"> | string
    currentXP?: IntFilter<"XPBalance"> | number
    totalEarned?: IntFilter<"XPBalance"> | number
    totalSpent?: IntFilter<"XPBalance"> | number
    reserveXP?: IntFilter<"XPBalance"> | number
    pendingLoans?: IntFilter<"XPBalance"> | number
    createdAt?: DateTimeFilter<"XPBalance"> | Date | string
    updatedAt?: DateTimeFilter<"XPBalance"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type XPBalanceOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    currentXP?: SortOrder
    totalEarned?: SortOrder
    totalSpent?: SortOrder
    reserveXP?: SortOrder
    pendingLoans?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type XPBalanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: XPBalanceWhereInput | XPBalanceWhereInput[]
    OR?: XPBalanceWhereInput[]
    NOT?: XPBalanceWhereInput | XPBalanceWhereInput[]
    currentXP?: IntFilter<"XPBalance"> | number
    totalEarned?: IntFilter<"XPBalance"> | number
    totalSpent?: IntFilter<"XPBalance"> | number
    reserveXP?: IntFilter<"XPBalance"> | number
    pendingLoans?: IntFilter<"XPBalance"> | number
    createdAt?: DateTimeFilter<"XPBalance"> | Date | string
    updatedAt?: DateTimeFilter<"XPBalance"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type XPBalanceOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    currentXP?: SortOrder
    totalEarned?: SortOrder
    totalSpent?: SortOrder
    reserveXP?: SortOrder
    pendingLoans?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: XPBalanceCountOrderByAggregateInput
    _avg?: XPBalanceAvgOrderByAggregateInput
    _max?: XPBalanceMaxOrderByAggregateInput
    _min?: XPBalanceMinOrderByAggregateInput
    _sum?: XPBalanceSumOrderByAggregateInput
  }

  export type XPBalanceScalarWhereWithAggregatesInput = {
    AND?: XPBalanceScalarWhereWithAggregatesInput | XPBalanceScalarWhereWithAggregatesInput[]
    OR?: XPBalanceScalarWhereWithAggregatesInput[]
    NOT?: XPBalanceScalarWhereWithAggregatesInput | XPBalanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"XPBalance"> | string
    userId?: StringWithAggregatesFilter<"XPBalance"> | string
    currentXP?: IntWithAggregatesFilter<"XPBalance"> | number
    totalEarned?: IntWithAggregatesFilter<"XPBalance"> | number
    totalSpent?: IntWithAggregatesFilter<"XPBalance"> | number
    reserveXP?: IntWithAggregatesFilter<"XPBalance"> | number
    pendingLoans?: IntWithAggregatesFilter<"XPBalance"> | number
    createdAt?: DateTimeWithAggregatesFilter<"XPBalance"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"XPBalance"> | Date | string
  }

  export type XPPurchaseWhereInput = {
    AND?: XPPurchaseWhereInput | XPPurchaseWhereInput[]
    OR?: XPPurchaseWhereInput[]
    NOT?: XPPurchaseWhereInput | XPPurchaseWhereInput[]
    id?: StringFilter<"XPPurchase"> | string
    userId?: StringFilter<"XPPurchase"> | string
    rewardId?: StringFilter<"XPPurchase"> | string
    xpSpent?: IntFilter<"XPPurchase"> | number
    actualPrice?: IntFilter<"XPPurchase"> | number
    purchaseType?: StringFilter<"XPPurchase"> | string
    notes?: StringNullableFilter<"XPPurchase"> | string | null
    satisfactionRating?: IntNullableFilter<"XPPurchase"> | number | null
    guiltLevel?: IntNullableFilter<"XPPurchase"> | number | null
    wasPlanned?: BoolFilter<"XPPurchase"> | boolean
    celebrationLevel?: StringNullableFilter<"XPPurchase"> | string | null
    createdAt?: DateTimeFilter<"XPPurchase"> | Date | string
    updatedAt?: DateTimeFilter<"XPPurchase"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    reward?: XOR<RewardDefinitionScalarRelationFilter, RewardDefinitionWhereInput>
  }

  export type XPPurchaseOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    rewardId?: SortOrder
    xpSpent?: SortOrder
    actualPrice?: SortOrder
    purchaseType?: SortOrder
    notes?: SortOrderInput | SortOrder
    satisfactionRating?: SortOrderInput | SortOrder
    guiltLevel?: SortOrderInput | SortOrder
    wasPlanned?: SortOrder
    celebrationLevel?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    reward?: RewardDefinitionOrderByWithRelationInput
  }

  export type XPPurchaseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: XPPurchaseWhereInput | XPPurchaseWhereInput[]
    OR?: XPPurchaseWhereInput[]
    NOT?: XPPurchaseWhereInput | XPPurchaseWhereInput[]
    userId?: StringFilter<"XPPurchase"> | string
    rewardId?: StringFilter<"XPPurchase"> | string
    xpSpent?: IntFilter<"XPPurchase"> | number
    actualPrice?: IntFilter<"XPPurchase"> | number
    purchaseType?: StringFilter<"XPPurchase"> | string
    notes?: StringNullableFilter<"XPPurchase"> | string | null
    satisfactionRating?: IntNullableFilter<"XPPurchase"> | number | null
    guiltLevel?: IntNullableFilter<"XPPurchase"> | number | null
    wasPlanned?: BoolFilter<"XPPurchase"> | boolean
    celebrationLevel?: StringNullableFilter<"XPPurchase"> | string | null
    createdAt?: DateTimeFilter<"XPPurchase"> | Date | string
    updatedAt?: DateTimeFilter<"XPPurchase"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    reward?: XOR<RewardDefinitionScalarRelationFilter, RewardDefinitionWhereInput>
  }, "id">

  export type XPPurchaseOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    rewardId?: SortOrder
    xpSpent?: SortOrder
    actualPrice?: SortOrder
    purchaseType?: SortOrder
    notes?: SortOrderInput | SortOrder
    satisfactionRating?: SortOrderInput | SortOrder
    guiltLevel?: SortOrderInput | SortOrder
    wasPlanned?: SortOrder
    celebrationLevel?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: XPPurchaseCountOrderByAggregateInput
    _avg?: XPPurchaseAvgOrderByAggregateInput
    _max?: XPPurchaseMaxOrderByAggregateInput
    _min?: XPPurchaseMinOrderByAggregateInput
    _sum?: XPPurchaseSumOrderByAggregateInput
  }

  export type XPPurchaseScalarWhereWithAggregatesInput = {
    AND?: XPPurchaseScalarWhereWithAggregatesInput | XPPurchaseScalarWhereWithAggregatesInput[]
    OR?: XPPurchaseScalarWhereWithAggregatesInput[]
    NOT?: XPPurchaseScalarWhereWithAggregatesInput | XPPurchaseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"XPPurchase"> | string
    userId?: StringWithAggregatesFilter<"XPPurchase"> | string
    rewardId?: StringWithAggregatesFilter<"XPPurchase"> | string
    xpSpent?: IntWithAggregatesFilter<"XPPurchase"> | number
    actualPrice?: IntWithAggregatesFilter<"XPPurchase"> | number
    purchaseType?: StringWithAggregatesFilter<"XPPurchase"> | string
    notes?: StringNullableWithAggregatesFilter<"XPPurchase"> | string | null
    satisfactionRating?: IntNullableWithAggregatesFilter<"XPPurchase"> | number | null
    guiltLevel?: IntNullableWithAggregatesFilter<"XPPurchase"> | number | null
    wasPlanned?: BoolWithAggregatesFilter<"XPPurchase"> | boolean
    celebrationLevel?: StringNullableWithAggregatesFilter<"XPPurchase"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"XPPurchase"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"XPPurchase"> | Date | string
  }

  export type XPEarningLogWhereInput = {
    AND?: XPEarningLogWhereInput | XPEarningLogWhereInput[]
    OR?: XPEarningLogWhereInput[]
    NOT?: XPEarningLogWhereInput | XPEarningLogWhereInput[]
    id?: StringFilter<"XPEarningLog"> | string
    userId?: StringFilter<"XPEarningLog"> | string
    source?: StringFilter<"XPEarningLog"> | string
    sourceId?: StringNullableFilter<"XPEarningLog"> | string | null
    baseXP?: IntFilter<"XPEarningLog"> | number
    finalXP?: IntFilter<"XPEarningLog"> | number
    multipliers?: JsonFilter<"XPEarningLog">
    createdAt?: DateTimeFilter<"XPEarningLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type XPEarningLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    source?: SortOrder
    sourceId?: SortOrderInput | SortOrder
    baseXP?: SortOrder
    finalXP?: SortOrder
    multipliers?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type XPEarningLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: XPEarningLogWhereInput | XPEarningLogWhereInput[]
    OR?: XPEarningLogWhereInput[]
    NOT?: XPEarningLogWhereInput | XPEarningLogWhereInput[]
    userId?: StringFilter<"XPEarningLog"> | string
    source?: StringFilter<"XPEarningLog"> | string
    sourceId?: StringNullableFilter<"XPEarningLog"> | string | null
    baseXP?: IntFilter<"XPEarningLog"> | number
    finalXP?: IntFilter<"XPEarningLog"> | number
    multipliers?: JsonFilter<"XPEarningLog">
    createdAt?: DateTimeFilter<"XPEarningLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type XPEarningLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    source?: SortOrder
    sourceId?: SortOrderInput | SortOrder
    baseXP?: SortOrder
    finalXP?: SortOrder
    multipliers?: SortOrder
    createdAt?: SortOrder
    _count?: XPEarningLogCountOrderByAggregateInput
    _avg?: XPEarningLogAvgOrderByAggregateInput
    _max?: XPEarningLogMaxOrderByAggregateInput
    _min?: XPEarningLogMinOrderByAggregateInput
    _sum?: XPEarningLogSumOrderByAggregateInput
  }

  export type XPEarningLogScalarWhereWithAggregatesInput = {
    AND?: XPEarningLogScalarWhereWithAggregatesInput | XPEarningLogScalarWhereWithAggregatesInput[]
    OR?: XPEarningLogScalarWhereWithAggregatesInput[]
    NOT?: XPEarningLogScalarWhereWithAggregatesInput | XPEarningLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"XPEarningLog"> | string
    userId?: StringWithAggregatesFilter<"XPEarningLog"> | string
    source?: StringWithAggregatesFilter<"XPEarningLog"> | string
    sourceId?: StringNullableWithAggregatesFilter<"XPEarningLog"> | string | null
    baseXP?: IntWithAggregatesFilter<"XPEarningLog"> | number
    finalXP?: IntWithAggregatesFilter<"XPEarningLog"> | number
    multipliers?: JsonWithAggregatesFilter<"XPEarningLog">
    createdAt?: DateTimeWithAggregatesFilter<"XPEarningLog"> | Date | string
  }

  export type RewardDefinitionWhereInput = {
    AND?: RewardDefinitionWhereInput | RewardDefinitionWhereInput[]
    OR?: RewardDefinitionWhereInput[]
    NOT?: RewardDefinitionWhereInput | RewardDefinitionWhereInput[]
    id?: StringFilter<"RewardDefinition"> | string
    category?: StringFilter<"RewardDefinition"> | string
    name?: StringFilter<"RewardDefinition"> | string
    description?: StringFilter<"RewardDefinition"> | string
    basePrice?: IntFilter<"RewardDefinition"> | number
    iconEmoji?: StringFilter<"RewardDefinition"> | string
    isActive?: BoolFilter<"RewardDefinition"> | boolean
    requiresStreak?: IntNullableFilter<"RewardDefinition"> | number | null
    maxDailyUse?: IntFilter<"RewardDefinition"> | number
    availabilityWindow?: StringNullableFilter<"RewardDefinition"> | string | null
    createdAt?: DateTimeFilter<"RewardDefinition"> | Date | string
    updatedAt?: DateTimeFilter<"RewardDefinition"> | Date | string
    purchases?: XPPurchaseListRelationFilter
  }

  export type RewardDefinitionOrderByWithRelationInput = {
    id?: SortOrder
    category?: SortOrder
    name?: SortOrder
    description?: SortOrder
    basePrice?: SortOrder
    iconEmoji?: SortOrder
    isActive?: SortOrder
    requiresStreak?: SortOrderInput | SortOrder
    maxDailyUse?: SortOrder
    availabilityWindow?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    purchases?: XPPurchaseOrderByRelationAggregateInput
  }

  export type RewardDefinitionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RewardDefinitionWhereInput | RewardDefinitionWhereInput[]
    OR?: RewardDefinitionWhereInput[]
    NOT?: RewardDefinitionWhereInput | RewardDefinitionWhereInput[]
    category?: StringFilter<"RewardDefinition"> | string
    name?: StringFilter<"RewardDefinition"> | string
    description?: StringFilter<"RewardDefinition"> | string
    basePrice?: IntFilter<"RewardDefinition"> | number
    iconEmoji?: StringFilter<"RewardDefinition"> | string
    isActive?: BoolFilter<"RewardDefinition"> | boolean
    requiresStreak?: IntNullableFilter<"RewardDefinition"> | number | null
    maxDailyUse?: IntFilter<"RewardDefinition"> | number
    availabilityWindow?: StringNullableFilter<"RewardDefinition"> | string | null
    createdAt?: DateTimeFilter<"RewardDefinition"> | Date | string
    updatedAt?: DateTimeFilter<"RewardDefinition"> | Date | string
    purchases?: XPPurchaseListRelationFilter
  }, "id">

  export type RewardDefinitionOrderByWithAggregationInput = {
    id?: SortOrder
    category?: SortOrder
    name?: SortOrder
    description?: SortOrder
    basePrice?: SortOrder
    iconEmoji?: SortOrder
    isActive?: SortOrder
    requiresStreak?: SortOrderInput | SortOrder
    maxDailyUse?: SortOrder
    availabilityWindow?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RewardDefinitionCountOrderByAggregateInput
    _avg?: RewardDefinitionAvgOrderByAggregateInput
    _max?: RewardDefinitionMaxOrderByAggregateInput
    _min?: RewardDefinitionMinOrderByAggregateInput
    _sum?: RewardDefinitionSumOrderByAggregateInput
  }

  export type RewardDefinitionScalarWhereWithAggregatesInput = {
    AND?: RewardDefinitionScalarWhereWithAggregatesInput | RewardDefinitionScalarWhereWithAggregatesInput[]
    OR?: RewardDefinitionScalarWhereWithAggregatesInput[]
    NOT?: RewardDefinitionScalarWhereWithAggregatesInput | RewardDefinitionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RewardDefinition"> | string
    category?: StringWithAggregatesFilter<"RewardDefinition"> | string
    name?: StringWithAggregatesFilter<"RewardDefinition"> | string
    description?: StringWithAggregatesFilter<"RewardDefinition"> | string
    basePrice?: IntWithAggregatesFilter<"RewardDefinition"> | number
    iconEmoji?: StringWithAggregatesFilter<"RewardDefinition"> | string
    isActive?: BoolWithAggregatesFilter<"RewardDefinition"> | boolean
    requiresStreak?: IntNullableWithAggregatesFilter<"RewardDefinition"> | number | null
    maxDailyUse?: IntWithAggregatesFilter<"RewardDefinition"> | number
    availabilityWindow?: StringNullableWithAggregatesFilter<"RewardDefinition"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"RewardDefinition"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RewardDefinition"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    supabaseId: string
    email: string
    displayName?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    lightWorkTasks?: LightWorkTaskCreateNestedManyWithoutUserInput
    deepWorkTasks?: DeepWorkTaskCreateNestedManyWithoutUserInput
    personalContext?: PersonalContextCreateNestedManyWithoutUserInput
    automationTasks?: AutomationTaskCreateNestedManyWithoutUserInput
    dailyHabits?: DailyHabitsCreateNestedManyWithoutUserInput
    dailyHealth?: DailyHealthCreateNestedManyWithoutUserInput
    dailyWorkout?: DailyWorkoutCreateNestedManyWithoutUserInput
    dailyRoutine?: DailyRoutineCreateNestedManyWithoutUserInput
    dailyReflections?: DailyReflectionsCreateNestedManyWithoutUserInput
    timeBlocks?: TimeBlockCreateNestedManyWithoutUserInput
    userProgress?: UserProgressCreateNestedManyWithoutUserInput
    xpBalance?: XPBalanceCreateNestedManyWithoutUserInput
    xpPurchases?: XPPurchaseCreateNestedManyWithoutUserInput
    xpEarningLog?: XPEarningLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    supabaseId: string
    email: string
    displayName?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    lightWorkTasks?: LightWorkTaskUncheckedCreateNestedManyWithoutUserInput
    deepWorkTasks?: DeepWorkTaskUncheckedCreateNestedManyWithoutUserInput
    personalContext?: PersonalContextUncheckedCreateNestedManyWithoutUserInput
    automationTasks?: AutomationTaskUncheckedCreateNestedManyWithoutUserInput
    dailyHabits?: DailyHabitsUncheckedCreateNestedManyWithoutUserInput
    dailyHealth?: DailyHealthUncheckedCreateNestedManyWithoutUserInput
    dailyWorkout?: DailyWorkoutUncheckedCreateNestedManyWithoutUserInput
    dailyRoutine?: DailyRoutineUncheckedCreateNestedManyWithoutUserInput
    dailyReflections?: DailyReflectionsUncheckedCreateNestedManyWithoutUserInput
    timeBlocks?: TimeBlockUncheckedCreateNestedManyWithoutUserInput
    userProgress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    xpBalance?: XPBalanceUncheckedCreateNestedManyWithoutUserInput
    xpPurchases?: XPPurchaseUncheckedCreateNestedManyWithoutUserInput
    xpEarningLog?: XPEarningLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lightWorkTasks?: LightWorkTaskUpdateManyWithoutUserNestedInput
    deepWorkTasks?: DeepWorkTaskUpdateManyWithoutUserNestedInput
    personalContext?: PersonalContextUpdateManyWithoutUserNestedInput
    automationTasks?: AutomationTaskUpdateManyWithoutUserNestedInput
    dailyHabits?: DailyHabitsUpdateManyWithoutUserNestedInput
    dailyHealth?: DailyHealthUpdateManyWithoutUserNestedInput
    dailyWorkout?: DailyWorkoutUpdateManyWithoutUserNestedInput
    dailyRoutine?: DailyRoutineUpdateManyWithoutUserNestedInput
    dailyReflections?: DailyReflectionsUpdateManyWithoutUserNestedInput
    timeBlocks?: TimeBlockUpdateManyWithoutUserNestedInput
    userProgress?: UserProgressUpdateManyWithoutUserNestedInput
    xpBalance?: XPBalanceUpdateManyWithoutUserNestedInput
    xpPurchases?: XPPurchaseUpdateManyWithoutUserNestedInput
    xpEarningLog?: XPEarningLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lightWorkTasks?: LightWorkTaskUncheckedUpdateManyWithoutUserNestedInput
    deepWorkTasks?: DeepWorkTaskUncheckedUpdateManyWithoutUserNestedInput
    personalContext?: PersonalContextUncheckedUpdateManyWithoutUserNestedInput
    automationTasks?: AutomationTaskUncheckedUpdateManyWithoutUserNestedInput
    dailyHabits?: DailyHabitsUncheckedUpdateManyWithoutUserNestedInput
    dailyHealth?: DailyHealthUncheckedUpdateManyWithoutUserNestedInput
    dailyWorkout?: DailyWorkoutUncheckedUpdateManyWithoutUserNestedInput
    dailyRoutine?: DailyRoutineUncheckedUpdateManyWithoutUserNestedInput
    dailyReflections?: DailyReflectionsUncheckedUpdateManyWithoutUserNestedInput
    timeBlocks?: TimeBlockUncheckedUpdateManyWithoutUserNestedInput
    userProgress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    xpBalance?: XPBalanceUncheckedUpdateManyWithoutUserNestedInput
    xpPurchases?: XPPurchaseUncheckedUpdateManyWithoutUserNestedInput
    xpEarningLog?: XPEarningLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    supabaseId: string
    email: string
    displayName?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LightWorkTaskCreateInput = {
    id?: string
    title: string
    description?: string | null
    priority?: $Enums.Priority
    completed?: boolean
    originalDate: string
    currentDate: string
    estimatedDuration?: number | null
    rollovers?: number
    tags?: LightWorkTaskCreatetagsInput | string[]
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    startedAt?: Date | string | null
    actualDurationMin?: number | null
    timeEstimate?: string | null
    aiAnalyzed?: boolean
    aiReasoning?: string | null
    analyzedAt?: Date | string | null
    xpReward?: number | null
    complexity?: number | null
    confidence?: number | null
    contextualBonus?: number | null
    difficulty?: number | null
    learningValue?: number | null
    priorityRank?: number | null
    strategicImportance?: number | null
    timeAccuracy?: number | null
    user: UserCreateNestedOneWithoutLightWorkTasksInput
    subtasks?: LightWorkSubtaskCreateNestedManyWithoutTaskInput
  }

  export type LightWorkTaskUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    description?: string | null
    priority?: $Enums.Priority
    completed?: boolean
    originalDate: string
    currentDate: string
    estimatedDuration?: number | null
    rollovers?: number
    tags?: LightWorkTaskCreatetagsInput | string[]
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    startedAt?: Date | string | null
    actualDurationMin?: number | null
    timeEstimate?: string | null
    aiAnalyzed?: boolean
    aiReasoning?: string | null
    analyzedAt?: Date | string | null
    xpReward?: number | null
    complexity?: number | null
    confidence?: number | null
    contextualBonus?: number | null
    difficulty?: number | null
    learningValue?: number | null
    priorityRank?: number | null
    strategicImportance?: number | null
    timeAccuracy?: number | null
    subtasks?: LightWorkSubtaskUncheckedCreateNestedManyWithoutTaskInput
  }

  export type LightWorkTaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    completed?: BoolFieldUpdateOperationsInput | boolean
    originalDate?: StringFieldUpdateOperationsInput | string
    currentDate?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    rollovers?: IntFieldUpdateOperationsInput | number
    tags?: LightWorkTaskUpdatetagsInput | string[]
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDurationMin?: NullableIntFieldUpdateOperationsInput | number | null
    timeEstimate?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalyzed?: BoolFieldUpdateOperationsInput | boolean
    aiReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    analyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    xpReward?: NullableIntFieldUpdateOperationsInput | number | null
    complexity?: NullableIntFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    contextualBonus?: NullableFloatFieldUpdateOperationsInput | number | null
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    learningValue?: NullableIntFieldUpdateOperationsInput | number | null
    priorityRank?: NullableIntFieldUpdateOperationsInput | number | null
    strategicImportance?: NullableIntFieldUpdateOperationsInput | number | null
    timeAccuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    user?: UserUpdateOneRequiredWithoutLightWorkTasksNestedInput
    subtasks?: LightWorkSubtaskUpdateManyWithoutTaskNestedInput
  }

  export type LightWorkTaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    completed?: BoolFieldUpdateOperationsInput | boolean
    originalDate?: StringFieldUpdateOperationsInput | string
    currentDate?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    rollovers?: IntFieldUpdateOperationsInput | number
    tags?: LightWorkTaskUpdatetagsInput | string[]
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDurationMin?: NullableIntFieldUpdateOperationsInput | number | null
    timeEstimate?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalyzed?: BoolFieldUpdateOperationsInput | boolean
    aiReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    analyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    xpReward?: NullableIntFieldUpdateOperationsInput | number | null
    complexity?: NullableIntFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    contextualBonus?: NullableFloatFieldUpdateOperationsInput | number | null
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    learningValue?: NullableIntFieldUpdateOperationsInput | number | null
    priorityRank?: NullableIntFieldUpdateOperationsInput | number | null
    strategicImportance?: NullableIntFieldUpdateOperationsInput | number | null
    timeAccuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    subtasks?: LightWorkSubtaskUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type LightWorkTaskCreateManyInput = {
    id?: string
    userId: string
    title: string
    description?: string | null
    priority?: $Enums.Priority
    completed?: boolean
    originalDate: string
    currentDate: string
    estimatedDuration?: number | null
    rollovers?: number
    tags?: LightWorkTaskCreatetagsInput | string[]
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    startedAt?: Date | string | null
    actualDurationMin?: number | null
    timeEstimate?: string | null
    aiAnalyzed?: boolean
    aiReasoning?: string | null
    analyzedAt?: Date | string | null
    xpReward?: number | null
    complexity?: number | null
    confidence?: number | null
    contextualBonus?: number | null
    difficulty?: number | null
    learningValue?: number | null
    priorityRank?: number | null
    strategicImportance?: number | null
    timeAccuracy?: number | null
  }

  export type LightWorkTaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    completed?: BoolFieldUpdateOperationsInput | boolean
    originalDate?: StringFieldUpdateOperationsInput | string
    currentDate?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    rollovers?: IntFieldUpdateOperationsInput | number
    tags?: LightWorkTaskUpdatetagsInput | string[]
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDurationMin?: NullableIntFieldUpdateOperationsInput | number | null
    timeEstimate?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalyzed?: BoolFieldUpdateOperationsInput | boolean
    aiReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    analyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    xpReward?: NullableIntFieldUpdateOperationsInput | number | null
    complexity?: NullableIntFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    contextualBonus?: NullableFloatFieldUpdateOperationsInput | number | null
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    learningValue?: NullableIntFieldUpdateOperationsInput | number | null
    priorityRank?: NullableIntFieldUpdateOperationsInput | number | null
    strategicImportance?: NullableIntFieldUpdateOperationsInput | number | null
    timeAccuracy?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type LightWorkTaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    completed?: BoolFieldUpdateOperationsInput | boolean
    originalDate?: StringFieldUpdateOperationsInput | string
    currentDate?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    rollovers?: IntFieldUpdateOperationsInput | number
    tags?: LightWorkTaskUpdatetagsInput | string[]
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDurationMin?: NullableIntFieldUpdateOperationsInput | number | null
    timeEstimate?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalyzed?: BoolFieldUpdateOperationsInput | boolean
    aiReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    analyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    xpReward?: NullableIntFieldUpdateOperationsInput | number | null
    complexity?: NullableIntFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    contextualBonus?: NullableFloatFieldUpdateOperationsInput | number | null
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    learningValue?: NullableIntFieldUpdateOperationsInput | number | null
    priorityRank?: NullableIntFieldUpdateOperationsInput | number | null
    strategicImportance?: NullableIntFieldUpdateOperationsInput | number | null
    timeAccuracy?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type LightWorkSubtaskCreateInput = {
    id?: string
    title: string
    text: string
    completed?: boolean
    priority?: string | null
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    startedAt?: Date | string | null
    actualDurationMin?: number | null
    timeAccuracy?: number | null
    aiAnalyzed?: boolean
    aiReasoning?: string | null
    analyzedAt?: Date | string | null
    xpReward?: number | null
    complexity?: number | null
    confidence?: number | null
    contextualBonus?: number | null
    difficulty?: number | null
    learningValue?: number | null
    priorityRank?: number | null
    strategicImportance?: number | null
    task: LightWorkTaskCreateNestedOneWithoutSubtasksInput
  }

  export type LightWorkSubtaskUncheckedCreateInput = {
    id?: string
    taskId: string
    title: string
    text: string
    completed?: boolean
    priority?: string | null
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    startedAt?: Date | string | null
    actualDurationMin?: number | null
    timeAccuracy?: number | null
    aiAnalyzed?: boolean
    aiReasoning?: string | null
    analyzedAt?: Date | string | null
    xpReward?: number | null
    complexity?: number | null
    confidence?: number | null
    contextualBonus?: number | null
    difficulty?: number | null
    learningValue?: number | null
    priorityRank?: number | null
    strategicImportance?: number | null
  }

  export type LightWorkSubtaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDurationMin?: NullableIntFieldUpdateOperationsInput | number | null
    timeAccuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    aiAnalyzed?: BoolFieldUpdateOperationsInput | boolean
    aiReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    analyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    xpReward?: NullableIntFieldUpdateOperationsInput | number | null
    complexity?: NullableIntFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    contextualBonus?: NullableFloatFieldUpdateOperationsInput | number | null
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    learningValue?: NullableIntFieldUpdateOperationsInput | number | null
    priorityRank?: NullableIntFieldUpdateOperationsInput | number | null
    strategicImportance?: NullableIntFieldUpdateOperationsInput | number | null
    task?: LightWorkTaskUpdateOneRequiredWithoutSubtasksNestedInput
  }

  export type LightWorkSubtaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDurationMin?: NullableIntFieldUpdateOperationsInput | number | null
    timeAccuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    aiAnalyzed?: BoolFieldUpdateOperationsInput | boolean
    aiReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    analyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    xpReward?: NullableIntFieldUpdateOperationsInput | number | null
    complexity?: NullableIntFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    contextualBonus?: NullableFloatFieldUpdateOperationsInput | number | null
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    learningValue?: NullableIntFieldUpdateOperationsInput | number | null
    priorityRank?: NullableIntFieldUpdateOperationsInput | number | null
    strategicImportance?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LightWorkSubtaskCreateManyInput = {
    id?: string
    taskId: string
    title: string
    text: string
    completed?: boolean
    priority?: string | null
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    startedAt?: Date | string | null
    actualDurationMin?: number | null
    timeAccuracy?: number | null
    aiAnalyzed?: boolean
    aiReasoning?: string | null
    analyzedAt?: Date | string | null
    xpReward?: number | null
    complexity?: number | null
    confidence?: number | null
    contextualBonus?: number | null
    difficulty?: number | null
    learningValue?: number | null
    priorityRank?: number | null
    strategicImportance?: number | null
  }

  export type LightWorkSubtaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDurationMin?: NullableIntFieldUpdateOperationsInput | number | null
    timeAccuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    aiAnalyzed?: BoolFieldUpdateOperationsInput | boolean
    aiReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    analyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    xpReward?: NullableIntFieldUpdateOperationsInput | number | null
    complexity?: NullableIntFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    contextualBonus?: NullableFloatFieldUpdateOperationsInput | number | null
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    learningValue?: NullableIntFieldUpdateOperationsInput | number | null
    priorityRank?: NullableIntFieldUpdateOperationsInput | number | null
    strategicImportance?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LightWorkSubtaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDurationMin?: NullableIntFieldUpdateOperationsInput | number | null
    timeAccuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    aiAnalyzed?: BoolFieldUpdateOperationsInput | boolean
    aiReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    analyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    xpReward?: NullableIntFieldUpdateOperationsInput | number | null
    complexity?: NullableIntFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    contextualBonus?: NullableFloatFieldUpdateOperationsInput | number | null
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    learningValue?: NullableIntFieldUpdateOperationsInput | number | null
    priorityRank?: NullableIntFieldUpdateOperationsInput | number | null
    strategicImportance?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DeepWorkTaskCreateInput = {
    id?: string
    title: string
    description?: string | null
    priority?: $Enums.Priority
    completed?: boolean
    originalDate: string
    currentDate: string
    estimatedDuration?: number | null
    focusBlocks?: number
    breakDuration?: number
    interruptionMode?: boolean
    rollovers?: number
    tags?: DeepWorkTaskCreatetagsInput | string[]
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    startedAt?: Date | string | null
    actualDurationMin?: number | null
    timeEstimate?: string | null
    aiAnalyzed?: boolean
    aiReasoning?: string | null
    analyzedAt?: Date | string | null
    xpReward?: number | null
    complexity?: number | null
    confidence?: number | null
    contextualBonus?: number | null
    difficulty?: number | null
    learningValue?: number | null
    priorityRank?: number | null
    strategicImportance?: number | null
    timeAccuracy?: number | null
    user: UserCreateNestedOneWithoutDeepWorkTasksInput
    subtasks?: DeepWorkSubtaskCreateNestedManyWithoutTaskInput
  }

  export type DeepWorkTaskUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    description?: string | null
    priority?: $Enums.Priority
    completed?: boolean
    originalDate: string
    currentDate: string
    estimatedDuration?: number | null
    focusBlocks?: number
    breakDuration?: number
    interruptionMode?: boolean
    rollovers?: number
    tags?: DeepWorkTaskCreatetagsInput | string[]
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    startedAt?: Date | string | null
    actualDurationMin?: number | null
    timeEstimate?: string | null
    aiAnalyzed?: boolean
    aiReasoning?: string | null
    analyzedAt?: Date | string | null
    xpReward?: number | null
    complexity?: number | null
    confidence?: number | null
    contextualBonus?: number | null
    difficulty?: number | null
    learningValue?: number | null
    priorityRank?: number | null
    strategicImportance?: number | null
    timeAccuracy?: number | null
    subtasks?: DeepWorkSubtaskUncheckedCreateNestedManyWithoutTaskInput
  }

  export type DeepWorkTaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    completed?: BoolFieldUpdateOperationsInput | boolean
    originalDate?: StringFieldUpdateOperationsInput | string
    currentDate?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    focusBlocks?: IntFieldUpdateOperationsInput | number
    breakDuration?: IntFieldUpdateOperationsInput | number
    interruptionMode?: BoolFieldUpdateOperationsInput | boolean
    rollovers?: IntFieldUpdateOperationsInput | number
    tags?: DeepWorkTaskUpdatetagsInput | string[]
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDurationMin?: NullableIntFieldUpdateOperationsInput | number | null
    timeEstimate?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalyzed?: BoolFieldUpdateOperationsInput | boolean
    aiReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    analyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    xpReward?: NullableIntFieldUpdateOperationsInput | number | null
    complexity?: NullableIntFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    contextualBonus?: NullableFloatFieldUpdateOperationsInput | number | null
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    learningValue?: NullableIntFieldUpdateOperationsInput | number | null
    priorityRank?: NullableIntFieldUpdateOperationsInput | number | null
    strategicImportance?: NullableIntFieldUpdateOperationsInput | number | null
    timeAccuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    user?: UserUpdateOneRequiredWithoutDeepWorkTasksNestedInput
    subtasks?: DeepWorkSubtaskUpdateManyWithoutTaskNestedInput
  }

  export type DeepWorkTaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    completed?: BoolFieldUpdateOperationsInput | boolean
    originalDate?: StringFieldUpdateOperationsInput | string
    currentDate?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    focusBlocks?: IntFieldUpdateOperationsInput | number
    breakDuration?: IntFieldUpdateOperationsInput | number
    interruptionMode?: BoolFieldUpdateOperationsInput | boolean
    rollovers?: IntFieldUpdateOperationsInput | number
    tags?: DeepWorkTaskUpdatetagsInput | string[]
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDurationMin?: NullableIntFieldUpdateOperationsInput | number | null
    timeEstimate?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalyzed?: BoolFieldUpdateOperationsInput | boolean
    aiReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    analyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    xpReward?: NullableIntFieldUpdateOperationsInput | number | null
    complexity?: NullableIntFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    contextualBonus?: NullableFloatFieldUpdateOperationsInput | number | null
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    learningValue?: NullableIntFieldUpdateOperationsInput | number | null
    priorityRank?: NullableIntFieldUpdateOperationsInput | number | null
    strategicImportance?: NullableIntFieldUpdateOperationsInput | number | null
    timeAccuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    subtasks?: DeepWorkSubtaskUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type DeepWorkTaskCreateManyInput = {
    id?: string
    userId: string
    title: string
    description?: string | null
    priority?: $Enums.Priority
    completed?: boolean
    originalDate: string
    currentDate: string
    estimatedDuration?: number | null
    focusBlocks?: number
    breakDuration?: number
    interruptionMode?: boolean
    rollovers?: number
    tags?: DeepWorkTaskCreatetagsInput | string[]
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    startedAt?: Date | string | null
    actualDurationMin?: number | null
    timeEstimate?: string | null
    aiAnalyzed?: boolean
    aiReasoning?: string | null
    analyzedAt?: Date | string | null
    xpReward?: number | null
    complexity?: number | null
    confidence?: number | null
    contextualBonus?: number | null
    difficulty?: number | null
    learningValue?: number | null
    priorityRank?: number | null
    strategicImportance?: number | null
    timeAccuracy?: number | null
  }

  export type DeepWorkTaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    completed?: BoolFieldUpdateOperationsInput | boolean
    originalDate?: StringFieldUpdateOperationsInput | string
    currentDate?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    focusBlocks?: IntFieldUpdateOperationsInput | number
    breakDuration?: IntFieldUpdateOperationsInput | number
    interruptionMode?: BoolFieldUpdateOperationsInput | boolean
    rollovers?: IntFieldUpdateOperationsInput | number
    tags?: DeepWorkTaskUpdatetagsInput | string[]
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDurationMin?: NullableIntFieldUpdateOperationsInput | number | null
    timeEstimate?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalyzed?: BoolFieldUpdateOperationsInput | boolean
    aiReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    analyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    xpReward?: NullableIntFieldUpdateOperationsInput | number | null
    complexity?: NullableIntFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    contextualBonus?: NullableFloatFieldUpdateOperationsInput | number | null
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    learningValue?: NullableIntFieldUpdateOperationsInput | number | null
    priorityRank?: NullableIntFieldUpdateOperationsInput | number | null
    strategicImportance?: NullableIntFieldUpdateOperationsInput | number | null
    timeAccuracy?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type DeepWorkTaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    completed?: BoolFieldUpdateOperationsInput | boolean
    originalDate?: StringFieldUpdateOperationsInput | string
    currentDate?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    focusBlocks?: IntFieldUpdateOperationsInput | number
    breakDuration?: IntFieldUpdateOperationsInput | number
    interruptionMode?: BoolFieldUpdateOperationsInput | boolean
    rollovers?: IntFieldUpdateOperationsInput | number
    tags?: DeepWorkTaskUpdatetagsInput | string[]
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDurationMin?: NullableIntFieldUpdateOperationsInput | number | null
    timeEstimate?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalyzed?: BoolFieldUpdateOperationsInput | boolean
    aiReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    analyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    xpReward?: NullableIntFieldUpdateOperationsInput | number | null
    complexity?: NullableIntFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    contextualBonus?: NullableFloatFieldUpdateOperationsInput | number | null
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    learningValue?: NullableIntFieldUpdateOperationsInput | number | null
    priorityRank?: NullableIntFieldUpdateOperationsInput | number | null
    strategicImportance?: NullableIntFieldUpdateOperationsInput | number | null
    timeAccuracy?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type DeepWorkSubtaskCreateInput = {
    id?: string
    title: string
    text: string
    completed?: boolean
    priority?: string | null
    dueDate?: Date | string | null
    requiresFocus?: boolean
    complexityLevel?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    startedAt?: Date | string | null
    actualDurationMin?: number | null
    timeAccuracy?: number | null
    aiAnalyzed?: boolean
    aiReasoning?: string | null
    analyzedAt?: Date | string | null
    xpReward?: number | null
    complexity?: number | null
    confidence?: number | null
    contextualBonus?: number | null
    difficulty?: number | null
    learningValue?: number | null
    priorityRank?: number | null
    strategicImportance?: number | null
    task: DeepWorkTaskCreateNestedOneWithoutSubtasksInput
  }

  export type DeepWorkSubtaskUncheckedCreateInput = {
    id?: string
    taskId: string
    title: string
    text: string
    completed?: boolean
    priority?: string | null
    dueDate?: Date | string | null
    requiresFocus?: boolean
    complexityLevel?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    startedAt?: Date | string | null
    actualDurationMin?: number | null
    timeAccuracy?: number | null
    aiAnalyzed?: boolean
    aiReasoning?: string | null
    analyzedAt?: Date | string | null
    xpReward?: number | null
    complexity?: number | null
    confidence?: number | null
    contextualBonus?: number | null
    difficulty?: number | null
    learningValue?: number | null
    priorityRank?: number | null
    strategicImportance?: number | null
  }

  export type DeepWorkSubtaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requiresFocus?: BoolFieldUpdateOperationsInput | boolean
    complexityLevel?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDurationMin?: NullableIntFieldUpdateOperationsInput | number | null
    timeAccuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    aiAnalyzed?: BoolFieldUpdateOperationsInput | boolean
    aiReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    analyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    xpReward?: NullableIntFieldUpdateOperationsInput | number | null
    complexity?: NullableIntFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    contextualBonus?: NullableFloatFieldUpdateOperationsInput | number | null
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    learningValue?: NullableIntFieldUpdateOperationsInput | number | null
    priorityRank?: NullableIntFieldUpdateOperationsInput | number | null
    strategicImportance?: NullableIntFieldUpdateOperationsInput | number | null
    task?: DeepWorkTaskUpdateOneRequiredWithoutSubtasksNestedInput
  }

  export type DeepWorkSubtaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requiresFocus?: BoolFieldUpdateOperationsInput | boolean
    complexityLevel?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDurationMin?: NullableIntFieldUpdateOperationsInput | number | null
    timeAccuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    aiAnalyzed?: BoolFieldUpdateOperationsInput | boolean
    aiReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    analyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    xpReward?: NullableIntFieldUpdateOperationsInput | number | null
    complexity?: NullableIntFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    contextualBonus?: NullableFloatFieldUpdateOperationsInput | number | null
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    learningValue?: NullableIntFieldUpdateOperationsInput | number | null
    priorityRank?: NullableIntFieldUpdateOperationsInput | number | null
    strategicImportance?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DeepWorkSubtaskCreateManyInput = {
    id?: string
    taskId: string
    title: string
    text: string
    completed?: boolean
    priority?: string | null
    dueDate?: Date | string | null
    requiresFocus?: boolean
    complexityLevel?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    startedAt?: Date | string | null
    actualDurationMin?: number | null
    timeAccuracy?: number | null
    aiAnalyzed?: boolean
    aiReasoning?: string | null
    analyzedAt?: Date | string | null
    xpReward?: number | null
    complexity?: number | null
    confidence?: number | null
    contextualBonus?: number | null
    difficulty?: number | null
    learningValue?: number | null
    priorityRank?: number | null
    strategicImportance?: number | null
  }

  export type DeepWorkSubtaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requiresFocus?: BoolFieldUpdateOperationsInput | boolean
    complexityLevel?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDurationMin?: NullableIntFieldUpdateOperationsInput | number | null
    timeAccuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    aiAnalyzed?: BoolFieldUpdateOperationsInput | boolean
    aiReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    analyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    xpReward?: NullableIntFieldUpdateOperationsInput | number | null
    complexity?: NullableIntFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    contextualBonus?: NullableFloatFieldUpdateOperationsInput | number | null
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    learningValue?: NullableIntFieldUpdateOperationsInput | number | null
    priorityRank?: NullableIntFieldUpdateOperationsInput | number | null
    strategicImportance?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DeepWorkSubtaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requiresFocus?: BoolFieldUpdateOperationsInput | boolean
    complexityLevel?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDurationMin?: NullableIntFieldUpdateOperationsInput | number | null
    timeAccuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    aiAnalyzed?: BoolFieldUpdateOperationsInput | boolean
    aiReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    analyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    xpReward?: NullableIntFieldUpdateOperationsInput | number | null
    complexity?: NullableIntFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    contextualBonus?: NullableFloatFieldUpdateOperationsInput | number | null
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    learningValue?: NullableIntFieldUpdateOperationsInput | number | null
    priorityRank?: NullableIntFieldUpdateOperationsInput | number | null
    strategicImportance?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AutomationTaskCreateInput = {
    id?: string
    name: string
    description?: string | null
    category: $Enums.AutomationCategory
    priority: $Enums.Priority
    status?: $Enums.AutomationStatus
    prompt: string
    allowedTools?: JsonNullValueInput | InputJsonValue
    estimatedTokens?: number
    actualTokens?: number | null
    executionTimeMs?: number | null
    result?: string | null
    error?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    user: UserCreateNestedOneWithoutAutomationTasksInput
  }

  export type AutomationTaskUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    category: $Enums.AutomationCategory
    priority: $Enums.Priority
    status?: $Enums.AutomationStatus
    prompt: string
    allowedTools?: JsonNullValueInput | InputJsonValue
    estimatedTokens?: number
    actualTokens?: number | null
    executionTimeMs?: number | null
    result?: string | null
    error?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type AutomationTaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumAutomationCategoryFieldUpdateOperationsInput | $Enums.AutomationCategory
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumAutomationStatusFieldUpdateOperationsInput | $Enums.AutomationStatus
    prompt?: StringFieldUpdateOperationsInput | string
    allowedTools?: JsonNullValueInput | InputJsonValue
    estimatedTokens?: IntFieldUpdateOperationsInput | number
    actualTokens?: NullableIntFieldUpdateOperationsInput | number | null
    executionTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutAutomationTasksNestedInput
  }

  export type AutomationTaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumAutomationCategoryFieldUpdateOperationsInput | $Enums.AutomationCategory
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumAutomationStatusFieldUpdateOperationsInput | $Enums.AutomationStatus
    prompt?: StringFieldUpdateOperationsInput | string
    allowedTools?: JsonNullValueInput | InputJsonValue
    estimatedTokens?: IntFieldUpdateOperationsInput | number
    actualTokens?: NullableIntFieldUpdateOperationsInput | number | null
    executionTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AutomationTaskCreateManyInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    category: $Enums.AutomationCategory
    priority: $Enums.Priority
    status?: $Enums.AutomationStatus
    prompt: string
    allowedTools?: JsonNullValueInput | InputJsonValue
    estimatedTokens?: number
    actualTokens?: number | null
    executionTimeMs?: number | null
    result?: string | null
    error?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type AutomationTaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumAutomationCategoryFieldUpdateOperationsInput | $Enums.AutomationCategory
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumAutomationStatusFieldUpdateOperationsInput | $Enums.AutomationStatus
    prompt?: StringFieldUpdateOperationsInput | string
    allowedTools?: JsonNullValueInput | InputJsonValue
    estimatedTokens?: IntFieldUpdateOperationsInput | number
    actualTokens?: NullableIntFieldUpdateOperationsInput | number | null
    executionTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AutomationTaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumAutomationCategoryFieldUpdateOperationsInput | $Enums.AutomationCategory
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumAutomationStatusFieldUpdateOperationsInput | $Enums.AutomationStatus
    prompt?: StringFieldUpdateOperationsInput | string
    allowedTools?: JsonNullValueInput | InputJsonValue
    estimatedTokens?: IntFieldUpdateOperationsInput | number
    actualTokens?: NullableIntFieldUpdateOperationsInput | number | null
    executionTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DailyHabitsCreateInput = {
    id?: string
    date: string
    screenTimeMinutes?: number
    bullshitContentMinutes?: number
    noWeed?: boolean
    noScrolling?: boolean
    deepWorkHours?: number
    lightWorkHours?: number
    habitsData?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDailyHabitsInput
  }

  export type DailyHabitsUncheckedCreateInput = {
    id?: string
    userId: string
    date: string
    screenTimeMinutes?: number
    bullshitContentMinutes?: number
    noWeed?: boolean
    noScrolling?: boolean
    deepWorkHours?: number
    lightWorkHours?: number
    habitsData?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyHabitsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    screenTimeMinutes?: IntFieldUpdateOperationsInput | number
    bullshitContentMinutes?: IntFieldUpdateOperationsInput | number
    noWeed?: BoolFieldUpdateOperationsInput | boolean
    noScrolling?: BoolFieldUpdateOperationsInput | boolean
    deepWorkHours?: FloatFieldUpdateOperationsInput | number
    lightWorkHours?: FloatFieldUpdateOperationsInput | number
    habitsData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDailyHabitsNestedInput
  }

  export type DailyHabitsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    screenTimeMinutes?: IntFieldUpdateOperationsInput | number
    bullshitContentMinutes?: IntFieldUpdateOperationsInput | number
    noWeed?: BoolFieldUpdateOperationsInput | boolean
    noScrolling?: BoolFieldUpdateOperationsInput | boolean
    deepWorkHours?: FloatFieldUpdateOperationsInput | number
    lightWorkHours?: FloatFieldUpdateOperationsInput | number
    habitsData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyHabitsCreateManyInput = {
    id?: string
    userId: string
    date: string
    screenTimeMinutes?: number
    bullshitContentMinutes?: number
    noWeed?: boolean
    noScrolling?: boolean
    deepWorkHours?: number
    lightWorkHours?: number
    habitsData?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyHabitsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    screenTimeMinutes?: IntFieldUpdateOperationsInput | number
    bullshitContentMinutes?: IntFieldUpdateOperationsInput | number
    noWeed?: BoolFieldUpdateOperationsInput | boolean
    noScrolling?: BoolFieldUpdateOperationsInput | boolean
    deepWorkHours?: FloatFieldUpdateOperationsInput | number
    lightWorkHours?: FloatFieldUpdateOperationsInput | number
    habitsData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyHabitsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    screenTimeMinutes?: IntFieldUpdateOperationsInput | number
    bullshitContentMinutes?: IntFieldUpdateOperationsInput | number
    noWeed?: BoolFieldUpdateOperationsInput | boolean
    noScrolling?: BoolFieldUpdateOperationsInput | boolean
    deepWorkHours?: FloatFieldUpdateOperationsInput | number
    lightWorkHours?: FloatFieldUpdateOperationsInput | number
    habitsData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyHealthCreateInput = {
    id?: string
    date: string
    healthChecklist?: JsonNullValueInput | InputJsonValue
    meals?: JsonNullValueInput | InputJsonValue
    macros?: JsonNullValueInput | InputJsonValue
    waterIntakeMl?: number
    milkIntakeMl?: number
    sleepHours?: number
    energyLevel?: number | null
    moodLevel?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDailyHealthInput
  }

  export type DailyHealthUncheckedCreateInput = {
    id?: string
    userId: string
    date: string
    healthChecklist?: JsonNullValueInput | InputJsonValue
    meals?: JsonNullValueInput | InputJsonValue
    macros?: JsonNullValueInput | InputJsonValue
    waterIntakeMl?: number
    milkIntakeMl?: number
    sleepHours?: number
    energyLevel?: number | null
    moodLevel?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyHealthUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    healthChecklist?: JsonNullValueInput | InputJsonValue
    meals?: JsonNullValueInput | InputJsonValue
    macros?: JsonNullValueInput | InputJsonValue
    waterIntakeMl?: IntFieldUpdateOperationsInput | number
    milkIntakeMl?: IntFieldUpdateOperationsInput | number
    sleepHours?: FloatFieldUpdateOperationsInput | number
    energyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    moodLevel?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDailyHealthNestedInput
  }

  export type DailyHealthUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    healthChecklist?: JsonNullValueInput | InputJsonValue
    meals?: JsonNullValueInput | InputJsonValue
    macros?: JsonNullValueInput | InputJsonValue
    waterIntakeMl?: IntFieldUpdateOperationsInput | number
    milkIntakeMl?: IntFieldUpdateOperationsInput | number
    sleepHours?: FloatFieldUpdateOperationsInput | number
    energyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    moodLevel?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyHealthCreateManyInput = {
    id?: string
    userId: string
    date: string
    healthChecklist?: JsonNullValueInput | InputJsonValue
    meals?: JsonNullValueInput | InputJsonValue
    macros?: JsonNullValueInput | InputJsonValue
    waterIntakeMl?: number
    milkIntakeMl?: number
    sleepHours?: number
    energyLevel?: number | null
    moodLevel?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyHealthUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    healthChecklist?: JsonNullValueInput | InputJsonValue
    meals?: JsonNullValueInput | InputJsonValue
    macros?: JsonNullValueInput | InputJsonValue
    waterIntakeMl?: IntFieldUpdateOperationsInput | number
    milkIntakeMl?: IntFieldUpdateOperationsInput | number
    sleepHours?: FloatFieldUpdateOperationsInput | number
    energyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    moodLevel?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyHealthUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    healthChecklist?: JsonNullValueInput | InputJsonValue
    meals?: JsonNullValueInput | InputJsonValue
    macros?: JsonNullValueInput | InputJsonValue
    waterIntakeMl?: IntFieldUpdateOperationsInput | number
    milkIntakeMl?: IntFieldUpdateOperationsInput | number
    sleepHours?: FloatFieldUpdateOperationsInput | number
    energyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    moodLevel?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyWorkoutCreateInput = {
    id?: string
    date: string
    exercises?: JsonNullValueInput | InputJsonValue
    totalExercises?: number
    completedExercises?: number
    completionPercentage?: number
    durationMinutes?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDailyWorkoutInput
  }

  export type DailyWorkoutUncheckedCreateInput = {
    id?: string
    userId: string
    date: string
    exercises?: JsonNullValueInput | InputJsonValue
    totalExercises?: number
    completedExercises?: number
    completionPercentage?: number
    durationMinutes?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyWorkoutUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    exercises?: JsonNullValueInput | InputJsonValue
    totalExercises?: IntFieldUpdateOperationsInput | number
    completedExercises?: IntFieldUpdateOperationsInput | number
    completionPercentage?: FloatFieldUpdateOperationsInput | number
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDailyWorkoutNestedInput
  }

  export type DailyWorkoutUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    exercises?: JsonNullValueInput | InputJsonValue
    totalExercises?: IntFieldUpdateOperationsInput | number
    completedExercises?: IntFieldUpdateOperationsInput | number
    completionPercentage?: FloatFieldUpdateOperationsInput | number
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyWorkoutCreateManyInput = {
    id?: string
    userId: string
    date: string
    exercises?: JsonNullValueInput | InputJsonValue
    totalExercises?: number
    completedExercises?: number
    completionPercentage?: number
    durationMinutes?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyWorkoutUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    exercises?: JsonNullValueInput | InputJsonValue
    totalExercises?: IntFieldUpdateOperationsInput | number
    completedExercises?: IntFieldUpdateOperationsInput | number
    completionPercentage?: FloatFieldUpdateOperationsInput | number
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyWorkoutUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    exercises?: JsonNullValueInput | InputJsonValue
    totalExercises?: IntFieldUpdateOperationsInput | number
    completedExercises?: IntFieldUpdateOperationsInput | number
    completionPercentage?: FloatFieldUpdateOperationsInput | number
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyRoutineCreateInput = {
    id?: string
    date: string
    routineType: $Enums.RoutineType
    items?: JsonNullValueInput | InputJsonValue
    completedCount?: number
    totalCount?: number
    completionPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDailyRoutineInput
  }

  export type DailyRoutineUncheckedCreateInput = {
    id?: string
    userId: string
    date: string
    routineType: $Enums.RoutineType
    items?: JsonNullValueInput | InputJsonValue
    completedCount?: number
    totalCount?: number
    completionPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyRoutineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    routineType?: EnumRoutineTypeFieldUpdateOperationsInput | $Enums.RoutineType
    items?: JsonNullValueInput | InputJsonValue
    completedCount?: IntFieldUpdateOperationsInput | number
    totalCount?: IntFieldUpdateOperationsInput | number
    completionPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDailyRoutineNestedInput
  }

  export type DailyRoutineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    routineType?: EnumRoutineTypeFieldUpdateOperationsInput | $Enums.RoutineType
    items?: JsonNullValueInput | InputJsonValue
    completedCount?: IntFieldUpdateOperationsInput | number
    totalCount?: IntFieldUpdateOperationsInput | number
    completionPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyRoutineCreateManyInput = {
    id?: string
    userId: string
    date: string
    routineType: $Enums.RoutineType
    items?: JsonNullValueInput | InputJsonValue
    completedCount?: number
    totalCount?: number
    completionPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyRoutineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    routineType?: EnumRoutineTypeFieldUpdateOperationsInput | $Enums.RoutineType
    items?: JsonNullValueInput | InputJsonValue
    completedCount?: IntFieldUpdateOperationsInput | number
    totalCount?: IntFieldUpdateOperationsInput | number
    completionPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyRoutineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    routineType?: EnumRoutineTypeFieldUpdateOperationsInput | $Enums.RoutineType
    items?: JsonNullValueInput | InputJsonValue
    completedCount?: IntFieldUpdateOperationsInput | number
    totalCount?: IntFieldUpdateOperationsInput | number
    completionPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyReflectionsCreateInput = {
    id?: string
    date: string
    wentWell?: DailyReflectionsCreatewentWellInput | string[]
    evenBetterIf?: DailyReflectionsCreateevenBetterIfInput | string[]
    analysis?: DailyReflectionsCreateanalysisInput | string[]
    patterns?: DailyReflectionsCreatepatternsInput | string[]
    changes?: DailyReflectionsCreatechangesInput | string[]
    overallRating?: number | null
    keyLearnings?: string | null
    tomorrowFocus?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDailyReflectionsInput
  }

  export type DailyReflectionsUncheckedCreateInput = {
    id?: string
    userId: string
    date: string
    wentWell?: DailyReflectionsCreatewentWellInput | string[]
    evenBetterIf?: DailyReflectionsCreateevenBetterIfInput | string[]
    analysis?: DailyReflectionsCreateanalysisInput | string[]
    patterns?: DailyReflectionsCreatepatternsInput | string[]
    changes?: DailyReflectionsCreatechangesInput | string[]
    overallRating?: number | null
    keyLearnings?: string | null
    tomorrowFocus?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyReflectionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    wentWell?: DailyReflectionsUpdatewentWellInput | string[]
    evenBetterIf?: DailyReflectionsUpdateevenBetterIfInput | string[]
    analysis?: DailyReflectionsUpdateanalysisInput | string[]
    patterns?: DailyReflectionsUpdatepatternsInput | string[]
    changes?: DailyReflectionsUpdatechangesInput | string[]
    overallRating?: NullableIntFieldUpdateOperationsInput | number | null
    keyLearnings?: NullableStringFieldUpdateOperationsInput | string | null
    tomorrowFocus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDailyReflectionsNestedInput
  }

  export type DailyReflectionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    wentWell?: DailyReflectionsUpdatewentWellInput | string[]
    evenBetterIf?: DailyReflectionsUpdateevenBetterIfInput | string[]
    analysis?: DailyReflectionsUpdateanalysisInput | string[]
    patterns?: DailyReflectionsUpdatepatternsInput | string[]
    changes?: DailyReflectionsUpdatechangesInput | string[]
    overallRating?: NullableIntFieldUpdateOperationsInput | number | null
    keyLearnings?: NullableStringFieldUpdateOperationsInput | string | null
    tomorrowFocus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyReflectionsCreateManyInput = {
    id?: string
    userId: string
    date: string
    wentWell?: DailyReflectionsCreatewentWellInput | string[]
    evenBetterIf?: DailyReflectionsCreateevenBetterIfInput | string[]
    analysis?: DailyReflectionsCreateanalysisInput | string[]
    patterns?: DailyReflectionsCreatepatternsInput | string[]
    changes?: DailyReflectionsCreatechangesInput | string[]
    overallRating?: number | null
    keyLearnings?: string | null
    tomorrowFocus?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyReflectionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    wentWell?: DailyReflectionsUpdatewentWellInput | string[]
    evenBetterIf?: DailyReflectionsUpdateevenBetterIfInput | string[]
    analysis?: DailyReflectionsUpdateanalysisInput | string[]
    patterns?: DailyReflectionsUpdatepatternsInput | string[]
    changes?: DailyReflectionsUpdatechangesInput | string[]
    overallRating?: NullableIntFieldUpdateOperationsInput | number | null
    keyLearnings?: NullableStringFieldUpdateOperationsInput | string | null
    tomorrowFocus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyReflectionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    wentWell?: DailyReflectionsUpdatewentWellInput | string[]
    evenBetterIf?: DailyReflectionsUpdateevenBetterIfInput | string[]
    analysis?: DailyReflectionsUpdateanalysisInput | string[]
    patterns?: DailyReflectionsUpdatepatternsInput | string[]
    changes?: DailyReflectionsUpdatechangesInput | string[]
    overallRating?: NullableIntFieldUpdateOperationsInput | number | null
    keyLearnings?: NullableStringFieldUpdateOperationsInput | string | null
    tomorrowFocus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimeBlockCreateInput = {
    id?: string
    date: string
    startTime: string
    endTime: string
    title: string
    description?: string | null
    category: $Enums.TimeBlockCategory
    completed?: boolean
    actualStart?: string | null
    actualEnd?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTimeBlocksInput
  }

  export type TimeBlockUncheckedCreateInput = {
    id?: string
    userId: string
    date: string
    startTime: string
    endTime: string
    title: string
    description?: string | null
    category: $Enums.TimeBlockCategory
    completed?: boolean
    actualStart?: string | null
    actualEnd?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimeBlockUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumTimeBlockCategoryFieldUpdateOperationsInput | $Enums.TimeBlockCategory
    completed?: BoolFieldUpdateOperationsInput | boolean
    actualStart?: NullableStringFieldUpdateOperationsInput | string | null
    actualEnd?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTimeBlocksNestedInput
  }

  export type TimeBlockUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumTimeBlockCategoryFieldUpdateOperationsInput | $Enums.TimeBlockCategory
    completed?: BoolFieldUpdateOperationsInput | boolean
    actualStart?: NullableStringFieldUpdateOperationsInput | string | null
    actualEnd?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimeBlockCreateManyInput = {
    id?: string
    userId: string
    date: string
    startTime: string
    endTime: string
    title: string
    description?: string | null
    category: $Enums.TimeBlockCategory
    completed?: boolean
    actualStart?: string | null
    actualEnd?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimeBlockUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumTimeBlockCategoryFieldUpdateOperationsInput | $Enums.TimeBlockCategory
    completed?: BoolFieldUpdateOperationsInput | boolean
    actualStart?: NullableStringFieldUpdateOperationsInput | string | null
    actualEnd?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimeBlockUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumTimeBlockCategoryFieldUpdateOperationsInput | $Enums.TimeBlockCategory
    completed?: BoolFieldUpdateOperationsInput | boolean
    actualStart?: NullableStringFieldUpdateOperationsInput | string | null
    actualEnd?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonalContextCreateInput = {
    id?: string
    currentGoals?: string | null
    skillPriorities?: string | null
    revenueTargets?: string | null
    timeConstraints?: string | null
    currentProjects?: string | null
    hatedTasks?: string | null
    valuedTasks?: string | null
    learningObjectives?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPersonalContextInput
  }

  export type PersonalContextUncheckedCreateInput = {
    id?: string
    userId: string
    currentGoals?: string | null
    skillPriorities?: string | null
    revenueTargets?: string | null
    timeConstraints?: string | null
    currentProjects?: string | null
    hatedTasks?: string | null
    valuedTasks?: string | null
    learningObjectives?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PersonalContextUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentGoals?: NullableStringFieldUpdateOperationsInput | string | null
    skillPriorities?: NullableStringFieldUpdateOperationsInput | string | null
    revenueTargets?: NullableStringFieldUpdateOperationsInput | string | null
    timeConstraints?: NullableStringFieldUpdateOperationsInput | string | null
    currentProjects?: NullableStringFieldUpdateOperationsInput | string | null
    hatedTasks?: NullableStringFieldUpdateOperationsInput | string | null
    valuedTasks?: NullableStringFieldUpdateOperationsInput | string | null
    learningObjectives?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPersonalContextNestedInput
  }

  export type PersonalContextUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    currentGoals?: NullableStringFieldUpdateOperationsInput | string | null
    skillPriorities?: NullableStringFieldUpdateOperationsInput | string | null
    revenueTargets?: NullableStringFieldUpdateOperationsInput | string | null
    timeConstraints?: NullableStringFieldUpdateOperationsInput | string | null
    currentProjects?: NullableStringFieldUpdateOperationsInput | string | null
    hatedTasks?: NullableStringFieldUpdateOperationsInput | string | null
    valuedTasks?: NullableStringFieldUpdateOperationsInput | string | null
    learningObjectives?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonalContextCreateManyInput = {
    id?: string
    userId: string
    currentGoals?: string | null
    skillPriorities?: string | null
    revenueTargets?: string | null
    timeConstraints?: string | null
    currentProjects?: string | null
    hatedTasks?: string | null
    valuedTasks?: string | null
    learningObjectives?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PersonalContextUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentGoals?: NullableStringFieldUpdateOperationsInput | string | null
    skillPriorities?: NullableStringFieldUpdateOperationsInput | string | null
    revenueTargets?: NullableStringFieldUpdateOperationsInput | string | null
    timeConstraints?: NullableStringFieldUpdateOperationsInput | string | null
    currentProjects?: NullableStringFieldUpdateOperationsInput | string | null
    hatedTasks?: NullableStringFieldUpdateOperationsInput | string | null
    valuedTasks?: NullableStringFieldUpdateOperationsInput | string | null
    learningObjectives?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonalContextUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    currentGoals?: NullableStringFieldUpdateOperationsInput | string | null
    skillPriorities?: NullableStringFieldUpdateOperationsInput | string | null
    revenueTargets?: NullableStringFieldUpdateOperationsInput | string | null
    timeConstraints?: NullableStringFieldUpdateOperationsInput | string | null
    currentProjects?: NullableStringFieldUpdateOperationsInput | string | null
    hatedTasks?: NullableStringFieldUpdateOperationsInput | string | null
    valuedTasks?: NullableStringFieldUpdateOperationsInput | string | null
    learningObjectives?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProgressCreateInput = {
    id?: string
    currentLevel?: number
    totalXP?: number
    dailyXP?: number
    currentStreak?: number
    bestStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    achievements?: AchievementCreateNestedManyWithoutUserProgressInput
    dailyStats?: DailyStatsCreateNestedManyWithoutUserProgressInput
    user: UserCreateNestedOneWithoutUserProgressInput
  }

  export type UserProgressUncheckedCreateInput = {
    id?: string
    userId: string
    currentLevel?: number
    totalXP?: number
    dailyXP?: number
    currentStreak?: number
    bestStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserProgressInput
    dailyStats?: DailyStatsUncheckedCreateNestedManyWithoutUserProgressInput
  }

  export type UserProgressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentLevel?: IntFieldUpdateOperationsInput | number
    totalXP?: IntFieldUpdateOperationsInput | number
    dailyXP?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    achievements?: AchievementUpdateManyWithoutUserProgressNestedInput
    dailyStats?: DailyStatsUpdateManyWithoutUserProgressNestedInput
    user?: UserUpdateOneRequiredWithoutUserProgressNestedInput
  }

  export type UserProgressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    currentLevel?: IntFieldUpdateOperationsInput | number
    totalXP?: IntFieldUpdateOperationsInput | number
    dailyXP?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    achievements?: AchievementUncheckedUpdateManyWithoutUserProgressNestedInput
    dailyStats?: DailyStatsUncheckedUpdateManyWithoutUserProgressNestedInput
  }

  export type UserProgressCreateManyInput = {
    id?: string
    userId: string
    currentLevel?: number
    totalXP?: number
    dailyXP?: number
    currentStreak?: number
    bestStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserProgressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentLevel?: IntFieldUpdateOperationsInput | number
    totalXP?: IntFieldUpdateOperationsInput | number
    dailyXP?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProgressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    currentLevel?: IntFieldUpdateOperationsInput | number
    totalXP?: IntFieldUpdateOperationsInput | number
    dailyXP?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementCreateInput = {
    id?: string
    name: string
    description: string
    badge: string
    category: $Enums.AchievementCategory
    requirement: number
    unlocked?: boolean
    progress?: number
    maxProgress: number
    unlockedAt?: Date | string | null
    createdAt?: Date | string
    userProgress: UserProgressCreateNestedOneWithoutAchievementsInput
  }

  export type AchievementUncheckedCreateInput = {
    id?: string
    progressId: string
    name: string
    description: string
    badge: string
    category: $Enums.AchievementCategory
    requirement: number
    unlocked?: boolean
    progress?: number
    maxProgress: number
    unlockedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AchievementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    badge?: StringFieldUpdateOperationsInput | string
    category?: EnumAchievementCategoryFieldUpdateOperationsInput | $Enums.AchievementCategory
    requirement?: IntFieldUpdateOperationsInput | number
    unlocked?: BoolFieldUpdateOperationsInput | boolean
    progress?: IntFieldUpdateOperationsInput | number
    maxProgress?: IntFieldUpdateOperationsInput | number
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userProgress?: UserProgressUpdateOneRequiredWithoutAchievementsNestedInput
  }

  export type AchievementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    progressId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    badge?: StringFieldUpdateOperationsInput | string
    category?: EnumAchievementCategoryFieldUpdateOperationsInput | $Enums.AchievementCategory
    requirement?: IntFieldUpdateOperationsInput | number
    unlocked?: BoolFieldUpdateOperationsInput | boolean
    progress?: IntFieldUpdateOperationsInput | number
    maxProgress?: IntFieldUpdateOperationsInput | number
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementCreateManyInput = {
    id?: string
    progressId: string
    name: string
    description: string
    badge: string
    category: $Enums.AchievementCategory
    requirement: number
    unlocked?: boolean
    progress?: number
    maxProgress: number
    unlockedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AchievementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    badge?: StringFieldUpdateOperationsInput | string
    category?: EnumAchievementCategoryFieldUpdateOperationsInput | $Enums.AchievementCategory
    requirement?: IntFieldUpdateOperationsInput | number
    unlocked?: BoolFieldUpdateOperationsInput | boolean
    progress?: IntFieldUpdateOperationsInput | number
    maxProgress?: IntFieldUpdateOperationsInput | number
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    progressId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    badge?: StringFieldUpdateOperationsInput | string
    category?: EnumAchievementCategoryFieldUpdateOperationsInput | $Enums.AchievementCategory
    requirement?: IntFieldUpdateOperationsInput | number
    unlocked?: BoolFieldUpdateOperationsInput | boolean
    progress?: IntFieldUpdateOperationsInput | number
    maxProgress?: IntFieldUpdateOperationsInput | number
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyStatsCreateInput = {
    id?: string
    date: string
    totalXP?: number
    activitiesCompleted?: number
    streakCount?: number
    level?: number
    routineXP?: number
    taskXP?: number
    healthXP?: number
    focusXP?: number
    habitXP?: number
    createdAt?: Date | string
    userProgress: UserProgressCreateNestedOneWithoutDailyStatsInput
  }

  export type DailyStatsUncheckedCreateInput = {
    id?: string
    progressId: string
    date: string
    totalXP?: number
    activitiesCompleted?: number
    streakCount?: number
    level?: number
    routineXP?: number
    taskXP?: number
    healthXP?: number
    focusXP?: number
    habitXP?: number
    createdAt?: Date | string
  }

  export type DailyStatsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    totalXP?: IntFieldUpdateOperationsInput | number
    activitiesCompleted?: IntFieldUpdateOperationsInput | number
    streakCount?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    routineXP?: IntFieldUpdateOperationsInput | number
    taskXP?: IntFieldUpdateOperationsInput | number
    healthXP?: IntFieldUpdateOperationsInput | number
    focusXP?: IntFieldUpdateOperationsInput | number
    habitXP?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userProgress?: UserProgressUpdateOneRequiredWithoutDailyStatsNestedInput
  }

  export type DailyStatsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    progressId?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    totalXP?: IntFieldUpdateOperationsInput | number
    activitiesCompleted?: IntFieldUpdateOperationsInput | number
    streakCount?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    routineXP?: IntFieldUpdateOperationsInput | number
    taskXP?: IntFieldUpdateOperationsInput | number
    healthXP?: IntFieldUpdateOperationsInput | number
    focusXP?: IntFieldUpdateOperationsInput | number
    habitXP?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyStatsCreateManyInput = {
    id?: string
    progressId: string
    date: string
    totalXP?: number
    activitiesCompleted?: number
    streakCount?: number
    level?: number
    routineXP?: number
    taskXP?: number
    healthXP?: number
    focusXP?: number
    habitXP?: number
    createdAt?: Date | string
  }

  export type DailyStatsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    totalXP?: IntFieldUpdateOperationsInput | number
    activitiesCompleted?: IntFieldUpdateOperationsInput | number
    streakCount?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    routineXP?: IntFieldUpdateOperationsInput | number
    taskXP?: IntFieldUpdateOperationsInput | number
    healthXP?: IntFieldUpdateOperationsInput | number
    focusXP?: IntFieldUpdateOperationsInput | number
    habitXP?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyStatsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    progressId?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    totalXP?: IntFieldUpdateOperationsInput | number
    activitiesCompleted?: IntFieldUpdateOperationsInput | number
    streakCount?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    routineXP?: IntFieldUpdateOperationsInput | number
    taskXP?: IntFieldUpdateOperationsInput | number
    healthXP?: IntFieldUpdateOperationsInput | number
    focusXP?: IntFieldUpdateOperationsInput | number
    habitXP?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XPBalanceCreateInput = {
    id?: string
    currentXP?: number
    totalEarned?: number
    totalSpent?: number
    reserveXP?: number
    pendingLoans?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutXpBalanceInput
  }

  export type XPBalanceUncheckedCreateInput = {
    id?: string
    userId: string
    currentXP?: number
    totalEarned?: number
    totalSpent?: number
    reserveXP?: number
    pendingLoans?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type XPBalanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentXP?: IntFieldUpdateOperationsInput | number
    totalEarned?: IntFieldUpdateOperationsInput | number
    totalSpent?: IntFieldUpdateOperationsInput | number
    reserveXP?: IntFieldUpdateOperationsInput | number
    pendingLoans?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutXpBalanceNestedInput
  }

  export type XPBalanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    currentXP?: IntFieldUpdateOperationsInput | number
    totalEarned?: IntFieldUpdateOperationsInput | number
    totalSpent?: IntFieldUpdateOperationsInput | number
    reserveXP?: IntFieldUpdateOperationsInput | number
    pendingLoans?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XPBalanceCreateManyInput = {
    id?: string
    userId: string
    currentXP?: number
    totalEarned?: number
    totalSpent?: number
    reserveXP?: number
    pendingLoans?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type XPBalanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentXP?: IntFieldUpdateOperationsInput | number
    totalEarned?: IntFieldUpdateOperationsInput | number
    totalSpent?: IntFieldUpdateOperationsInput | number
    reserveXP?: IntFieldUpdateOperationsInput | number
    pendingLoans?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XPBalanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    currentXP?: IntFieldUpdateOperationsInput | number
    totalEarned?: IntFieldUpdateOperationsInput | number
    totalSpent?: IntFieldUpdateOperationsInput | number
    reserveXP?: IntFieldUpdateOperationsInput | number
    pendingLoans?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XPPurchaseCreateInput = {
    id?: string
    xpSpent: number
    actualPrice: number
    purchaseType?: string
    notes?: string | null
    satisfactionRating?: number | null
    guiltLevel?: number | null
    wasPlanned?: boolean
    celebrationLevel?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutXpPurchasesInput
    reward: RewardDefinitionCreateNestedOneWithoutPurchasesInput
  }

  export type XPPurchaseUncheckedCreateInput = {
    id?: string
    userId: string
    rewardId: string
    xpSpent: number
    actualPrice: number
    purchaseType?: string
    notes?: string | null
    satisfactionRating?: number | null
    guiltLevel?: number | null
    wasPlanned?: boolean
    celebrationLevel?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type XPPurchaseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    xpSpent?: IntFieldUpdateOperationsInput | number
    actualPrice?: IntFieldUpdateOperationsInput | number
    purchaseType?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    satisfactionRating?: NullableIntFieldUpdateOperationsInput | number | null
    guiltLevel?: NullableIntFieldUpdateOperationsInput | number | null
    wasPlanned?: BoolFieldUpdateOperationsInput | boolean
    celebrationLevel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutXpPurchasesNestedInput
    reward?: RewardDefinitionUpdateOneRequiredWithoutPurchasesNestedInput
  }

  export type XPPurchaseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rewardId?: StringFieldUpdateOperationsInput | string
    xpSpent?: IntFieldUpdateOperationsInput | number
    actualPrice?: IntFieldUpdateOperationsInput | number
    purchaseType?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    satisfactionRating?: NullableIntFieldUpdateOperationsInput | number | null
    guiltLevel?: NullableIntFieldUpdateOperationsInput | number | null
    wasPlanned?: BoolFieldUpdateOperationsInput | boolean
    celebrationLevel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XPPurchaseCreateManyInput = {
    id?: string
    userId: string
    rewardId: string
    xpSpent: number
    actualPrice: number
    purchaseType?: string
    notes?: string | null
    satisfactionRating?: number | null
    guiltLevel?: number | null
    wasPlanned?: boolean
    celebrationLevel?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type XPPurchaseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    xpSpent?: IntFieldUpdateOperationsInput | number
    actualPrice?: IntFieldUpdateOperationsInput | number
    purchaseType?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    satisfactionRating?: NullableIntFieldUpdateOperationsInput | number | null
    guiltLevel?: NullableIntFieldUpdateOperationsInput | number | null
    wasPlanned?: BoolFieldUpdateOperationsInput | boolean
    celebrationLevel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XPPurchaseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rewardId?: StringFieldUpdateOperationsInput | string
    xpSpent?: IntFieldUpdateOperationsInput | number
    actualPrice?: IntFieldUpdateOperationsInput | number
    purchaseType?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    satisfactionRating?: NullableIntFieldUpdateOperationsInput | number | null
    guiltLevel?: NullableIntFieldUpdateOperationsInput | number | null
    wasPlanned?: BoolFieldUpdateOperationsInput | boolean
    celebrationLevel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XPEarningLogCreateInput = {
    id?: string
    source: string
    sourceId?: string | null
    baseXP: number
    finalXP: number
    multipliers?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutXpEarningLogInput
  }

  export type XPEarningLogUncheckedCreateInput = {
    id?: string
    userId: string
    source: string
    sourceId?: string | null
    baseXP: number
    finalXP: number
    multipliers?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type XPEarningLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    baseXP?: IntFieldUpdateOperationsInput | number
    finalXP?: IntFieldUpdateOperationsInput | number
    multipliers?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutXpEarningLogNestedInput
  }

  export type XPEarningLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    baseXP?: IntFieldUpdateOperationsInput | number
    finalXP?: IntFieldUpdateOperationsInput | number
    multipliers?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XPEarningLogCreateManyInput = {
    id?: string
    userId: string
    source: string
    sourceId?: string | null
    baseXP: number
    finalXP: number
    multipliers?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type XPEarningLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    baseXP?: IntFieldUpdateOperationsInput | number
    finalXP?: IntFieldUpdateOperationsInput | number
    multipliers?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XPEarningLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    baseXP?: IntFieldUpdateOperationsInput | number
    finalXP?: IntFieldUpdateOperationsInput | number
    multipliers?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RewardDefinitionCreateInput = {
    id?: string
    category: string
    name: string
    description: string
    basePrice: number
    iconEmoji: string
    isActive?: boolean
    requiresStreak?: number | null
    maxDailyUse?: number
    availabilityWindow?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchases?: XPPurchaseCreateNestedManyWithoutRewardInput
  }

  export type RewardDefinitionUncheckedCreateInput = {
    id?: string
    category: string
    name: string
    description: string
    basePrice: number
    iconEmoji: string
    isActive?: boolean
    requiresStreak?: number | null
    maxDailyUse?: number
    availabilityWindow?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchases?: XPPurchaseUncheckedCreateNestedManyWithoutRewardInput
  }

  export type RewardDefinitionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    basePrice?: IntFieldUpdateOperationsInput | number
    iconEmoji?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requiresStreak?: NullableIntFieldUpdateOperationsInput | number | null
    maxDailyUse?: IntFieldUpdateOperationsInput | number
    availabilityWindow?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchases?: XPPurchaseUpdateManyWithoutRewardNestedInput
  }

  export type RewardDefinitionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    basePrice?: IntFieldUpdateOperationsInput | number
    iconEmoji?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requiresStreak?: NullableIntFieldUpdateOperationsInput | number | null
    maxDailyUse?: IntFieldUpdateOperationsInput | number
    availabilityWindow?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchases?: XPPurchaseUncheckedUpdateManyWithoutRewardNestedInput
  }

  export type RewardDefinitionCreateManyInput = {
    id?: string
    category: string
    name: string
    description: string
    basePrice: number
    iconEmoji: string
    isActive?: boolean
    requiresStreak?: number | null
    maxDailyUse?: number
    availabilityWindow?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RewardDefinitionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    basePrice?: IntFieldUpdateOperationsInput | number
    iconEmoji?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requiresStreak?: NullableIntFieldUpdateOperationsInput | number | null
    maxDailyUse?: IntFieldUpdateOperationsInput | number
    availabilityWindow?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RewardDefinitionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    basePrice?: IntFieldUpdateOperationsInput | number
    iconEmoji?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requiresStreak?: NullableIntFieldUpdateOperationsInput | number | null
    maxDailyUse?: IntFieldUpdateOperationsInput | number
    availabilityWindow?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type LightWorkTaskListRelationFilter = {
    every?: LightWorkTaskWhereInput
    some?: LightWorkTaskWhereInput
    none?: LightWorkTaskWhereInput
  }

  export type DeepWorkTaskListRelationFilter = {
    every?: DeepWorkTaskWhereInput
    some?: DeepWorkTaskWhereInput
    none?: DeepWorkTaskWhereInput
  }

  export type PersonalContextListRelationFilter = {
    every?: PersonalContextWhereInput
    some?: PersonalContextWhereInput
    none?: PersonalContextWhereInput
  }

  export type AutomationTaskListRelationFilter = {
    every?: AutomationTaskWhereInput
    some?: AutomationTaskWhereInput
    none?: AutomationTaskWhereInput
  }

  export type DailyHabitsListRelationFilter = {
    every?: DailyHabitsWhereInput
    some?: DailyHabitsWhereInput
    none?: DailyHabitsWhereInput
  }

  export type DailyHealthListRelationFilter = {
    every?: DailyHealthWhereInput
    some?: DailyHealthWhereInput
    none?: DailyHealthWhereInput
  }

  export type DailyWorkoutListRelationFilter = {
    every?: DailyWorkoutWhereInput
    some?: DailyWorkoutWhereInput
    none?: DailyWorkoutWhereInput
  }

  export type DailyRoutineListRelationFilter = {
    every?: DailyRoutineWhereInput
    some?: DailyRoutineWhereInput
    none?: DailyRoutineWhereInput
  }

  export type DailyReflectionsListRelationFilter = {
    every?: DailyReflectionsWhereInput
    some?: DailyReflectionsWhereInput
    none?: DailyReflectionsWhereInput
  }

  export type TimeBlockListRelationFilter = {
    every?: TimeBlockWhereInput
    some?: TimeBlockWhereInput
    none?: TimeBlockWhereInput
  }

  export type UserProgressListRelationFilter = {
    every?: UserProgressWhereInput
    some?: UserProgressWhereInput
    none?: UserProgressWhereInput
  }

  export type XPBalanceListRelationFilter = {
    every?: XPBalanceWhereInput
    some?: XPBalanceWhereInput
    none?: XPBalanceWhereInput
  }

  export type XPPurchaseListRelationFilter = {
    every?: XPPurchaseWhereInput
    some?: XPPurchaseWhereInput
    none?: XPPurchaseWhereInput
  }

  export type XPEarningLogListRelationFilter = {
    every?: XPEarningLogWhereInput
    some?: XPEarningLogWhereInput
    none?: XPEarningLogWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type LightWorkTaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeepWorkTaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PersonalContextOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AutomationTaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DailyHabitsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DailyHealthOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DailyWorkoutOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DailyRoutineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DailyReflectionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TimeBlockOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserProgressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type XPBalanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type XPPurchaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type XPEarningLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    supabaseId?: SortOrder
    email?: SortOrder
    displayName?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    supabaseId?: SortOrder
    email?: SortOrder
    displayName?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    supabaseId?: SortOrder
    email?: SortOrder
    displayName?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityFilter<$PrismaModel> | $Enums.Priority
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type LightWorkSubtaskListRelationFilter = {
    every?: LightWorkSubtaskWhereInput
    some?: LightWorkSubtaskWhereInput
    none?: LightWorkSubtaskWhereInput
  }

  export type LightWorkSubtaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LightWorkTaskCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    completed?: SortOrder
    originalDate?: SortOrder
    currentDate?: SortOrder
    estimatedDuration?: SortOrder
    rollovers?: SortOrder
    tags?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
    startedAt?: SortOrder
    actualDurationMin?: SortOrder
    timeEstimate?: SortOrder
    aiAnalyzed?: SortOrder
    aiReasoning?: SortOrder
    analyzedAt?: SortOrder
    xpReward?: SortOrder
    complexity?: SortOrder
    confidence?: SortOrder
    contextualBonus?: SortOrder
    difficulty?: SortOrder
    learningValue?: SortOrder
    priorityRank?: SortOrder
    strategicImportance?: SortOrder
    timeAccuracy?: SortOrder
  }

  export type LightWorkTaskAvgOrderByAggregateInput = {
    estimatedDuration?: SortOrder
    rollovers?: SortOrder
    actualDurationMin?: SortOrder
    xpReward?: SortOrder
    complexity?: SortOrder
    confidence?: SortOrder
    contextualBonus?: SortOrder
    difficulty?: SortOrder
    learningValue?: SortOrder
    priorityRank?: SortOrder
    strategicImportance?: SortOrder
    timeAccuracy?: SortOrder
  }

  export type LightWorkTaskMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    completed?: SortOrder
    originalDate?: SortOrder
    currentDate?: SortOrder
    estimatedDuration?: SortOrder
    rollovers?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
    startedAt?: SortOrder
    actualDurationMin?: SortOrder
    timeEstimate?: SortOrder
    aiAnalyzed?: SortOrder
    aiReasoning?: SortOrder
    analyzedAt?: SortOrder
    xpReward?: SortOrder
    complexity?: SortOrder
    confidence?: SortOrder
    contextualBonus?: SortOrder
    difficulty?: SortOrder
    learningValue?: SortOrder
    priorityRank?: SortOrder
    strategicImportance?: SortOrder
    timeAccuracy?: SortOrder
  }

  export type LightWorkTaskMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    completed?: SortOrder
    originalDate?: SortOrder
    currentDate?: SortOrder
    estimatedDuration?: SortOrder
    rollovers?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
    startedAt?: SortOrder
    actualDurationMin?: SortOrder
    timeEstimate?: SortOrder
    aiAnalyzed?: SortOrder
    aiReasoning?: SortOrder
    analyzedAt?: SortOrder
    xpReward?: SortOrder
    complexity?: SortOrder
    confidence?: SortOrder
    contextualBonus?: SortOrder
    difficulty?: SortOrder
    learningValue?: SortOrder
    priorityRank?: SortOrder
    strategicImportance?: SortOrder
    timeAccuracy?: SortOrder
  }

  export type LightWorkTaskSumOrderByAggregateInput = {
    estimatedDuration?: SortOrder
    rollovers?: SortOrder
    actualDurationMin?: SortOrder
    xpReward?: SortOrder
    complexity?: SortOrder
    confidence?: SortOrder
    contextualBonus?: SortOrder
    difficulty?: SortOrder
    learningValue?: SortOrder
    priorityRank?: SortOrder
    strategicImportance?: SortOrder
    timeAccuracy?: SortOrder
  }

  export type EnumPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityWithAggregatesFilter<$PrismaModel> | $Enums.Priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriorityFilter<$PrismaModel>
    _max?: NestedEnumPriorityFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type LightWorkTaskScalarRelationFilter = {
    is?: LightWorkTaskWhereInput
    isNot?: LightWorkTaskWhereInput
  }

  export type LightWorkSubtaskCountOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    title?: SortOrder
    text?: SortOrder
    completed?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
    startedAt?: SortOrder
    actualDurationMin?: SortOrder
    timeAccuracy?: SortOrder
    aiAnalyzed?: SortOrder
    aiReasoning?: SortOrder
    analyzedAt?: SortOrder
    xpReward?: SortOrder
    complexity?: SortOrder
    confidence?: SortOrder
    contextualBonus?: SortOrder
    difficulty?: SortOrder
    learningValue?: SortOrder
    priorityRank?: SortOrder
    strategicImportance?: SortOrder
  }

  export type LightWorkSubtaskAvgOrderByAggregateInput = {
    actualDurationMin?: SortOrder
    timeAccuracy?: SortOrder
    xpReward?: SortOrder
    complexity?: SortOrder
    confidence?: SortOrder
    contextualBonus?: SortOrder
    difficulty?: SortOrder
    learningValue?: SortOrder
    priorityRank?: SortOrder
    strategicImportance?: SortOrder
  }

  export type LightWorkSubtaskMaxOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    title?: SortOrder
    text?: SortOrder
    completed?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
    startedAt?: SortOrder
    actualDurationMin?: SortOrder
    timeAccuracy?: SortOrder
    aiAnalyzed?: SortOrder
    aiReasoning?: SortOrder
    analyzedAt?: SortOrder
    xpReward?: SortOrder
    complexity?: SortOrder
    confidence?: SortOrder
    contextualBonus?: SortOrder
    difficulty?: SortOrder
    learningValue?: SortOrder
    priorityRank?: SortOrder
    strategicImportance?: SortOrder
  }

  export type LightWorkSubtaskMinOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    title?: SortOrder
    text?: SortOrder
    completed?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
    startedAt?: SortOrder
    actualDurationMin?: SortOrder
    timeAccuracy?: SortOrder
    aiAnalyzed?: SortOrder
    aiReasoning?: SortOrder
    analyzedAt?: SortOrder
    xpReward?: SortOrder
    complexity?: SortOrder
    confidence?: SortOrder
    contextualBonus?: SortOrder
    difficulty?: SortOrder
    learningValue?: SortOrder
    priorityRank?: SortOrder
    strategicImportance?: SortOrder
  }

  export type LightWorkSubtaskSumOrderByAggregateInput = {
    actualDurationMin?: SortOrder
    timeAccuracy?: SortOrder
    xpReward?: SortOrder
    complexity?: SortOrder
    confidence?: SortOrder
    contextualBonus?: SortOrder
    difficulty?: SortOrder
    learningValue?: SortOrder
    priorityRank?: SortOrder
    strategicImportance?: SortOrder
  }

  export type DeepWorkSubtaskListRelationFilter = {
    every?: DeepWorkSubtaskWhereInput
    some?: DeepWorkSubtaskWhereInput
    none?: DeepWorkSubtaskWhereInput
  }

  export type DeepWorkSubtaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeepWorkTaskCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    completed?: SortOrder
    originalDate?: SortOrder
    currentDate?: SortOrder
    estimatedDuration?: SortOrder
    focusBlocks?: SortOrder
    breakDuration?: SortOrder
    interruptionMode?: SortOrder
    rollovers?: SortOrder
    tags?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
    startedAt?: SortOrder
    actualDurationMin?: SortOrder
    timeEstimate?: SortOrder
    aiAnalyzed?: SortOrder
    aiReasoning?: SortOrder
    analyzedAt?: SortOrder
    xpReward?: SortOrder
    complexity?: SortOrder
    confidence?: SortOrder
    contextualBonus?: SortOrder
    difficulty?: SortOrder
    learningValue?: SortOrder
    priorityRank?: SortOrder
    strategicImportance?: SortOrder
    timeAccuracy?: SortOrder
  }

  export type DeepWorkTaskAvgOrderByAggregateInput = {
    estimatedDuration?: SortOrder
    focusBlocks?: SortOrder
    breakDuration?: SortOrder
    rollovers?: SortOrder
    actualDurationMin?: SortOrder
    xpReward?: SortOrder
    complexity?: SortOrder
    confidence?: SortOrder
    contextualBonus?: SortOrder
    difficulty?: SortOrder
    learningValue?: SortOrder
    priorityRank?: SortOrder
    strategicImportance?: SortOrder
    timeAccuracy?: SortOrder
  }

  export type DeepWorkTaskMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    completed?: SortOrder
    originalDate?: SortOrder
    currentDate?: SortOrder
    estimatedDuration?: SortOrder
    focusBlocks?: SortOrder
    breakDuration?: SortOrder
    interruptionMode?: SortOrder
    rollovers?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
    startedAt?: SortOrder
    actualDurationMin?: SortOrder
    timeEstimate?: SortOrder
    aiAnalyzed?: SortOrder
    aiReasoning?: SortOrder
    analyzedAt?: SortOrder
    xpReward?: SortOrder
    complexity?: SortOrder
    confidence?: SortOrder
    contextualBonus?: SortOrder
    difficulty?: SortOrder
    learningValue?: SortOrder
    priorityRank?: SortOrder
    strategicImportance?: SortOrder
    timeAccuracy?: SortOrder
  }

  export type DeepWorkTaskMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    completed?: SortOrder
    originalDate?: SortOrder
    currentDate?: SortOrder
    estimatedDuration?: SortOrder
    focusBlocks?: SortOrder
    breakDuration?: SortOrder
    interruptionMode?: SortOrder
    rollovers?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
    startedAt?: SortOrder
    actualDurationMin?: SortOrder
    timeEstimate?: SortOrder
    aiAnalyzed?: SortOrder
    aiReasoning?: SortOrder
    analyzedAt?: SortOrder
    xpReward?: SortOrder
    complexity?: SortOrder
    confidence?: SortOrder
    contextualBonus?: SortOrder
    difficulty?: SortOrder
    learningValue?: SortOrder
    priorityRank?: SortOrder
    strategicImportance?: SortOrder
    timeAccuracy?: SortOrder
  }

  export type DeepWorkTaskSumOrderByAggregateInput = {
    estimatedDuration?: SortOrder
    focusBlocks?: SortOrder
    breakDuration?: SortOrder
    rollovers?: SortOrder
    actualDurationMin?: SortOrder
    xpReward?: SortOrder
    complexity?: SortOrder
    confidence?: SortOrder
    contextualBonus?: SortOrder
    difficulty?: SortOrder
    learningValue?: SortOrder
    priorityRank?: SortOrder
    strategicImportance?: SortOrder
    timeAccuracy?: SortOrder
  }

  export type DeepWorkTaskScalarRelationFilter = {
    is?: DeepWorkTaskWhereInput
    isNot?: DeepWorkTaskWhereInput
  }

  export type DeepWorkSubtaskCountOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    title?: SortOrder
    text?: SortOrder
    completed?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrder
    requiresFocus?: SortOrder
    complexityLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
    startedAt?: SortOrder
    actualDurationMin?: SortOrder
    timeAccuracy?: SortOrder
    aiAnalyzed?: SortOrder
    aiReasoning?: SortOrder
    analyzedAt?: SortOrder
    xpReward?: SortOrder
    complexity?: SortOrder
    confidence?: SortOrder
    contextualBonus?: SortOrder
    difficulty?: SortOrder
    learningValue?: SortOrder
    priorityRank?: SortOrder
    strategicImportance?: SortOrder
  }

  export type DeepWorkSubtaskAvgOrderByAggregateInput = {
    complexityLevel?: SortOrder
    actualDurationMin?: SortOrder
    timeAccuracy?: SortOrder
    xpReward?: SortOrder
    complexity?: SortOrder
    confidence?: SortOrder
    contextualBonus?: SortOrder
    difficulty?: SortOrder
    learningValue?: SortOrder
    priorityRank?: SortOrder
    strategicImportance?: SortOrder
  }

  export type DeepWorkSubtaskMaxOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    title?: SortOrder
    text?: SortOrder
    completed?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrder
    requiresFocus?: SortOrder
    complexityLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
    startedAt?: SortOrder
    actualDurationMin?: SortOrder
    timeAccuracy?: SortOrder
    aiAnalyzed?: SortOrder
    aiReasoning?: SortOrder
    analyzedAt?: SortOrder
    xpReward?: SortOrder
    complexity?: SortOrder
    confidence?: SortOrder
    contextualBonus?: SortOrder
    difficulty?: SortOrder
    learningValue?: SortOrder
    priorityRank?: SortOrder
    strategicImportance?: SortOrder
  }

  export type DeepWorkSubtaskMinOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    title?: SortOrder
    text?: SortOrder
    completed?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrder
    requiresFocus?: SortOrder
    complexityLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
    startedAt?: SortOrder
    actualDurationMin?: SortOrder
    timeAccuracy?: SortOrder
    aiAnalyzed?: SortOrder
    aiReasoning?: SortOrder
    analyzedAt?: SortOrder
    xpReward?: SortOrder
    complexity?: SortOrder
    confidence?: SortOrder
    contextualBonus?: SortOrder
    difficulty?: SortOrder
    learningValue?: SortOrder
    priorityRank?: SortOrder
    strategicImportance?: SortOrder
  }

  export type DeepWorkSubtaskSumOrderByAggregateInput = {
    complexityLevel?: SortOrder
    actualDurationMin?: SortOrder
    timeAccuracy?: SortOrder
    xpReward?: SortOrder
    complexity?: SortOrder
    confidence?: SortOrder
    contextualBonus?: SortOrder
    difficulty?: SortOrder
    learningValue?: SortOrder
    priorityRank?: SortOrder
    strategicImportance?: SortOrder
  }

  export type EnumAutomationCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.AutomationCategory | EnumAutomationCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.AutomationCategory[] | ListEnumAutomationCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.AutomationCategory[] | ListEnumAutomationCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumAutomationCategoryFilter<$PrismaModel> | $Enums.AutomationCategory
  }

  export type EnumAutomationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AutomationStatus | EnumAutomationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AutomationStatus[] | ListEnumAutomationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AutomationStatus[] | ListEnumAutomationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAutomationStatusFilter<$PrismaModel> | $Enums.AutomationStatus
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AutomationTaskCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    prompt?: SortOrder
    allowedTools?: SortOrder
    estimatedTokens?: SortOrder
    actualTokens?: SortOrder
    executionTimeMs?: SortOrder
    result?: SortOrder
    error?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type AutomationTaskAvgOrderByAggregateInput = {
    estimatedTokens?: SortOrder
    actualTokens?: SortOrder
    executionTimeMs?: SortOrder
  }

  export type AutomationTaskMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    prompt?: SortOrder
    estimatedTokens?: SortOrder
    actualTokens?: SortOrder
    executionTimeMs?: SortOrder
    result?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type AutomationTaskMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    prompt?: SortOrder
    estimatedTokens?: SortOrder
    actualTokens?: SortOrder
    executionTimeMs?: SortOrder
    result?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type AutomationTaskSumOrderByAggregateInput = {
    estimatedTokens?: SortOrder
    actualTokens?: SortOrder
    executionTimeMs?: SortOrder
  }

  export type EnumAutomationCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AutomationCategory | EnumAutomationCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.AutomationCategory[] | ListEnumAutomationCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.AutomationCategory[] | ListEnumAutomationCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumAutomationCategoryWithAggregatesFilter<$PrismaModel> | $Enums.AutomationCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAutomationCategoryFilter<$PrismaModel>
    _max?: NestedEnumAutomationCategoryFilter<$PrismaModel>
  }

  export type EnumAutomationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AutomationStatus | EnumAutomationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AutomationStatus[] | ListEnumAutomationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AutomationStatus[] | ListEnumAutomationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAutomationStatusWithAggregatesFilter<$PrismaModel> | $Enums.AutomationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAutomationStatusFilter<$PrismaModel>
    _max?: NestedEnumAutomationStatusFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type DailyHabitsUserIdDateCompoundUniqueInput = {
    userId: string
    date: string
  }

  export type DailyHabitsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    screenTimeMinutes?: SortOrder
    bullshitContentMinutes?: SortOrder
    noWeed?: SortOrder
    noScrolling?: SortOrder
    deepWorkHours?: SortOrder
    lightWorkHours?: SortOrder
    habitsData?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DailyHabitsAvgOrderByAggregateInput = {
    screenTimeMinutes?: SortOrder
    bullshitContentMinutes?: SortOrder
    deepWorkHours?: SortOrder
    lightWorkHours?: SortOrder
  }

  export type DailyHabitsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    screenTimeMinutes?: SortOrder
    bullshitContentMinutes?: SortOrder
    noWeed?: SortOrder
    noScrolling?: SortOrder
    deepWorkHours?: SortOrder
    lightWorkHours?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DailyHabitsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    screenTimeMinutes?: SortOrder
    bullshitContentMinutes?: SortOrder
    noWeed?: SortOrder
    noScrolling?: SortOrder
    deepWorkHours?: SortOrder
    lightWorkHours?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DailyHabitsSumOrderByAggregateInput = {
    screenTimeMinutes?: SortOrder
    bullshitContentMinutes?: SortOrder
    deepWorkHours?: SortOrder
    lightWorkHours?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type DailyHealthUserIdDateCompoundUniqueInput = {
    userId: string
    date: string
  }

  export type DailyHealthCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    healthChecklist?: SortOrder
    meals?: SortOrder
    macros?: SortOrder
    waterIntakeMl?: SortOrder
    milkIntakeMl?: SortOrder
    sleepHours?: SortOrder
    energyLevel?: SortOrder
    moodLevel?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DailyHealthAvgOrderByAggregateInput = {
    waterIntakeMl?: SortOrder
    milkIntakeMl?: SortOrder
    sleepHours?: SortOrder
    energyLevel?: SortOrder
    moodLevel?: SortOrder
  }

  export type DailyHealthMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    waterIntakeMl?: SortOrder
    milkIntakeMl?: SortOrder
    sleepHours?: SortOrder
    energyLevel?: SortOrder
    moodLevel?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DailyHealthMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    waterIntakeMl?: SortOrder
    milkIntakeMl?: SortOrder
    sleepHours?: SortOrder
    energyLevel?: SortOrder
    moodLevel?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DailyHealthSumOrderByAggregateInput = {
    waterIntakeMl?: SortOrder
    milkIntakeMl?: SortOrder
    sleepHours?: SortOrder
    energyLevel?: SortOrder
    moodLevel?: SortOrder
  }

  export type DailyWorkoutUserIdDateCompoundUniqueInput = {
    userId: string
    date: string
  }

  export type DailyWorkoutCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    exercises?: SortOrder
    totalExercises?: SortOrder
    completedExercises?: SortOrder
    completionPercentage?: SortOrder
    durationMinutes?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DailyWorkoutAvgOrderByAggregateInput = {
    totalExercises?: SortOrder
    completedExercises?: SortOrder
    completionPercentage?: SortOrder
    durationMinutes?: SortOrder
  }

  export type DailyWorkoutMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    totalExercises?: SortOrder
    completedExercises?: SortOrder
    completionPercentage?: SortOrder
    durationMinutes?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DailyWorkoutMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    totalExercises?: SortOrder
    completedExercises?: SortOrder
    completionPercentage?: SortOrder
    durationMinutes?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DailyWorkoutSumOrderByAggregateInput = {
    totalExercises?: SortOrder
    completedExercises?: SortOrder
    completionPercentage?: SortOrder
    durationMinutes?: SortOrder
  }

  export type EnumRoutineTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RoutineType | EnumRoutineTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RoutineType[] | ListEnumRoutineTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoutineType[] | ListEnumRoutineTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRoutineTypeFilter<$PrismaModel> | $Enums.RoutineType
  }

  export type DailyRoutineUserIdDateRoutineTypeCompoundUniqueInput = {
    userId: string
    date: string
    routineType: $Enums.RoutineType
  }

  export type DailyRoutineCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    routineType?: SortOrder
    items?: SortOrder
    completedCount?: SortOrder
    totalCount?: SortOrder
    completionPercentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DailyRoutineAvgOrderByAggregateInput = {
    completedCount?: SortOrder
    totalCount?: SortOrder
    completionPercentage?: SortOrder
  }

  export type DailyRoutineMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    routineType?: SortOrder
    completedCount?: SortOrder
    totalCount?: SortOrder
    completionPercentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DailyRoutineMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    routineType?: SortOrder
    completedCount?: SortOrder
    totalCount?: SortOrder
    completionPercentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DailyRoutineSumOrderByAggregateInput = {
    completedCount?: SortOrder
    totalCount?: SortOrder
    completionPercentage?: SortOrder
  }

  export type EnumRoutineTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoutineType | EnumRoutineTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RoutineType[] | ListEnumRoutineTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoutineType[] | ListEnumRoutineTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRoutineTypeWithAggregatesFilter<$PrismaModel> | $Enums.RoutineType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoutineTypeFilter<$PrismaModel>
    _max?: NestedEnumRoutineTypeFilter<$PrismaModel>
  }

  export type DailyReflectionsUserIdDateCompoundUniqueInput = {
    userId: string
    date: string
  }

  export type DailyReflectionsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    wentWell?: SortOrder
    evenBetterIf?: SortOrder
    analysis?: SortOrder
    patterns?: SortOrder
    changes?: SortOrder
    overallRating?: SortOrder
    keyLearnings?: SortOrder
    tomorrowFocus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DailyReflectionsAvgOrderByAggregateInput = {
    overallRating?: SortOrder
  }

  export type DailyReflectionsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    overallRating?: SortOrder
    keyLearnings?: SortOrder
    tomorrowFocus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DailyReflectionsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    overallRating?: SortOrder
    keyLearnings?: SortOrder
    tomorrowFocus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DailyReflectionsSumOrderByAggregateInput = {
    overallRating?: SortOrder
  }

  export type EnumTimeBlockCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.TimeBlockCategory | EnumTimeBlockCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.TimeBlockCategory[] | ListEnumTimeBlockCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.TimeBlockCategory[] | ListEnumTimeBlockCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumTimeBlockCategoryFilter<$PrismaModel> | $Enums.TimeBlockCategory
  }

  export type TimeBlockCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    completed?: SortOrder
    actualStart?: SortOrder
    actualEnd?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TimeBlockMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    completed?: SortOrder
    actualStart?: SortOrder
    actualEnd?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TimeBlockMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    completed?: SortOrder
    actualStart?: SortOrder
    actualEnd?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTimeBlockCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TimeBlockCategory | EnumTimeBlockCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.TimeBlockCategory[] | ListEnumTimeBlockCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.TimeBlockCategory[] | ListEnumTimeBlockCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumTimeBlockCategoryWithAggregatesFilter<$PrismaModel> | $Enums.TimeBlockCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTimeBlockCategoryFilter<$PrismaModel>
    _max?: NestedEnumTimeBlockCategoryFilter<$PrismaModel>
  }

  export type PersonalContextCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    currentGoals?: SortOrder
    skillPriorities?: SortOrder
    revenueTargets?: SortOrder
    timeConstraints?: SortOrder
    currentProjects?: SortOrder
    hatedTasks?: SortOrder
    valuedTasks?: SortOrder
    learningObjectives?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PersonalContextMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    currentGoals?: SortOrder
    skillPriorities?: SortOrder
    revenueTargets?: SortOrder
    timeConstraints?: SortOrder
    currentProjects?: SortOrder
    hatedTasks?: SortOrder
    valuedTasks?: SortOrder
    learningObjectives?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PersonalContextMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    currentGoals?: SortOrder
    skillPriorities?: SortOrder
    revenueTargets?: SortOrder
    timeConstraints?: SortOrder
    currentProjects?: SortOrder
    hatedTasks?: SortOrder
    valuedTasks?: SortOrder
    learningObjectives?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AchievementListRelationFilter = {
    every?: AchievementWhereInput
    some?: AchievementWhereInput
    none?: AchievementWhereInput
  }

  export type DailyStatsListRelationFilter = {
    every?: DailyStatsWhereInput
    some?: DailyStatsWhereInput
    none?: DailyStatsWhereInput
  }

  export type AchievementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DailyStatsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserProgressCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    currentLevel?: SortOrder
    totalXP?: SortOrder
    dailyXP?: SortOrder
    currentStreak?: SortOrder
    bestStreak?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserProgressAvgOrderByAggregateInput = {
    currentLevel?: SortOrder
    totalXP?: SortOrder
    dailyXP?: SortOrder
    currentStreak?: SortOrder
    bestStreak?: SortOrder
  }

  export type UserProgressMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    currentLevel?: SortOrder
    totalXP?: SortOrder
    dailyXP?: SortOrder
    currentStreak?: SortOrder
    bestStreak?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserProgressMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    currentLevel?: SortOrder
    totalXP?: SortOrder
    dailyXP?: SortOrder
    currentStreak?: SortOrder
    bestStreak?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserProgressSumOrderByAggregateInput = {
    currentLevel?: SortOrder
    totalXP?: SortOrder
    dailyXP?: SortOrder
    currentStreak?: SortOrder
    bestStreak?: SortOrder
  }

  export type EnumAchievementCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.AchievementCategory | EnumAchievementCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.AchievementCategory[] | ListEnumAchievementCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.AchievementCategory[] | ListEnumAchievementCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumAchievementCategoryFilter<$PrismaModel> | $Enums.AchievementCategory
  }

  export type UserProgressScalarRelationFilter = {
    is?: UserProgressWhereInput
    isNot?: UserProgressWhereInput
  }

  export type AchievementCountOrderByAggregateInput = {
    id?: SortOrder
    progressId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    badge?: SortOrder
    category?: SortOrder
    requirement?: SortOrder
    unlocked?: SortOrder
    progress?: SortOrder
    maxProgress?: SortOrder
    unlockedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type AchievementAvgOrderByAggregateInput = {
    requirement?: SortOrder
    progress?: SortOrder
    maxProgress?: SortOrder
  }

  export type AchievementMaxOrderByAggregateInput = {
    id?: SortOrder
    progressId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    badge?: SortOrder
    category?: SortOrder
    requirement?: SortOrder
    unlocked?: SortOrder
    progress?: SortOrder
    maxProgress?: SortOrder
    unlockedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type AchievementMinOrderByAggregateInput = {
    id?: SortOrder
    progressId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    badge?: SortOrder
    category?: SortOrder
    requirement?: SortOrder
    unlocked?: SortOrder
    progress?: SortOrder
    maxProgress?: SortOrder
    unlockedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type AchievementSumOrderByAggregateInput = {
    requirement?: SortOrder
    progress?: SortOrder
    maxProgress?: SortOrder
  }

  export type EnumAchievementCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AchievementCategory | EnumAchievementCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.AchievementCategory[] | ListEnumAchievementCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.AchievementCategory[] | ListEnumAchievementCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumAchievementCategoryWithAggregatesFilter<$PrismaModel> | $Enums.AchievementCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAchievementCategoryFilter<$PrismaModel>
    _max?: NestedEnumAchievementCategoryFilter<$PrismaModel>
  }

  export type DailyStatsProgressIdDateCompoundUniqueInput = {
    progressId: string
    date: string
  }

  export type DailyStatsCountOrderByAggregateInput = {
    id?: SortOrder
    progressId?: SortOrder
    date?: SortOrder
    totalXP?: SortOrder
    activitiesCompleted?: SortOrder
    streakCount?: SortOrder
    level?: SortOrder
    routineXP?: SortOrder
    taskXP?: SortOrder
    healthXP?: SortOrder
    focusXP?: SortOrder
    habitXP?: SortOrder
    createdAt?: SortOrder
  }

  export type DailyStatsAvgOrderByAggregateInput = {
    totalXP?: SortOrder
    activitiesCompleted?: SortOrder
    streakCount?: SortOrder
    level?: SortOrder
    routineXP?: SortOrder
    taskXP?: SortOrder
    healthXP?: SortOrder
    focusXP?: SortOrder
    habitXP?: SortOrder
  }

  export type DailyStatsMaxOrderByAggregateInput = {
    id?: SortOrder
    progressId?: SortOrder
    date?: SortOrder
    totalXP?: SortOrder
    activitiesCompleted?: SortOrder
    streakCount?: SortOrder
    level?: SortOrder
    routineXP?: SortOrder
    taskXP?: SortOrder
    healthXP?: SortOrder
    focusXP?: SortOrder
    habitXP?: SortOrder
    createdAt?: SortOrder
  }

  export type DailyStatsMinOrderByAggregateInput = {
    id?: SortOrder
    progressId?: SortOrder
    date?: SortOrder
    totalXP?: SortOrder
    activitiesCompleted?: SortOrder
    streakCount?: SortOrder
    level?: SortOrder
    routineXP?: SortOrder
    taskXP?: SortOrder
    healthXP?: SortOrder
    focusXP?: SortOrder
    habitXP?: SortOrder
    createdAt?: SortOrder
  }

  export type DailyStatsSumOrderByAggregateInput = {
    totalXP?: SortOrder
    activitiesCompleted?: SortOrder
    streakCount?: SortOrder
    level?: SortOrder
    routineXP?: SortOrder
    taskXP?: SortOrder
    healthXP?: SortOrder
    focusXP?: SortOrder
    habitXP?: SortOrder
  }

  export type XPBalanceCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    currentXP?: SortOrder
    totalEarned?: SortOrder
    totalSpent?: SortOrder
    reserveXP?: SortOrder
    pendingLoans?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type XPBalanceAvgOrderByAggregateInput = {
    currentXP?: SortOrder
    totalEarned?: SortOrder
    totalSpent?: SortOrder
    reserveXP?: SortOrder
    pendingLoans?: SortOrder
  }

  export type XPBalanceMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    currentXP?: SortOrder
    totalEarned?: SortOrder
    totalSpent?: SortOrder
    reserveXP?: SortOrder
    pendingLoans?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type XPBalanceMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    currentXP?: SortOrder
    totalEarned?: SortOrder
    totalSpent?: SortOrder
    reserveXP?: SortOrder
    pendingLoans?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type XPBalanceSumOrderByAggregateInput = {
    currentXP?: SortOrder
    totalEarned?: SortOrder
    totalSpent?: SortOrder
    reserveXP?: SortOrder
    pendingLoans?: SortOrder
  }

  export type RewardDefinitionScalarRelationFilter = {
    is?: RewardDefinitionWhereInput
    isNot?: RewardDefinitionWhereInput
  }

  export type XPPurchaseCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    rewardId?: SortOrder
    xpSpent?: SortOrder
    actualPrice?: SortOrder
    purchaseType?: SortOrder
    notes?: SortOrder
    satisfactionRating?: SortOrder
    guiltLevel?: SortOrder
    wasPlanned?: SortOrder
    celebrationLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type XPPurchaseAvgOrderByAggregateInput = {
    xpSpent?: SortOrder
    actualPrice?: SortOrder
    satisfactionRating?: SortOrder
    guiltLevel?: SortOrder
  }

  export type XPPurchaseMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    rewardId?: SortOrder
    xpSpent?: SortOrder
    actualPrice?: SortOrder
    purchaseType?: SortOrder
    notes?: SortOrder
    satisfactionRating?: SortOrder
    guiltLevel?: SortOrder
    wasPlanned?: SortOrder
    celebrationLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type XPPurchaseMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    rewardId?: SortOrder
    xpSpent?: SortOrder
    actualPrice?: SortOrder
    purchaseType?: SortOrder
    notes?: SortOrder
    satisfactionRating?: SortOrder
    guiltLevel?: SortOrder
    wasPlanned?: SortOrder
    celebrationLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type XPPurchaseSumOrderByAggregateInput = {
    xpSpent?: SortOrder
    actualPrice?: SortOrder
    satisfactionRating?: SortOrder
    guiltLevel?: SortOrder
  }

  export type XPEarningLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    source?: SortOrder
    sourceId?: SortOrder
    baseXP?: SortOrder
    finalXP?: SortOrder
    multipliers?: SortOrder
    createdAt?: SortOrder
  }

  export type XPEarningLogAvgOrderByAggregateInput = {
    baseXP?: SortOrder
    finalXP?: SortOrder
  }

  export type XPEarningLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    source?: SortOrder
    sourceId?: SortOrder
    baseXP?: SortOrder
    finalXP?: SortOrder
    createdAt?: SortOrder
  }

  export type XPEarningLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    source?: SortOrder
    sourceId?: SortOrder
    baseXP?: SortOrder
    finalXP?: SortOrder
    createdAt?: SortOrder
  }

  export type XPEarningLogSumOrderByAggregateInput = {
    baseXP?: SortOrder
    finalXP?: SortOrder
  }

  export type RewardDefinitionCountOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    name?: SortOrder
    description?: SortOrder
    basePrice?: SortOrder
    iconEmoji?: SortOrder
    isActive?: SortOrder
    requiresStreak?: SortOrder
    maxDailyUse?: SortOrder
    availabilityWindow?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RewardDefinitionAvgOrderByAggregateInput = {
    basePrice?: SortOrder
    requiresStreak?: SortOrder
    maxDailyUse?: SortOrder
  }

  export type RewardDefinitionMaxOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    name?: SortOrder
    description?: SortOrder
    basePrice?: SortOrder
    iconEmoji?: SortOrder
    isActive?: SortOrder
    requiresStreak?: SortOrder
    maxDailyUse?: SortOrder
    availabilityWindow?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RewardDefinitionMinOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    name?: SortOrder
    description?: SortOrder
    basePrice?: SortOrder
    iconEmoji?: SortOrder
    isActive?: SortOrder
    requiresStreak?: SortOrder
    maxDailyUse?: SortOrder
    availabilityWindow?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RewardDefinitionSumOrderByAggregateInput = {
    basePrice?: SortOrder
    requiresStreak?: SortOrder
    maxDailyUse?: SortOrder
  }

  export type LightWorkTaskCreateNestedManyWithoutUserInput = {
    create?: XOR<LightWorkTaskCreateWithoutUserInput, LightWorkTaskUncheckedCreateWithoutUserInput> | LightWorkTaskCreateWithoutUserInput[] | LightWorkTaskUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LightWorkTaskCreateOrConnectWithoutUserInput | LightWorkTaskCreateOrConnectWithoutUserInput[]
    createMany?: LightWorkTaskCreateManyUserInputEnvelope
    connect?: LightWorkTaskWhereUniqueInput | LightWorkTaskWhereUniqueInput[]
  }

  export type DeepWorkTaskCreateNestedManyWithoutUserInput = {
    create?: XOR<DeepWorkTaskCreateWithoutUserInput, DeepWorkTaskUncheckedCreateWithoutUserInput> | DeepWorkTaskCreateWithoutUserInput[] | DeepWorkTaskUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeepWorkTaskCreateOrConnectWithoutUserInput | DeepWorkTaskCreateOrConnectWithoutUserInput[]
    createMany?: DeepWorkTaskCreateManyUserInputEnvelope
    connect?: DeepWorkTaskWhereUniqueInput | DeepWorkTaskWhereUniqueInput[]
  }

  export type PersonalContextCreateNestedManyWithoutUserInput = {
    create?: XOR<PersonalContextCreateWithoutUserInput, PersonalContextUncheckedCreateWithoutUserInput> | PersonalContextCreateWithoutUserInput[] | PersonalContextUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PersonalContextCreateOrConnectWithoutUserInput | PersonalContextCreateOrConnectWithoutUserInput[]
    createMany?: PersonalContextCreateManyUserInputEnvelope
    connect?: PersonalContextWhereUniqueInput | PersonalContextWhereUniqueInput[]
  }

  export type AutomationTaskCreateNestedManyWithoutUserInput = {
    create?: XOR<AutomationTaskCreateWithoutUserInput, AutomationTaskUncheckedCreateWithoutUserInput> | AutomationTaskCreateWithoutUserInput[] | AutomationTaskUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AutomationTaskCreateOrConnectWithoutUserInput | AutomationTaskCreateOrConnectWithoutUserInput[]
    createMany?: AutomationTaskCreateManyUserInputEnvelope
    connect?: AutomationTaskWhereUniqueInput | AutomationTaskWhereUniqueInput[]
  }

  export type DailyHabitsCreateNestedManyWithoutUserInput = {
    create?: XOR<DailyHabitsCreateWithoutUserInput, DailyHabitsUncheckedCreateWithoutUserInput> | DailyHabitsCreateWithoutUserInput[] | DailyHabitsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DailyHabitsCreateOrConnectWithoutUserInput | DailyHabitsCreateOrConnectWithoutUserInput[]
    createMany?: DailyHabitsCreateManyUserInputEnvelope
    connect?: DailyHabitsWhereUniqueInput | DailyHabitsWhereUniqueInput[]
  }

  export type DailyHealthCreateNestedManyWithoutUserInput = {
    create?: XOR<DailyHealthCreateWithoutUserInput, DailyHealthUncheckedCreateWithoutUserInput> | DailyHealthCreateWithoutUserInput[] | DailyHealthUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DailyHealthCreateOrConnectWithoutUserInput | DailyHealthCreateOrConnectWithoutUserInput[]
    createMany?: DailyHealthCreateManyUserInputEnvelope
    connect?: DailyHealthWhereUniqueInput | DailyHealthWhereUniqueInput[]
  }

  export type DailyWorkoutCreateNestedManyWithoutUserInput = {
    create?: XOR<DailyWorkoutCreateWithoutUserInput, DailyWorkoutUncheckedCreateWithoutUserInput> | DailyWorkoutCreateWithoutUserInput[] | DailyWorkoutUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DailyWorkoutCreateOrConnectWithoutUserInput | DailyWorkoutCreateOrConnectWithoutUserInput[]
    createMany?: DailyWorkoutCreateManyUserInputEnvelope
    connect?: DailyWorkoutWhereUniqueInput | DailyWorkoutWhereUniqueInput[]
  }

  export type DailyRoutineCreateNestedManyWithoutUserInput = {
    create?: XOR<DailyRoutineCreateWithoutUserInput, DailyRoutineUncheckedCreateWithoutUserInput> | DailyRoutineCreateWithoutUserInput[] | DailyRoutineUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DailyRoutineCreateOrConnectWithoutUserInput | DailyRoutineCreateOrConnectWithoutUserInput[]
    createMany?: DailyRoutineCreateManyUserInputEnvelope
    connect?: DailyRoutineWhereUniqueInput | DailyRoutineWhereUniqueInput[]
  }

  export type DailyReflectionsCreateNestedManyWithoutUserInput = {
    create?: XOR<DailyReflectionsCreateWithoutUserInput, DailyReflectionsUncheckedCreateWithoutUserInput> | DailyReflectionsCreateWithoutUserInput[] | DailyReflectionsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DailyReflectionsCreateOrConnectWithoutUserInput | DailyReflectionsCreateOrConnectWithoutUserInput[]
    createMany?: DailyReflectionsCreateManyUserInputEnvelope
    connect?: DailyReflectionsWhereUniqueInput | DailyReflectionsWhereUniqueInput[]
  }

  export type TimeBlockCreateNestedManyWithoutUserInput = {
    create?: XOR<TimeBlockCreateWithoutUserInput, TimeBlockUncheckedCreateWithoutUserInput> | TimeBlockCreateWithoutUserInput[] | TimeBlockUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TimeBlockCreateOrConnectWithoutUserInput | TimeBlockCreateOrConnectWithoutUserInput[]
    createMany?: TimeBlockCreateManyUserInputEnvelope
    connect?: TimeBlockWhereUniqueInput | TimeBlockWhereUniqueInput[]
  }

  export type UserProgressCreateNestedManyWithoutUserInput = {
    create?: XOR<UserProgressCreateWithoutUserInput, UserProgressUncheckedCreateWithoutUserInput> | UserProgressCreateWithoutUserInput[] | UserProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserProgressCreateOrConnectWithoutUserInput | UserProgressCreateOrConnectWithoutUserInput[]
    createMany?: UserProgressCreateManyUserInputEnvelope
    connect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
  }

  export type XPBalanceCreateNestedManyWithoutUserInput = {
    create?: XOR<XPBalanceCreateWithoutUserInput, XPBalanceUncheckedCreateWithoutUserInput> | XPBalanceCreateWithoutUserInput[] | XPBalanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: XPBalanceCreateOrConnectWithoutUserInput | XPBalanceCreateOrConnectWithoutUserInput[]
    createMany?: XPBalanceCreateManyUserInputEnvelope
    connect?: XPBalanceWhereUniqueInput | XPBalanceWhereUniqueInput[]
  }

  export type XPPurchaseCreateNestedManyWithoutUserInput = {
    create?: XOR<XPPurchaseCreateWithoutUserInput, XPPurchaseUncheckedCreateWithoutUserInput> | XPPurchaseCreateWithoutUserInput[] | XPPurchaseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: XPPurchaseCreateOrConnectWithoutUserInput | XPPurchaseCreateOrConnectWithoutUserInput[]
    createMany?: XPPurchaseCreateManyUserInputEnvelope
    connect?: XPPurchaseWhereUniqueInput | XPPurchaseWhereUniqueInput[]
  }

  export type XPEarningLogCreateNestedManyWithoutUserInput = {
    create?: XOR<XPEarningLogCreateWithoutUserInput, XPEarningLogUncheckedCreateWithoutUserInput> | XPEarningLogCreateWithoutUserInput[] | XPEarningLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: XPEarningLogCreateOrConnectWithoutUserInput | XPEarningLogCreateOrConnectWithoutUserInput[]
    createMany?: XPEarningLogCreateManyUserInputEnvelope
    connect?: XPEarningLogWhereUniqueInput | XPEarningLogWhereUniqueInput[]
  }

  export type LightWorkTaskUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LightWorkTaskCreateWithoutUserInput, LightWorkTaskUncheckedCreateWithoutUserInput> | LightWorkTaskCreateWithoutUserInput[] | LightWorkTaskUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LightWorkTaskCreateOrConnectWithoutUserInput | LightWorkTaskCreateOrConnectWithoutUserInput[]
    createMany?: LightWorkTaskCreateManyUserInputEnvelope
    connect?: LightWorkTaskWhereUniqueInput | LightWorkTaskWhereUniqueInput[]
  }

  export type DeepWorkTaskUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DeepWorkTaskCreateWithoutUserInput, DeepWorkTaskUncheckedCreateWithoutUserInput> | DeepWorkTaskCreateWithoutUserInput[] | DeepWorkTaskUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeepWorkTaskCreateOrConnectWithoutUserInput | DeepWorkTaskCreateOrConnectWithoutUserInput[]
    createMany?: DeepWorkTaskCreateManyUserInputEnvelope
    connect?: DeepWorkTaskWhereUniqueInput | DeepWorkTaskWhereUniqueInput[]
  }

  export type PersonalContextUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PersonalContextCreateWithoutUserInput, PersonalContextUncheckedCreateWithoutUserInput> | PersonalContextCreateWithoutUserInput[] | PersonalContextUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PersonalContextCreateOrConnectWithoutUserInput | PersonalContextCreateOrConnectWithoutUserInput[]
    createMany?: PersonalContextCreateManyUserInputEnvelope
    connect?: PersonalContextWhereUniqueInput | PersonalContextWhereUniqueInput[]
  }

  export type AutomationTaskUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AutomationTaskCreateWithoutUserInput, AutomationTaskUncheckedCreateWithoutUserInput> | AutomationTaskCreateWithoutUserInput[] | AutomationTaskUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AutomationTaskCreateOrConnectWithoutUserInput | AutomationTaskCreateOrConnectWithoutUserInput[]
    createMany?: AutomationTaskCreateManyUserInputEnvelope
    connect?: AutomationTaskWhereUniqueInput | AutomationTaskWhereUniqueInput[]
  }

  export type DailyHabitsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DailyHabitsCreateWithoutUserInput, DailyHabitsUncheckedCreateWithoutUserInput> | DailyHabitsCreateWithoutUserInput[] | DailyHabitsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DailyHabitsCreateOrConnectWithoutUserInput | DailyHabitsCreateOrConnectWithoutUserInput[]
    createMany?: DailyHabitsCreateManyUserInputEnvelope
    connect?: DailyHabitsWhereUniqueInput | DailyHabitsWhereUniqueInput[]
  }

  export type DailyHealthUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DailyHealthCreateWithoutUserInput, DailyHealthUncheckedCreateWithoutUserInput> | DailyHealthCreateWithoutUserInput[] | DailyHealthUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DailyHealthCreateOrConnectWithoutUserInput | DailyHealthCreateOrConnectWithoutUserInput[]
    createMany?: DailyHealthCreateManyUserInputEnvelope
    connect?: DailyHealthWhereUniqueInput | DailyHealthWhereUniqueInput[]
  }

  export type DailyWorkoutUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DailyWorkoutCreateWithoutUserInput, DailyWorkoutUncheckedCreateWithoutUserInput> | DailyWorkoutCreateWithoutUserInput[] | DailyWorkoutUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DailyWorkoutCreateOrConnectWithoutUserInput | DailyWorkoutCreateOrConnectWithoutUserInput[]
    createMany?: DailyWorkoutCreateManyUserInputEnvelope
    connect?: DailyWorkoutWhereUniqueInput | DailyWorkoutWhereUniqueInput[]
  }

  export type DailyRoutineUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DailyRoutineCreateWithoutUserInput, DailyRoutineUncheckedCreateWithoutUserInput> | DailyRoutineCreateWithoutUserInput[] | DailyRoutineUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DailyRoutineCreateOrConnectWithoutUserInput | DailyRoutineCreateOrConnectWithoutUserInput[]
    createMany?: DailyRoutineCreateManyUserInputEnvelope
    connect?: DailyRoutineWhereUniqueInput | DailyRoutineWhereUniqueInput[]
  }

  export type DailyReflectionsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DailyReflectionsCreateWithoutUserInput, DailyReflectionsUncheckedCreateWithoutUserInput> | DailyReflectionsCreateWithoutUserInput[] | DailyReflectionsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DailyReflectionsCreateOrConnectWithoutUserInput | DailyReflectionsCreateOrConnectWithoutUserInput[]
    createMany?: DailyReflectionsCreateManyUserInputEnvelope
    connect?: DailyReflectionsWhereUniqueInput | DailyReflectionsWhereUniqueInput[]
  }

  export type TimeBlockUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TimeBlockCreateWithoutUserInput, TimeBlockUncheckedCreateWithoutUserInput> | TimeBlockCreateWithoutUserInput[] | TimeBlockUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TimeBlockCreateOrConnectWithoutUserInput | TimeBlockCreateOrConnectWithoutUserInput[]
    createMany?: TimeBlockCreateManyUserInputEnvelope
    connect?: TimeBlockWhereUniqueInput | TimeBlockWhereUniqueInput[]
  }

  export type UserProgressUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserProgressCreateWithoutUserInput, UserProgressUncheckedCreateWithoutUserInput> | UserProgressCreateWithoutUserInput[] | UserProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserProgressCreateOrConnectWithoutUserInput | UserProgressCreateOrConnectWithoutUserInput[]
    createMany?: UserProgressCreateManyUserInputEnvelope
    connect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
  }

  export type XPBalanceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<XPBalanceCreateWithoutUserInput, XPBalanceUncheckedCreateWithoutUserInput> | XPBalanceCreateWithoutUserInput[] | XPBalanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: XPBalanceCreateOrConnectWithoutUserInput | XPBalanceCreateOrConnectWithoutUserInput[]
    createMany?: XPBalanceCreateManyUserInputEnvelope
    connect?: XPBalanceWhereUniqueInput | XPBalanceWhereUniqueInput[]
  }

  export type XPPurchaseUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<XPPurchaseCreateWithoutUserInput, XPPurchaseUncheckedCreateWithoutUserInput> | XPPurchaseCreateWithoutUserInput[] | XPPurchaseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: XPPurchaseCreateOrConnectWithoutUserInput | XPPurchaseCreateOrConnectWithoutUserInput[]
    createMany?: XPPurchaseCreateManyUserInputEnvelope
    connect?: XPPurchaseWhereUniqueInput | XPPurchaseWhereUniqueInput[]
  }

  export type XPEarningLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<XPEarningLogCreateWithoutUserInput, XPEarningLogUncheckedCreateWithoutUserInput> | XPEarningLogCreateWithoutUserInput[] | XPEarningLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: XPEarningLogCreateOrConnectWithoutUserInput | XPEarningLogCreateOrConnectWithoutUserInput[]
    createMany?: XPEarningLogCreateManyUserInputEnvelope
    connect?: XPEarningLogWhereUniqueInput | XPEarningLogWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type LightWorkTaskUpdateManyWithoutUserNestedInput = {
    create?: XOR<LightWorkTaskCreateWithoutUserInput, LightWorkTaskUncheckedCreateWithoutUserInput> | LightWorkTaskCreateWithoutUserInput[] | LightWorkTaskUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LightWorkTaskCreateOrConnectWithoutUserInput | LightWorkTaskCreateOrConnectWithoutUserInput[]
    upsert?: LightWorkTaskUpsertWithWhereUniqueWithoutUserInput | LightWorkTaskUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LightWorkTaskCreateManyUserInputEnvelope
    set?: LightWorkTaskWhereUniqueInput | LightWorkTaskWhereUniqueInput[]
    disconnect?: LightWorkTaskWhereUniqueInput | LightWorkTaskWhereUniqueInput[]
    delete?: LightWorkTaskWhereUniqueInput | LightWorkTaskWhereUniqueInput[]
    connect?: LightWorkTaskWhereUniqueInput | LightWorkTaskWhereUniqueInput[]
    update?: LightWorkTaskUpdateWithWhereUniqueWithoutUserInput | LightWorkTaskUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LightWorkTaskUpdateManyWithWhereWithoutUserInput | LightWorkTaskUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LightWorkTaskScalarWhereInput | LightWorkTaskScalarWhereInput[]
  }

  export type DeepWorkTaskUpdateManyWithoutUserNestedInput = {
    create?: XOR<DeepWorkTaskCreateWithoutUserInput, DeepWorkTaskUncheckedCreateWithoutUserInput> | DeepWorkTaskCreateWithoutUserInput[] | DeepWorkTaskUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeepWorkTaskCreateOrConnectWithoutUserInput | DeepWorkTaskCreateOrConnectWithoutUserInput[]
    upsert?: DeepWorkTaskUpsertWithWhereUniqueWithoutUserInput | DeepWorkTaskUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DeepWorkTaskCreateManyUserInputEnvelope
    set?: DeepWorkTaskWhereUniqueInput | DeepWorkTaskWhereUniqueInput[]
    disconnect?: DeepWorkTaskWhereUniqueInput | DeepWorkTaskWhereUniqueInput[]
    delete?: DeepWorkTaskWhereUniqueInput | DeepWorkTaskWhereUniqueInput[]
    connect?: DeepWorkTaskWhereUniqueInput | DeepWorkTaskWhereUniqueInput[]
    update?: DeepWorkTaskUpdateWithWhereUniqueWithoutUserInput | DeepWorkTaskUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DeepWorkTaskUpdateManyWithWhereWithoutUserInput | DeepWorkTaskUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DeepWorkTaskScalarWhereInput | DeepWorkTaskScalarWhereInput[]
  }

  export type PersonalContextUpdateManyWithoutUserNestedInput = {
    create?: XOR<PersonalContextCreateWithoutUserInput, PersonalContextUncheckedCreateWithoutUserInput> | PersonalContextCreateWithoutUserInput[] | PersonalContextUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PersonalContextCreateOrConnectWithoutUserInput | PersonalContextCreateOrConnectWithoutUserInput[]
    upsert?: PersonalContextUpsertWithWhereUniqueWithoutUserInput | PersonalContextUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PersonalContextCreateManyUserInputEnvelope
    set?: PersonalContextWhereUniqueInput | PersonalContextWhereUniqueInput[]
    disconnect?: PersonalContextWhereUniqueInput | PersonalContextWhereUniqueInput[]
    delete?: PersonalContextWhereUniqueInput | PersonalContextWhereUniqueInput[]
    connect?: PersonalContextWhereUniqueInput | PersonalContextWhereUniqueInput[]
    update?: PersonalContextUpdateWithWhereUniqueWithoutUserInput | PersonalContextUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PersonalContextUpdateManyWithWhereWithoutUserInput | PersonalContextUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PersonalContextScalarWhereInput | PersonalContextScalarWhereInput[]
  }

  export type AutomationTaskUpdateManyWithoutUserNestedInput = {
    create?: XOR<AutomationTaskCreateWithoutUserInput, AutomationTaskUncheckedCreateWithoutUserInput> | AutomationTaskCreateWithoutUserInput[] | AutomationTaskUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AutomationTaskCreateOrConnectWithoutUserInput | AutomationTaskCreateOrConnectWithoutUserInput[]
    upsert?: AutomationTaskUpsertWithWhereUniqueWithoutUserInput | AutomationTaskUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AutomationTaskCreateManyUserInputEnvelope
    set?: AutomationTaskWhereUniqueInput | AutomationTaskWhereUniqueInput[]
    disconnect?: AutomationTaskWhereUniqueInput | AutomationTaskWhereUniqueInput[]
    delete?: AutomationTaskWhereUniqueInput | AutomationTaskWhereUniqueInput[]
    connect?: AutomationTaskWhereUniqueInput | AutomationTaskWhereUniqueInput[]
    update?: AutomationTaskUpdateWithWhereUniqueWithoutUserInput | AutomationTaskUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AutomationTaskUpdateManyWithWhereWithoutUserInput | AutomationTaskUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AutomationTaskScalarWhereInput | AutomationTaskScalarWhereInput[]
  }

  export type DailyHabitsUpdateManyWithoutUserNestedInput = {
    create?: XOR<DailyHabitsCreateWithoutUserInput, DailyHabitsUncheckedCreateWithoutUserInput> | DailyHabitsCreateWithoutUserInput[] | DailyHabitsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DailyHabitsCreateOrConnectWithoutUserInput | DailyHabitsCreateOrConnectWithoutUserInput[]
    upsert?: DailyHabitsUpsertWithWhereUniqueWithoutUserInput | DailyHabitsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DailyHabitsCreateManyUserInputEnvelope
    set?: DailyHabitsWhereUniqueInput | DailyHabitsWhereUniqueInput[]
    disconnect?: DailyHabitsWhereUniqueInput | DailyHabitsWhereUniqueInput[]
    delete?: DailyHabitsWhereUniqueInput | DailyHabitsWhereUniqueInput[]
    connect?: DailyHabitsWhereUniqueInput | DailyHabitsWhereUniqueInput[]
    update?: DailyHabitsUpdateWithWhereUniqueWithoutUserInput | DailyHabitsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DailyHabitsUpdateManyWithWhereWithoutUserInput | DailyHabitsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DailyHabitsScalarWhereInput | DailyHabitsScalarWhereInput[]
  }

  export type DailyHealthUpdateManyWithoutUserNestedInput = {
    create?: XOR<DailyHealthCreateWithoutUserInput, DailyHealthUncheckedCreateWithoutUserInput> | DailyHealthCreateWithoutUserInput[] | DailyHealthUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DailyHealthCreateOrConnectWithoutUserInput | DailyHealthCreateOrConnectWithoutUserInput[]
    upsert?: DailyHealthUpsertWithWhereUniqueWithoutUserInput | DailyHealthUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DailyHealthCreateManyUserInputEnvelope
    set?: DailyHealthWhereUniqueInput | DailyHealthWhereUniqueInput[]
    disconnect?: DailyHealthWhereUniqueInput | DailyHealthWhereUniqueInput[]
    delete?: DailyHealthWhereUniqueInput | DailyHealthWhereUniqueInput[]
    connect?: DailyHealthWhereUniqueInput | DailyHealthWhereUniqueInput[]
    update?: DailyHealthUpdateWithWhereUniqueWithoutUserInput | DailyHealthUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DailyHealthUpdateManyWithWhereWithoutUserInput | DailyHealthUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DailyHealthScalarWhereInput | DailyHealthScalarWhereInput[]
  }

  export type DailyWorkoutUpdateManyWithoutUserNestedInput = {
    create?: XOR<DailyWorkoutCreateWithoutUserInput, DailyWorkoutUncheckedCreateWithoutUserInput> | DailyWorkoutCreateWithoutUserInput[] | DailyWorkoutUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DailyWorkoutCreateOrConnectWithoutUserInput | DailyWorkoutCreateOrConnectWithoutUserInput[]
    upsert?: DailyWorkoutUpsertWithWhereUniqueWithoutUserInput | DailyWorkoutUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DailyWorkoutCreateManyUserInputEnvelope
    set?: DailyWorkoutWhereUniqueInput | DailyWorkoutWhereUniqueInput[]
    disconnect?: DailyWorkoutWhereUniqueInput | DailyWorkoutWhereUniqueInput[]
    delete?: DailyWorkoutWhereUniqueInput | DailyWorkoutWhereUniqueInput[]
    connect?: DailyWorkoutWhereUniqueInput | DailyWorkoutWhereUniqueInput[]
    update?: DailyWorkoutUpdateWithWhereUniqueWithoutUserInput | DailyWorkoutUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DailyWorkoutUpdateManyWithWhereWithoutUserInput | DailyWorkoutUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DailyWorkoutScalarWhereInput | DailyWorkoutScalarWhereInput[]
  }

  export type DailyRoutineUpdateManyWithoutUserNestedInput = {
    create?: XOR<DailyRoutineCreateWithoutUserInput, DailyRoutineUncheckedCreateWithoutUserInput> | DailyRoutineCreateWithoutUserInput[] | DailyRoutineUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DailyRoutineCreateOrConnectWithoutUserInput | DailyRoutineCreateOrConnectWithoutUserInput[]
    upsert?: DailyRoutineUpsertWithWhereUniqueWithoutUserInput | DailyRoutineUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DailyRoutineCreateManyUserInputEnvelope
    set?: DailyRoutineWhereUniqueInput | DailyRoutineWhereUniqueInput[]
    disconnect?: DailyRoutineWhereUniqueInput | DailyRoutineWhereUniqueInput[]
    delete?: DailyRoutineWhereUniqueInput | DailyRoutineWhereUniqueInput[]
    connect?: DailyRoutineWhereUniqueInput | DailyRoutineWhereUniqueInput[]
    update?: DailyRoutineUpdateWithWhereUniqueWithoutUserInput | DailyRoutineUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DailyRoutineUpdateManyWithWhereWithoutUserInput | DailyRoutineUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DailyRoutineScalarWhereInput | DailyRoutineScalarWhereInput[]
  }

  export type DailyReflectionsUpdateManyWithoutUserNestedInput = {
    create?: XOR<DailyReflectionsCreateWithoutUserInput, DailyReflectionsUncheckedCreateWithoutUserInput> | DailyReflectionsCreateWithoutUserInput[] | DailyReflectionsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DailyReflectionsCreateOrConnectWithoutUserInput | DailyReflectionsCreateOrConnectWithoutUserInput[]
    upsert?: DailyReflectionsUpsertWithWhereUniqueWithoutUserInput | DailyReflectionsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DailyReflectionsCreateManyUserInputEnvelope
    set?: DailyReflectionsWhereUniqueInput | DailyReflectionsWhereUniqueInput[]
    disconnect?: DailyReflectionsWhereUniqueInput | DailyReflectionsWhereUniqueInput[]
    delete?: DailyReflectionsWhereUniqueInput | DailyReflectionsWhereUniqueInput[]
    connect?: DailyReflectionsWhereUniqueInput | DailyReflectionsWhereUniqueInput[]
    update?: DailyReflectionsUpdateWithWhereUniqueWithoutUserInput | DailyReflectionsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DailyReflectionsUpdateManyWithWhereWithoutUserInput | DailyReflectionsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DailyReflectionsScalarWhereInput | DailyReflectionsScalarWhereInput[]
  }

  export type TimeBlockUpdateManyWithoutUserNestedInput = {
    create?: XOR<TimeBlockCreateWithoutUserInput, TimeBlockUncheckedCreateWithoutUserInput> | TimeBlockCreateWithoutUserInput[] | TimeBlockUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TimeBlockCreateOrConnectWithoutUserInput | TimeBlockCreateOrConnectWithoutUserInput[]
    upsert?: TimeBlockUpsertWithWhereUniqueWithoutUserInput | TimeBlockUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TimeBlockCreateManyUserInputEnvelope
    set?: TimeBlockWhereUniqueInput | TimeBlockWhereUniqueInput[]
    disconnect?: TimeBlockWhereUniqueInput | TimeBlockWhereUniqueInput[]
    delete?: TimeBlockWhereUniqueInput | TimeBlockWhereUniqueInput[]
    connect?: TimeBlockWhereUniqueInput | TimeBlockWhereUniqueInput[]
    update?: TimeBlockUpdateWithWhereUniqueWithoutUserInput | TimeBlockUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TimeBlockUpdateManyWithWhereWithoutUserInput | TimeBlockUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TimeBlockScalarWhereInput | TimeBlockScalarWhereInput[]
  }

  export type UserProgressUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserProgressCreateWithoutUserInput, UserProgressUncheckedCreateWithoutUserInput> | UserProgressCreateWithoutUserInput[] | UserProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserProgressCreateOrConnectWithoutUserInput | UserProgressCreateOrConnectWithoutUserInput[]
    upsert?: UserProgressUpsertWithWhereUniqueWithoutUserInput | UserProgressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserProgressCreateManyUserInputEnvelope
    set?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    disconnect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    delete?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    connect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    update?: UserProgressUpdateWithWhereUniqueWithoutUserInput | UserProgressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserProgressUpdateManyWithWhereWithoutUserInput | UserProgressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserProgressScalarWhereInput | UserProgressScalarWhereInput[]
  }

  export type XPBalanceUpdateManyWithoutUserNestedInput = {
    create?: XOR<XPBalanceCreateWithoutUserInput, XPBalanceUncheckedCreateWithoutUserInput> | XPBalanceCreateWithoutUserInput[] | XPBalanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: XPBalanceCreateOrConnectWithoutUserInput | XPBalanceCreateOrConnectWithoutUserInput[]
    upsert?: XPBalanceUpsertWithWhereUniqueWithoutUserInput | XPBalanceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: XPBalanceCreateManyUserInputEnvelope
    set?: XPBalanceWhereUniqueInput | XPBalanceWhereUniqueInput[]
    disconnect?: XPBalanceWhereUniqueInput | XPBalanceWhereUniqueInput[]
    delete?: XPBalanceWhereUniqueInput | XPBalanceWhereUniqueInput[]
    connect?: XPBalanceWhereUniqueInput | XPBalanceWhereUniqueInput[]
    update?: XPBalanceUpdateWithWhereUniqueWithoutUserInput | XPBalanceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: XPBalanceUpdateManyWithWhereWithoutUserInput | XPBalanceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: XPBalanceScalarWhereInput | XPBalanceScalarWhereInput[]
  }

  export type XPPurchaseUpdateManyWithoutUserNestedInput = {
    create?: XOR<XPPurchaseCreateWithoutUserInput, XPPurchaseUncheckedCreateWithoutUserInput> | XPPurchaseCreateWithoutUserInput[] | XPPurchaseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: XPPurchaseCreateOrConnectWithoutUserInput | XPPurchaseCreateOrConnectWithoutUserInput[]
    upsert?: XPPurchaseUpsertWithWhereUniqueWithoutUserInput | XPPurchaseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: XPPurchaseCreateManyUserInputEnvelope
    set?: XPPurchaseWhereUniqueInput | XPPurchaseWhereUniqueInput[]
    disconnect?: XPPurchaseWhereUniqueInput | XPPurchaseWhereUniqueInput[]
    delete?: XPPurchaseWhereUniqueInput | XPPurchaseWhereUniqueInput[]
    connect?: XPPurchaseWhereUniqueInput | XPPurchaseWhereUniqueInput[]
    update?: XPPurchaseUpdateWithWhereUniqueWithoutUserInput | XPPurchaseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: XPPurchaseUpdateManyWithWhereWithoutUserInput | XPPurchaseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: XPPurchaseScalarWhereInput | XPPurchaseScalarWhereInput[]
  }

  export type XPEarningLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<XPEarningLogCreateWithoutUserInput, XPEarningLogUncheckedCreateWithoutUserInput> | XPEarningLogCreateWithoutUserInput[] | XPEarningLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: XPEarningLogCreateOrConnectWithoutUserInput | XPEarningLogCreateOrConnectWithoutUserInput[]
    upsert?: XPEarningLogUpsertWithWhereUniqueWithoutUserInput | XPEarningLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: XPEarningLogCreateManyUserInputEnvelope
    set?: XPEarningLogWhereUniqueInput | XPEarningLogWhereUniqueInput[]
    disconnect?: XPEarningLogWhereUniqueInput | XPEarningLogWhereUniqueInput[]
    delete?: XPEarningLogWhereUniqueInput | XPEarningLogWhereUniqueInput[]
    connect?: XPEarningLogWhereUniqueInput | XPEarningLogWhereUniqueInput[]
    update?: XPEarningLogUpdateWithWhereUniqueWithoutUserInput | XPEarningLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: XPEarningLogUpdateManyWithWhereWithoutUserInput | XPEarningLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: XPEarningLogScalarWhereInput | XPEarningLogScalarWhereInput[]
  }

  export type LightWorkTaskUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LightWorkTaskCreateWithoutUserInput, LightWorkTaskUncheckedCreateWithoutUserInput> | LightWorkTaskCreateWithoutUserInput[] | LightWorkTaskUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LightWorkTaskCreateOrConnectWithoutUserInput | LightWorkTaskCreateOrConnectWithoutUserInput[]
    upsert?: LightWorkTaskUpsertWithWhereUniqueWithoutUserInput | LightWorkTaskUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LightWorkTaskCreateManyUserInputEnvelope
    set?: LightWorkTaskWhereUniqueInput | LightWorkTaskWhereUniqueInput[]
    disconnect?: LightWorkTaskWhereUniqueInput | LightWorkTaskWhereUniqueInput[]
    delete?: LightWorkTaskWhereUniqueInput | LightWorkTaskWhereUniqueInput[]
    connect?: LightWorkTaskWhereUniqueInput | LightWorkTaskWhereUniqueInput[]
    update?: LightWorkTaskUpdateWithWhereUniqueWithoutUserInput | LightWorkTaskUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LightWorkTaskUpdateManyWithWhereWithoutUserInput | LightWorkTaskUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LightWorkTaskScalarWhereInput | LightWorkTaskScalarWhereInput[]
  }

  export type DeepWorkTaskUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DeepWorkTaskCreateWithoutUserInput, DeepWorkTaskUncheckedCreateWithoutUserInput> | DeepWorkTaskCreateWithoutUserInput[] | DeepWorkTaskUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeepWorkTaskCreateOrConnectWithoutUserInput | DeepWorkTaskCreateOrConnectWithoutUserInput[]
    upsert?: DeepWorkTaskUpsertWithWhereUniqueWithoutUserInput | DeepWorkTaskUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DeepWorkTaskCreateManyUserInputEnvelope
    set?: DeepWorkTaskWhereUniqueInput | DeepWorkTaskWhereUniqueInput[]
    disconnect?: DeepWorkTaskWhereUniqueInput | DeepWorkTaskWhereUniqueInput[]
    delete?: DeepWorkTaskWhereUniqueInput | DeepWorkTaskWhereUniqueInput[]
    connect?: DeepWorkTaskWhereUniqueInput | DeepWorkTaskWhereUniqueInput[]
    update?: DeepWorkTaskUpdateWithWhereUniqueWithoutUserInput | DeepWorkTaskUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DeepWorkTaskUpdateManyWithWhereWithoutUserInput | DeepWorkTaskUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DeepWorkTaskScalarWhereInput | DeepWorkTaskScalarWhereInput[]
  }

  export type PersonalContextUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PersonalContextCreateWithoutUserInput, PersonalContextUncheckedCreateWithoutUserInput> | PersonalContextCreateWithoutUserInput[] | PersonalContextUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PersonalContextCreateOrConnectWithoutUserInput | PersonalContextCreateOrConnectWithoutUserInput[]
    upsert?: PersonalContextUpsertWithWhereUniqueWithoutUserInput | PersonalContextUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PersonalContextCreateManyUserInputEnvelope
    set?: PersonalContextWhereUniqueInput | PersonalContextWhereUniqueInput[]
    disconnect?: PersonalContextWhereUniqueInput | PersonalContextWhereUniqueInput[]
    delete?: PersonalContextWhereUniqueInput | PersonalContextWhereUniqueInput[]
    connect?: PersonalContextWhereUniqueInput | PersonalContextWhereUniqueInput[]
    update?: PersonalContextUpdateWithWhereUniqueWithoutUserInput | PersonalContextUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PersonalContextUpdateManyWithWhereWithoutUserInput | PersonalContextUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PersonalContextScalarWhereInput | PersonalContextScalarWhereInput[]
  }

  export type AutomationTaskUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AutomationTaskCreateWithoutUserInput, AutomationTaskUncheckedCreateWithoutUserInput> | AutomationTaskCreateWithoutUserInput[] | AutomationTaskUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AutomationTaskCreateOrConnectWithoutUserInput | AutomationTaskCreateOrConnectWithoutUserInput[]
    upsert?: AutomationTaskUpsertWithWhereUniqueWithoutUserInput | AutomationTaskUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AutomationTaskCreateManyUserInputEnvelope
    set?: AutomationTaskWhereUniqueInput | AutomationTaskWhereUniqueInput[]
    disconnect?: AutomationTaskWhereUniqueInput | AutomationTaskWhereUniqueInput[]
    delete?: AutomationTaskWhereUniqueInput | AutomationTaskWhereUniqueInput[]
    connect?: AutomationTaskWhereUniqueInput | AutomationTaskWhereUniqueInput[]
    update?: AutomationTaskUpdateWithWhereUniqueWithoutUserInput | AutomationTaskUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AutomationTaskUpdateManyWithWhereWithoutUserInput | AutomationTaskUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AutomationTaskScalarWhereInput | AutomationTaskScalarWhereInput[]
  }

  export type DailyHabitsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DailyHabitsCreateWithoutUserInput, DailyHabitsUncheckedCreateWithoutUserInput> | DailyHabitsCreateWithoutUserInput[] | DailyHabitsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DailyHabitsCreateOrConnectWithoutUserInput | DailyHabitsCreateOrConnectWithoutUserInput[]
    upsert?: DailyHabitsUpsertWithWhereUniqueWithoutUserInput | DailyHabitsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DailyHabitsCreateManyUserInputEnvelope
    set?: DailyHabitsWhereUniqueInput | DailyHabitsWhereUniqueInput[]
    disconnect?: DailyHabitsWhereUniqueInput | DailyHabitsWhereUniqueInput[]
    delete?: DailyHabitsWhereUniqueInput | DailyHabitsWhereUniqueInput[]
    connect?: DailyHabitsWhereUniqueInput | DailyHabitsWhereUniqueInput[]
    update?: DailyHabitsUpdateWithWhereUniqueWithoutUserInput | DailyHabitsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DailyHabitsUpdateManyWithWhereWithoutUserInput | DailyHabitsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DailyHabitsScalarWhereInput | DailyHabitsScalarWhereInput[]
  }

  export type DailyHealthUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DailyHealthCreateWithoutUserInput, DailyHealthUncheckedCreateWithoutUserInput> | DailyHealthCreateWithoutUserInput[] | DailyHealthUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DailyHealthCreateOrConnectWithoutUserInput | DailyHealthCreateOrConnectWithoutUserInput[]
    upsert?: DailyHealthUpsertWithWhereUniqueWithoutUserInput | DailyHealthUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DailyHealthCreateManyUserInputEnvelope
    set?: DailyHealthWhereUniqueInput | DailyHealthWhereUniqueInput[]
    disconnect?: DailyHealthWhereUniqueInput | DailyHealthWhereUniqueInput[]
    delete?: DailyHealthWhereUniqueInput | DailyHealthWhereUniqueInput[]
    connect?: DailyHealthWhereUniqueInput | DailyHealthWhereUniqueInput[]
    update?: DailyHealthUpdateWithWhereUniqueWithoutUserInput | DailyHealthUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DailyHealthUpdateManyWithWhereWithoutUserInput | DailyHealthUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DailyHealthScalarWhereInput | DailyHealthScalarWhereInput[]
  }

  export type DailyWorkoutUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DailyWorkoutCreateWithoutUserInput, DailyWorkoutUncheckedCreateWithoutUserInput> | DailyWorkoutCreateWithoutUserInput[] | DailyWorkoutUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DailyWorkoutCreateOrConnectWithoutUserInput | DailyWorkoutCreateOrConnectWithoutUserInput[]
    upsert?: DailyWorkoutUpsertWithWhereUniqueWithoutUserInput | DailyWorkoutUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DailyWorkoutCreateManyUserInputEnvelope
    set?: DailyWorkoutWhereUniqueInput | DailyWorkoutWhereUniqueInput[]
    disconnect?: DailyWorkoutWhereUniqueInput | DailyWorkoutWhereUniqueInput[]
    delete?: DailyWorkoutWhereUniqueInput | DailyWorkoutWhereUniqueInput[]
    connect?: DailyWorkoutWhereUniqueInput | DailyWorkoutWhereUniqueInput[]
    update?: DailyWorkoutUpdateWithWhereUniqueWithoutUserInput | DailyWorkoutUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DailyWorkoutUpdateManyWithWhereWithoutUserInput | DailyWorkoutUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DailyWorkoutScalarWhereInput | DailyWorkoutScalarWhereInput[]
  }

  export type DailyRoutineUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DailyRoutineCreateWithoutUserInput, DailyRoutineUncheckedCreateWithoutUserInput> | DailyRoutineCreateWithoutUserInput[] | DailyRoutineUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DailyRoutineCreateOrConnectWithoutUserInput | DailyRoutineCreateOrConnectWithoutUserInput[]
    upsert?: DailyRoutineUpsertWithWhereUniqueWithoutUserInput | DailyRoutineUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DailyRoutineCreateManyUserInputEnvelope
    set?: DailyRoutineWhereUniqueInput | DailyRoutineWhereUniqueInput[]
    disconnect?: DailyRoutineWhereUniqueInput | DailyRoutineWhereUniqueInput[]
    delete?: DailyRoutineWhereUniqueInput | DailyRoutineWhereUniqueInput[]
    connect?: DailyRoutineWhereUniqueInput | DailyRoutineWhereUniqueInput[]
    update?: DailyRoutineUpdateWithWhereUniqueWithoutUserInput | DailyRoutineUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DailyRoutineUpdateManyWithWhereWithoutUserInput | DailyRoutineUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DailyRoutineScalarWhereInput | DailyRoutineScalarWhereInput[]
  }

  export type DailyReflectionsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DailyReflectionsCreateWithoutUserInput, DailyReflectionsUncheckedCreateWithoutUserInput> | DailyReflectionsCreateWithoutUserInput[] | DailyReflectionsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DailyReflectionsCreateOrConnectWithoutUserInput | DailyReflectionsCreateOrConnectWithoutUserInput[]
    upsert?: DailyReflectionsUpsertWithWhereUniqueWithoutUserInput | DailyReflectionsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DailyReflectionsCreateManyUserInputEnvelope
    set?: DailyReflectionsWhereUniqueInput | DailyReflectionsWhereUniqueInput[]
    disconnect?: DailyReflectionsWhereUniqueInput | DailyReflectionsWhereUniqueInput[]
    delete?: DailyReflectionsWhereUniqueInput | DailyReflectionsWhereUniqueInput[]
    connect?: DailyReflectionsWhereUniqueInput | DailyReflectionsWhereUniqueInput[]
    update?: DailyReflectionsUpdateWithWhereUniqueWithoutUserInput | DailyReflectionsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DailyReflectionsUpdateManyWithWhereWithoutUserInput | DailyReflectionsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DailyReflectionsScalarWhereInput | DailyReflectionsScalarWhereInput[]
  }

  export type TimeBlockUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TimeBlockCreateWithoutUserInput, TimeBlockUncheckedCreateWithoutUserInput> | TimeBlockCreateWithoutUserInput[] | TimeBlockUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TimeBlockCreateOrConnectWithoutUserInput | TimeBlockCreateOrConnectWithoutUserInput[]
    upsert?: TimeBlockUpsertWithWhereUniqueWithoutUserInput | TimeBlockUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TimeBlockCreateManyUserInputEnvelope
    set?: TimeBlockWhereUniqueInput | TimeBlockWhereUniqueInput[]
    disconnect?: TimeBlockWhereUniqueInput | TimeBlockWhereUniqueInput[]
    delete?: TimeBlockWhereUniqueInput | TimeBlockWhereUniqueInput[]
    connect?: TimeBlockWhereUniqueInput | TimeBlockWhereUniqueInput[]
    update?: TimeBlockUpdateWithWhereUniqueWithoutUserInput | TimeBlockUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TimeBlockUpdateManyWithWhereWithoutUserInput | TimeBlockUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TimeBlockScalarWhereInput | TimeBlockScalarWhereInput[]
  }

  export type UserProgressUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserProgressCreateWithoutUserInput, UserProgressUncheckedCreateWithoutUserInput> | UserProgressCreateWithoutUserInput[] | UserProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserProgressCreateOrConnectWithoutUserInput | UserProgressCreateOrConnectWithoutUserInput[]
    upsert?: UserProgressUpsertWithWhereUniqueWithoutUserInput | UserProgressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserProgressCreateManyUserInputEnvelope
    set?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    disconnect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    delete?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    connect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    update?: UserProgressUpdateWithWhereUniqueWithoutUserInput | UserProgressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserProgressUpdateManyWithWhereWithoutUserInput | UserProgressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserProgressScalarWhereInput | UserProgressScalarWhereInput[]
  }

  export type XPBalanceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<XPBalanceCreateWithoutUserInput, XPBalanceUncheckedCreateWithoutUserInput> | XPBalanceCreateWithoutUserInput[] | XPBalanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: XPBalanceCreateOrConnectWithoutUserInput | XPBalanceCreateOrConnectWithoutUserInput[]
    upsert?: XPBalanceUpsertWithWhereUniqueWithoutUserInput | XPBalanceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: XPBalanceCreateManyUserInputEnvelope
    set?: XPBalanceWhereUniqueInput | XPBalanceWhereUniqueInput[]
    disconnect?: XPBalanceWhereUniqueInput | XPBalanceWhereUniqueInput[]
    delete?: XPBalanceWhereUniqueInput | XPBalanceWhereUniqueInput[]
    connect?: XPBalanceWhereUniqueInput | XPBalanceWhereUniqueInput[]
    update?: XPBalanceUpdateWithWhereUniqueWithoutUserInput | XPBalanceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: XPBalanceUpdateManyWithWhereWithoutUserInput | XPBalanceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: XPBalanceScalarWhereInput | XPBalanceScalarWhereInput[]
  }

  export type XPPurchaseUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<XPPurchaseCreateWithoutUserInput, XPPurchaseUncheckedCreateWithoutUserInput> | XPPurchaseCreateWithoutUserInput[] | XPPurchaseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: XPPurchaseCreateOrConnectWithoutUserInput | XPPurchaseCreateOrConnectWithoutUserInput[]
    upsert?: XPPurchaseUpsertWithWhereUniqueWithoutUserInput | XPPurchaseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: XPPurchaseCreateManyUserInputEnvelope
    set?: XPPurchaseWhereUniqueInput | XPPurchaseWhereUniqueInput[]
    disconnect?: XPPurchaseWhereUniqueInput | XPPurchaseWhereUniqueInput[]
    delete?: XPPurchaseWhereUniqueInput | XPPurchaseWhereUniqueInput[]
    connect?: XPPurchaseWhereUniqueInput | XPPurchaseWhereUniqueInput[]
    update?: XPPurchaseUpdateWithWhereUniqueWithoutUserInput | XPPurchaseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: XPPurchaseUpdateManyWithWhereWithoutUserInput | XPPurchaseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: XPPurchaseScalarWhereInput | XPPurchaseScalarWhereInput[]
  }

  export type XPEarningLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<XPEarningLogCreateWithoutUserInput, XPEarningLogUncheckedCreateWithoutUserInput> | XPEarningLogCreateWithoutUserInput[] | XPEarningLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: XPEarningLogCreateOrConnectWithoutUserInput | XPEarningLogCreateOrConnectWithoutUserInput[]
    upsert?: XPEarningLogUpsertWithWhereUniqueWithoutUserInput | XPEarningLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: XPEarningLogCreateManyUserInputEnvelope
    set?: XPEarningLogWhereUniqueInput | XPEarningLogWhereUniqueInput[]
    disconnect?: XPEarningLogWhereUniqueInput | XPEarningLogWhereUniqueInput[]
    delete?: XPEarningLogWhereUniqueInput | XPEarningLogWhereUniqueInput[]
    connect?: XPEarningLogWhereUniqueInput | XPEarningLogWhereUniqueInput[]
    update?: XPEarningLogUpdateWithWhereUniqueWithoutUserInput | XPEarningLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: XPEarningLogUpdateManyWithWhereWithoutUserInput | XPEarningLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: XPEarningLogScalarWhereInput | XPEarningLogScalarWhereInput[]
  }

  export type LightWorkTaskCreatetagsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutLightWorkTasksInput = {
    create?: XOR<UserCreateWithoutLightWorkTasksInput, UserUncheckedCreateWithoutLightWorkTasksInput>
    connectOrCreate?: UserCreateOrConnectWithoutLightWorkTasksInput
    connect?: UserWhereUniqueInput
  }

  export type LightWorkSubtaskCreateNestedManyWithoutTaskInput = {
    create?: XOR<LightWorkSubtaskCreateWithoutTaskInput, LightWorkSubtaskUncheckedCreateWithoutTaskInput> | LightWorkSubtaskCreateWithoutTaskInput[] | LightWorkSubtaskUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: LightWorkSubtaskCreateOrConnectWithoutTaskInput | LightWorkSubtaskCreateOrConnectWithoutTaskInput[]
    createMany?: LightWorkSubtaskCreateManyTaskInputEnvelope
    connect?: LightWorkSubtaskWhereUniqueInput | LightWorkSubtaskWhereUniqueInput[]
  }

  export type LightWorkSubtaskUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<LightWorkSubtaskCreateWithoutTaskInput, LightWorkSubtaskUncheckedCreateWithoutTaskInput> | LightWorkSubtaskCreateWithoutTaskInput[] | LightWorkSubtaskUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: LightWorkSubtaskCreateOrConnectWithoutTaskInput | LightWorkSubtaskCreateOrConnectWithoutTaskInput[]
    createMany?: LightWorkSubtaskCreateManyTaskInputEnvelope
    connect?: LightWorkSubtaskWhereUniqueInput | LightWorkSubtaskWhereUniqueInput[]
  }

  export type EnumPriorityFieldUpdateOperationsInput = {
    set?: $Enums.Priority
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type LightWorkTaskUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutLightWorkTasksNestedInput = {
    create?: XOR<UserCreateWithoutLightWorkTasksInput, UserUncheckedCreateWithoutLightWorkTasksInput>
    connectOrCreate?: UserCreateOrConnectWithoutLightWorkTasksInput
    upsert?: UserUpsertWithoutLightWorkTasksInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLightWorkTasksInput, UserUpdateWithoutLightWorkTasksInput>, UserUncheckedUpdateWithoutLightWorkTasksInput>
  }

  export type LightWorkSubtaskUpdateManyWithoutTaskNestedInput = {
    create?: XOR<LightWorkSubtaskCreateWithoutTaskInput, LightWorkSubtaskUncheckedCreateWithoutTaskInput> | LightWorkSubtaskCreateWithoutTaskInput[] | LightWorkSubtaskUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: LightWorkSubtaskCreateOrConnectWithoutTaskInput | LightWorkSubtaskCreateOrConnectWithoutTaskInput[]
    upsert?: LightWorkSubtaskUpsertWithWhereUniqueWithoutTaskInput | LightWorkSubtaskUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: LightWorkSubtaskCreateManyTaskInputEnvelope
    set?: LightWorkSubtaskWhereUniqueInput | LightWorkSubtaskWhereUniqueInput[]
    disconnect?: LightWorkSubtaskWhereUniqueInput | LightWorkSubtaskWhereUniqueInput[]
    delete?: LightWorkSubtaskWhereUniqueInput | LightWorkSubtaskWhereUniqueInput[]
    connect?: LightWorkSubtaskWhereUniqueInput | LightWorkSubtaskWhereUniqueInput[]
    update?: LightWorkSubtaskUpdateWithWhereUniqueWithoutTaskInput | LightWorkSubtaskUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: LightWorkSubtaskUpdateManyWithWhereWithoutTaskInput | LightWorkSubtaskUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: LightWorkSubtaskScalarWhereInput | LightWorkSubtaskScalarWhereInput[]
  }

  export type LightWorkSubtaskUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<LightWorkSubtaskCreateWithoutTaskInput, LightWorkSubtaskUncheckedCreateWithoutTaskInput> | LightWorkSubtaskCreateWithoutTaskInput[] | LightWorkSubtaskUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: LightWorkSubtaskCreateOrConnectWithoutTaskInput | LightWorkSubtaskCreateOrConnectWithoutTaskInput[]
    upsert?: LightWorkSubtaskUpsertWithWhereUniqueWithoutTaskInput | LightWorkSubtaskUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: LightWorkSubtaskCreateManyTaskInputEnvelope
    set?: LightWorkSubtaskWhereUniqueInput | LightWorkSubtaskWhereUniqueInput[]
    disconnect?: LightWorkSubtaskWhereUniqueInput | LightWorkSubtaskWhereUniqueInput[]
    delete?: LightWorkSubtaskWhereUniqueInput | LightWorkSubtaskWhereUniqueInput[]
    connect?: LightWorkSubtaskWhereUniqueInput | LightWorkSubtaskWhereUniqueInput[]
    update?: LightWorkSubtaskUpdateWithWhereUniqueWithoutTaskInput | LightWorkSubtaskUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: LightWorkSubtaskUpdateManyWithWhereWithoutTaskInput | LightWorkSubtaskUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: LightWorkSubtaskScalarWhereInput | LightWorkSubtaskScalarWhereInput[]
  }

  export type LightWorkTaskCreateNestedOneWithoutSubtasksInput = {
    create?: XOR<LightWorkTaskCreateWithoutSubtasksInput, LightWorkTaskUncheckedCreateWithoutSubtasksInput>
    connectOrCreate?: LightWorkTaskCreateOrConnectWithoutSubtasksInput
    connect?: LightWorkTaskWhereUniqueInput
  }

  export type LightWorkTaskUpdateOneRequiredWithoutSubtasksNestedInput = {
    create?: XOR<LightWorkTaskCreateWithoutSubtasksInput, LightWorkTaskUncheckedCreateWithoutSubtasksInput>
    connectOrCreate?: LightWorkTaskCreateOrConnectWithoutSubtasksInput
    upsert?: LightWorkTaskUpsertWithoutSubtasksInput
    connect?: LightWorkTaskWhereUniqueInput
    update?: XOR<XOR<LightWorkTaskUpdateToOneWithWhereWithoutSubtasksInput, LightWorkTaskUpdateWithoutSubtasksInput>, LightWorkTaskUncheckedUpdateWithoutSubtasksInput>
  }

  export type DeepWorkTaskCreatetagsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutDeepWorkTasksInput = {
    create?: XOR<UserCreateWithoutDeepWorkTasksInput, UserUncheckedCreateWithoutDeepWorkTasksInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeepWorkTasksInput
    connect?: UserWhereUniqueInput
  }

  export type DeepWorkSubtaskCreateNestedManyWithoutTaskInput = {
    create?: XOR<DeepWorkSubtaskCreateWithoutTaskInput, DeepWorkSubtaskUncheckedCreateWithoutTaskInput> | DeepWorkSubtaskCreateWithoutTaskInput[] | DeepWorkSubtaskUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: DeepWorkSubtaskCreateOrConnectWithoutTaskInput | DeepWorkSubtaskCreateOrConnectWithoutTaskInput[]
    createMany?: DeepWorkSubtaskCreateManyTaskInputEnvelope
    connect?: DeepWorkSubtaskWhereUniqueInput | DeepWorkSubtaskWhereUniqueInput[]
  }

  export type DeepWorkSubtaskUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<DeepWorkSubtaskCreateWithoutTaskInput, DeepWorkSubtaskUncheckedCreateWithoutTaskInput> | DeepWorkSubtaskCreateWithoutTaskInput[] | DeepWorkSubtaskUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: DeepWorkSubtaskCreateOrConnectWithoutTaskInput | DeepWorkSubtaskCreateOrConnectWithoutTaskInput[]
    createMany?: DeepWorkSubtaskCreateManyTaskInputEnvelope
    connect?: DeepWorkSubtaskWhereUniqueInput | DeepWorkSubtaskWhereUniqueInput[]
  }

  export type DeepWorkTaskUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutDeepWorkTasksNestedInput = {
    create?: XOR<UserCreateWithoutDeepWorkTasksInput, UserUncheckedCreateWithoutDeepWorkTasksInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeepWorkTasksInput
    upsert?: UserUpsertWithoutDeepWorkTasksInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDeepWorkTasksInput, UserUpdateWithoutDeepWorkTasksInput>, UserUncheckedUpdateWithoutDeepWorkTasksInput>
  }

  export type DeepWorkSubtaskUpdateManyWithoutTaskNestedInput = {
    create?: XOR<DeepWorkSubtaskCreateWithoutTaskInput, DeepWorkSubtaskUncheckedCreateWithoutTaskInput> | DeepWorkSubtaskCreateWithoutTaskInput[] | DeepWorkSubtaskUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: DeepWorkSubtaskCreateOrConnectWithoutTaskInput | DeepWorkSubtaskCreateOrConnectWithoutTaskInput[]
    upsert?: DeepWorkSubtaskUpsertWithWhereUniqueWithoutTaskInput | DeepWorkSubtaskUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: DeepWorkSubtaskCreateManyTaskInputEnvelope
    set?: DeepWorkSubtaskWhereUniqueInput | DeepWorkSubtaskWhereUniqueInput[]
    disconnect?: DeepWorkSubtaskWhereUniqueInput | DeepWorkSubtaskWhereUniqueInput[]
    delete?: DeepWorkSubtaskWhereUniqueInput | DeepWorkSubtaskWhereUniqueInput[]
    connect?: DeepWorkSubtaskWhereUniqueInput | DeepWorkSubtaskWhereUniqueInput[]
    update?: DeepWorkSubtaskUpdateWithWhereUniqueWithoutTaskInput | DeepWorkSubtaskUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: DeepWorkSubtaskUpdateManyWithWhereWithoutTaskInput | DeepWorkSubtaskUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: DeepWorkSubtaskScalarWhereInput | DeepWorkSubtaskScalarWhereInput[]
  }

  export type DeepWorkSubtaskUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<DeepWorkSubtaskCreateWithoutTaskInput, DeepWorkSubtaskUncheckedCreateWithoutTaskInput> | DeepWorkSubtaskCreateWithoutTaskInput[] | DeepWorkSubtaskUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: DeepWorkSubtaskCreateOrConnectWithoutTaskInput | DeepWorkSubtaskCreateOrConnectWithoutTaskInput[]
    upsert?: DeepWorkSubtaskUpsertWithWhereUniqueWithoutTaskInput | DeepWorkSubtaskUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: DeepWorkSubtaskCreateManyTaskInputEnvelope
    set?: DeepWorkSubtaskWhereUniqueInput | DeepWorkSubtaskWhereUniqueInput[]
    disconnect?: DeepWorkSubtaskWhereUniqueInput | DeepWorkSubtaskWhereUniqueInput[]
    delete?: DeepWorkSubtaskWhereUniqueInput | DeepWorkSubtaskWhereUniqueInput[]
    connect?: DeepWorkSubtaskWhereUniqueInput | DeepWorkSubtaskWhereUniqueInput[]
    update?: DeepWorkSubtaskUpdateWithWhereUniqueWithoutTaskInput | DeepWorkSubtaskUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: DeepWorkSubtaskUpdateManyWithWhereWithoutTaskInput | DeepWorkSubtaskUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: DeepWorkSubtaskScalarWhereInput | DeepWorkSubtaskScalarWhereInput[]
  }

  export type DeepWorkTaskCreateNestedOneWithoutSubtasksInput = {
    create?: XOR<DeepWorkTaskCreateWithoutSubtasksInput, DeepWorkTaskUncheckedCreateWithoutSubtasksInput>
    connectOrCreate?: DeepWorkTaskCreateOrConnectWithoutSubtasksInput
    connect?: DeepWorkTaskWhereUniqueInput
  }

  export type DeepWorkTaskUpdateOneRequiredWithoutSubtasksNestedInput = {
    create?: XOR<DeepWorkTaskCreateWithoutSubtasksInput, DeepWorkTaskUncheckedCreateWithoutSubtasksInput>
    connectOrCreate?: DeepWorkTaskCreateOrConnectWithoutSubtasksInput
    upsert?: DeepWorkTaskUpsertWithoutSubtasksInput
    connect?: DeepWorkTaskWhereUniqueInput
    update?: XOR<XOR<DeepWorkTaskUpdateToOneWithWhereWithoutSubtasksInput, DeepWorkTaskUpdateWithoutSubtasksInput>, DeepWorkTaskUncheckedUpdateWithoutSubtasksInput>
  }

  export type UserCreateNestedOneWithoutAutomationTasksInput = {
    create?: XOR<UserCreateWithoutAutomationTasksInput, UserUncheckedCreateWithoutAutomationTasksInput>
    connectOrCreate?: UserCreateOrConnectWithoutAutomationTasksInput
    connect?: UserWhereUniqueInput
  }

  export type EnumAutomationCategoryFieldUpdateOperationsInput = {
    set?: $Enums.AutomationCategory
  }

  export type EnumAutomationStatusFieldUpdateOperationsInput = {
    set?: $Enums.AutomationStatus
  }

  export type UserUpdateOneRequiredWithoutAutomationTasksNestedInput = {
    create?: XOR<UserCreateWithoutAutomationTasksInput, UserUncheckedCreateWithoutAutomationTasksInput>
    connectOrCreate?: UserCreateOrConnectWithoutAutomationTasksInput
    upsert?: UserUpsertWithoutAutomationTasksInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAutomationTasksInput, UserUpdateWithoutAutomationTasksInput>, UserUncheckedUpdateWithoutAutomationTasksInput>
  }

  export type UserCreateNestedOneWithoutDailyHabitsInput = {
    create?: XOR<UserCreateWithoutDailyHabitsInput, UserUncheckedCreateWithoutDailyHabitsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDailyHabitsInput
    connect?: UserWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutDailyHabitsNestedInput = {
    create?: XOR<UserCreateWithoutDailyHabitsInput, UserUncheckedCreateWithoutDailyHabitsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDailyHabitsInput
    upsert?: UserUpsertWithoutDailyHabitsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDailyHabitsInput, UserUpdateWithoutDailyHabitsInput>, UserUncheckedUpdateWithoutDailyHabitsInput>
  }

  export type UserCreateNestedOneWithoutDailyHealthInput = {
    create?: XOR<UserCreateWithoutDailyHealthInput, UserUncheckedCreateWithoutDailyHealthInput>
    connectOrCreate?: UserCreateOrConnectWithoutDailyHealthInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutDailyHealthNestedInput = {
    create?: XOR<UserCreateWithoutDailyHealthInput, UserUncheckedCreateWithoutDailyHealthInput>
    connectOrCreate?: UserCreateOrConnectWithoutDailyHealthInput
    upsert?: UserUpsertWithoutDailyHealthInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDailyHealthInput, UserUpdateWithoutDailyHealthInput>, UserUncheckedUpdateWithoutDailyHealthInput>
  }

  export type UserCreateNestedOneWithoutDailyWorkoutInput = {
    create?: XOR<UserCreateWithoutDailyWorkoutInput, UserUncheckedCreateWithoutDailyWorkoutInput>
    connectOrCreate?: UserCreateOrConnectWithoutDailyWorkoutInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutDailyWorkoutNestedInput = {
    create?: XOR<UserCreateWithoutDailyWorkoutInput, UserUncheckedCreateWithoutDailyWorkoutInput>
    connectOrCreate?: UserCreateOrConnectWithoutDailyWorkoutInput
    upsert?: UserUpsertWithoutDailyWorkoutInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDailyWorkoutInput, UserUpdateWithoutDailyWorkoutInput>, UserUncheckedUpdateWithoutDailyWorkoutInput>
  }

  export type UserCreateNestedOneWithoutDailyRoutineInput = {
    create?: XOR<UserCreateWithoutDailyRoutineInput, UserUncheckedCreateWithoutDailyRoutineInput>
    connectOrCreate?: UserCreateOrConnectWithoutDailyRoutineInput
    connect?: UserWhereUniqueInput
  }

  export type EnumRoutineTypeFieldUpdateOperationsInput = {
    set?: $Enums.RoutineType
  }

  export type UserUpdateOneRequiredWithoutDailyRoutineNestedInput = {
    create?: XOR<UserCreateWithoutDailyRoutineInput, UserUncheckedCreateWithoutDailyRoutineInput>
    connectOrCreate?: UserCreateOrConnectWithoutDailyRoutineInput
    upsert?: UserUpsertWithoutDailyRoutineInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDailyRoutineInput, UserUpdateWithoutDailyRoutineInput>, UserUncheckedUpdateWithoutDailyRoutineInput>
  }

  export type DailyReflectionsCreatewentWellInput = {
    set: string[]
  }

  export type DailyReflectionsCreateevenBetterIfInput = {
    set: string[]
  }

  export type DailyReflectionsCreateanalysisInput = {
    set: string[]
  }

  export type DailyReflectionsCreatepatternsInput = {
    set: string[]
  }

  export type DailyReflectionsCreatechangesInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutDailyReflectionsInput = {
    create?: XOR<UserCreateWithoutDailyReflectionsInput, UserUncheckedCreateWithoutDailyReflectionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDailyReflectionsInput
    connect?: UserWhereUniqueInput
  }

  export type DailyReflectionsUpdatewentWellInput = {
    set?: string[]
    push?: string | string[]
  }

  export type DailyReflectionsUpdateevenBetterIfInput = {
    set?: string[]
    push?: string | string[]
  }

  export type DailyReflectionsUpdateanalysisInput = {
    set?: string[]
    push?: string | string[]
  }

  export type DailyReflectionsUpdatepatternsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type DailyReflectionsUpdatechangesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutDailyReflectionsNestedInput = {
    create?: XOR<UserCreateWithoutDailyReflectionsInput, UserUncheckedCreateWithoutDailyReflectionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDailyReflectionsInput
    upsert?: UserUpsertWithoutDailyReflectionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDailyReflectionsInput, UserUpdateWithoutDailyReflectionsInput>, UserUncheckedUpdateWithoutDailyReflectionsInput>
  }

  export type UserCreateNestedOneWithoutTimeBlocksInput = {
    create?: XOR<UserCreateWithoutTimeBlocksInput, UserUncheckedCreateWithoutTimeBlocksInput>
    connectOrCreate?: UserCreateOrConnectWithoutTimeBlocksInput
    connect?: UserWhereUniqueInput
  }

  export type EnumTimeBlockCategoryFieldUpdateOperationsInput = {
    set?: $Enums.TimeBlockCategory
  }

  export type UserUpdateOneRequiredWithoutTimeBlocksNestedInput = {
    create?: XOR<UserCreateWithoutTimeBlocksInput, UserUncheckedCreateWithoutTimeBlocksInput>
    connectOrCreate?: UserCreateOrConnectWithoutTimeBlocksInput
    upsert?: UserUpsertWithoutTimeBlocksInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTimeBlocksInput, UserUpdateWithoutTimeBlocksInput>, UserUncheckedUpdateWithoutTimeBlocksInput>
  }

  export type UserCreateNestedOneWithoutPersonalContextInput = {
    create?: XOR<UserCreateWithoutPersonalContextInput, UserUncheckedCreateWithoutPersonalContextInput>
    connectOrCreate?: UserCreateOrConnectWithoutPersonalContextInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPersonalContextNestedInput = {
    create?: XOR<UserCreateWithoutPersonalContextInput, UserUncheckedCreateWithoutPersonalContextInput>
    connectOrCreate?: UserCreateOrConnectWithoutPersonalContextInput
    upsert?: UserUpsertWithoutPersonalContextInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPersonalContextInput, UserUpdateWithoutPersonalContextInput>, UserUncheckedUpdateWithoutPersonalContextInput>
  }

  export type AchievementCreateNestedManyWithoutUserProgressInput = {
    create?: XOR<AchievementCreateWithoutUserProgressInput, AchievementUncheckedCreateWithoutUserProgressInput> | AchievementCreateWithoutUserProgressInput[] | AchievementUncheckedCreateWithoutUserProgressInput[]
    connectOrCreate?: AchievementCreateOrConnectWithoutUserProgressInput | AchievementCreateOrConnectWithoutUserProgressInput[]
    createMany?: AchievementCreateManyUserProgressInputEnvelope
    connect?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
  }

  export type DailyStatsCreateNestedManyWithoutUserProgressInput = {
    create?: XOR<DailyStatsCreateWithoutUserProgressInput, DailyStatsUncheckedCreateWithoutUserProgressInput> | DailyStatsCreateWithoutUserProgressInput[] | DailyStatsUncheckedCreateWithoutUserProgressInput[]
    connectOrCreate?: DailyStatsCreateOrConnectWithoutUserProgressInput | DailyStatsCreateOrConnectWithoutUserProgressInput[]
    createMany?: DailyStatsCreateManyUserProgressInputEnvelope
    connect?: DailyStatsWhereUniqueInput | DailyStatsWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutUserProgressInput = {
    create?: XOR<UserCreateWithoutUserProgressInput, UserUncheckedCreateWithoutUserProgressInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserProgressInput
    connect?: UserWhereUniqueInput
  }

  export type AchievementUncheckedCreateNestedManyWithoutUserProgressInput = {
    create?: XOR<AchievementCreateWithoutUserProgressInput, AchievementUncheckedCreateWithoutUserProgressInput> | AchievementCreateWithoutUserProgressInput[] | AchievementUncheckedCreateWithoutUserProgressInput[]
    connectOrCreate?: AchievementCreateOrConnectWithoutUserProgressInput | AchievementCreateOrConnectWithoutUserProgressInput[]
    createMany?: AchievementCreateManyUserProgressInputEnvelope
    connect?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
  }

  export type DailyStatsUncheckedCreateNestedManyWithoutUserProgressInput = {
    create?: XOR<DailyStatsCreateWithoutUserProgressInput, DailyStatsUncheckedCreateWithoutUserProgressInput> | DailyStatsCreateWithoutUserProgressInput[] | DailyStatsUncheckedCreateWithoutUserProgressInput[]
    connectOrCreate?: DailyStatsCreateOrConnectWithoutUserProgressInput | DailyStatsCreateOrConnectWithoutUserProgressInput[]
    createMany?: DailyStatsCreateManyUserProgressInputEnvelope
    connect?: DailyStatsWhereUniqueInput | DailyStatsWhereUniqueInput[]
  }

  export type AchievementUpdateManyWithoutUserProgressNestedInput = {
    create?: XOR<AchievementCreateWithoutUserProgressInput, AchievementUncheckedCreateWithoutUserProgressInput> | AchievementCreateWithoutUserProgressInput[] | AchievementUncheckedCreateWithoutUserProgressInput[]
    connectOrCreate?: AchievementCreateOrConnectWithoutUserProgressInput | AchievementCreateOrConnectWithoutUserProgressInput[]
    upsert?: AchievementUpsertWithWhereUniqueWithoutUserProgressInput | AchievementUpsertWithWhereUniqueWithoutUserProgressInput[]
    createMany?: AchievementCreateManyUserProgressInputEnvelope
    set?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    disconnect?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    delete?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    connect?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    update?: AchievementUpdateWithWhereUniqueWithoutUserProgressInput | AchievementUpdateWithWhereUniqueWithoutUserProgressInput[]
    updateMany?: AchievementUpdateManyWithWhereWithoutUserProgressInput | AchievementUpdateManyWithWhereWithoutUserProgressInput[]
    deleteMany?: AchievementScalarWhereInput | AchievementScalarWhereInput[]
  }

  export type DailyStatsUpdateManyWithoutUserProgressNestedInput = {
    create?: XOR<DailyStatsCreateWithoutUserProgressInput, DailyStatsUncheckedCreateWithoutUserProgressInput> | DailyStatsCreateWithoutUserProgressInput[] | DailyStatsUncheckedCreateWithoutUserProgressInput[]
    connectOrCreate?: DailyStatsCreateOrConnectWithoutUserProgressInput | DailyStatsCreateOrConnectWithoutUserProgressInput[]
    upsert?: DailyStatsUpsertWithWhereUniqueWithoutUserProgressInput | DailyStatsUpsertWithWhereUniqueWithoutUserProgressInput[]
    createMany?: DailyStatsCreateManyUserProgressInputEnvelope
    set?: DailyStatsWhereUniqueInput | DailyStatsWhereUniqueInput[]
    disconnect?: DailyStatsWhereUniqueInput | DailyStatsWhereUniqueInput[]
    delete?: DailyStatsWhereUniqueInput | DailyStatsWhereUniqueInput[]
    connect?: DailyStatsWhereUniqueInput | DailyStatsWhereUniqueInput[]
    update?: DailyStatsUpdateWithWhereUniqueWithoutUserProgressInput | DailyStatsUpdateWithWhereUniqueWithoutUserProgressInput[]
    updateMany?: DailyStatsUpdateManyWithWhereWithoutUserProgressInput | DailyStatsUpdateManyWithWhereWithoutUserProgressInput[]
    deleteMany?: DailyStatsScalarWhereInput | DailyStatsScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutUserProgressNestedInput = {
    create?: XOR<UserCreateWithoutUserProgressInput, UserUncheckedCreateWithoutUserProgressInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserProgressInput
    upsert?: UserUpsertWithoutUserProgressInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserProgressInput, UserUpdateWithoutUserProgressInput>, UserUncheckedUpdateWithoutUserProgressInput>
  }

  export type AchievementUncheckedUpdateManyWithoutUserProgressNestedInput = {
    create?: XOR<AchievementCreateWithoutUserProgressInput, AchievementUncheckedCreateWithoutUserProgressInput> | AchievementCreateWithoutUserProgressInput[] | AchievementUncheckedCreateWithoutUserProgressInput[]
    connectOrCreate?: AchievementCreateOrConnectWithoutUserProgressInput | AchievementCreateOrConnectWithoutUserProgressInput[]
    upsert?: AchievementUpsertWithWhereUniqueWithoutUserProgressInput | AchievementUpsertWithWhereUniqueWithoutUserProgressInput[]
    createMany?: AchievementCreateManyUserProgressInputEnvelope
    set?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    disconnect?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    delete?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    connect?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    update?: AchievementUpdateWithWhereUniqueWithoutUserProgressInput | AchievementUpdateWithWhereUniqueWithoutUserProgressInput[]
    updateMany?: AchievementUpdateManyWithWhereWithoutUserProgressInput | AchievementUpdateManyWithWhereWithoutUserProgressInput[]
    deleteMany?: AchievementScalarWhereInput | AchievementScalarWhereInput[]
  }

  export type DailyStatsUncheckedUpdateManyWithoutUserProgressNestedInput = {
    create?: XOR<DailyStatsCreateWithoutUserProgressInput, DailyStatsUncheckedCreateWithoutUserProgressInput> | DailyStatsCreateWithoutUserProgressInput[] | DailyStatsUncheckedCreateWithoutUserProgressInput[]
    connectOrCreate?: DailyStatsCreateOrConnectWithoutUserProgressInput | DailyStatsCreateOrConnectWithoutUserProgressInput[]
    upsert?: DailyStatsUpsertWithWhereUniqueWithoutUserProgressInput | DailyStatsUpsertWithWhereUniqueWithoutUserProgressInput[]
    createMany?: DailyStatsCreateManyUserProgressInputEnvelope
    set?: DailyStatsWhereUniqueInput | DailyStatsWhereUniqueInput[]
    disconnect?: DailyStatsWhereUniqueInput | DailyStatsWhereUniqueInput[]
    delete?: DailyStatsWhereUniqueInput | DailyStatsWhereUniqueInput[]
    connect?: DailyStatsWhereUniqueInput | DailyStatsWhereUniqueInput[]
    update?: DailyStatsUpdateWithWhereUniqueWithoutUserProgressInput | DailyStatsUpdateWithWhereUniqueWithoutUserProgressInput[]
    updateMany?: DailyStatsUpdateManyWithWhereWithoutUserProgressInput | DailyStatsUpdateManyWithWhereWithoutUserProgressInput[]
    deleteMany?: DailyStatsScalarWhereInput | DailyStatsScalarWhereInput[]
  }

  export type UserProgressCreateNestedOneWithoutAchievementsInput = {
    create?: XOR<UserProgressCreateWithoutAchievementsInput, UserProgressUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: UserProgressCreateOrConnectWithoutAchievementsInput
    connect?: UserProgressWhereUniqueInput
  }

  export type EnumAchievementCategoryFieldUpdateOperationsInput = {
    set?: $Enums.AchievementCategory
  }

  export type UserProgressUpdateOneRequiredWithoutAchievementsNestedInput = {
    create?: XOR<UserProgressCreateWithoutAchievementsInput, UserProgressUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: UserProgressCreateOrConnectWithoutAchievementsInput
    upsert?: UserProgressUpsertWithoutAchievementsInput
    connect?: UserProgressWhereUniqueInput
    update?: XOR<XOR<UserProgressUpdateToOneWithWhereWithoutAchievementsInput, UserProgressUpdateWithoutAchievementsInput>, UserProgressUncheckedUpdateWithoutAchievementsInput>
  }

  export type UserProgressCreateNestedOneWithoutDailyStatsInput = {
    create?: XOR<UserProgressCreateWithoutDailyStatsInput, UserProgressUncheckedCreateWithoutDailyStatsInput>
    connectOrCreate?: UserProgressCreateOrConnectWithoutDailyStatsInput
    connect?: UserProgressWhereUniqueInput
  }

  export type UserProgressUpdateOneRequiredWithoutDailyStatsNestedInput = {
    create?: XOR<UserProgressCreateWithoutDailyStatsInput, UserProgressUncheckedCreateWithoutDailyStatsInput>
    connectOrCreate?: UserProgressCreateOrConnectWithoutDailyStatsInput
    upsert?: UserProgressUpsertWithoutDailyStatsInput
    connect?: UserProgressWhereUniqueInput
    update?: XOR<XOR<UserProgressUpdateToOneWithWhereWithoutDailyStatsInput, UserProgressUpdateWithoutDailyStatsInput>, UserProgressUncheckedUpdateWithoutDailyStatsInput>
  }

  export type UserCreateNestedOneWithoutXpBalanceInput = {
    create?: XOR<UserCreateWithoutXpBalanceInput, UserUncheckedCreateWithoutXpBalanceInput>
    connectOrCreate?: UserCreateOrConnectWithoutXpBalanceInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutXpBalanceNestedInput = {
    create?: XOR<UserCreateWithoutXpBalanceInput, UserUncheckedCreateWithoutXpBalanceInput>
    connectOrCreate?: UserCreateOrConnectWithoutXpBalanceInput
    upsert?: UserUpsertWithoutXpBalanceInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutXpBalanceInput, UserUpdateWithoutXpBalanceInput>, UserUncheckedUpdateWithoutXpBalanceInput>
  }

  export type UserCreateNestedOneWithoutXpPurchasesInput = {
    create?: XOR<UserCreateWithoutXpPurchasesInput, UserUncheckedCreateWithoutXpPurchasesInput>
    connectOrCreate?: UserCreateOrConnectWithoutXpPurchasesInput
    connect?: UserWhereUniqueInput
  }

  export type RewardDefinitionCreateNestedOneWithoutPurchasesInput = {
    create?: XOR<RewardDefinitionCreateWithoutPurchasesInput, RewardDefinitionUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: RewardDefinitionCreateOrConnectWithoutPurchasesInput
    connect?: RewardDefinitionWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutXpPurchasesNestedInput = {
    create?: XOR<UserCreateWithoutXpPurchasesInput, UserUncheckedCreateWithoutXpPurchasesInput>
    connectOrCreate?: UserCreateOrConnectWithoutXpPurchasesInput
    upsert?: UserUpsertWithoutXpPurchasesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutXpPurchasesInput, UserUpdateWithoutXpPurchasesInput>, UserUncheckedUpdateWithoutXpPurchasesInput>
  }

  export type RewardDefinitionUpdateOneRequiredWithoutPurchasesNestedInput = {
    create?: XOR<RewardDefinitionCreateWithoutPurchasesInput, RewardDefinitionUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: RewardDefinitionCreateOrConnectWithoutPurchasesInput
    upsert?: RewardDefinitionUpsertWithoutPurchasesInput
    connect?: RewardDefinitionWhereUniqueInput
    update?: XOR<XOR<RewardDefinitionUpdateToOneWithWhereWithoutPurchasesInput, RewardDefinitionUpdateWithoutPurchasesInput>, RewardDefinitionUncheckedUpdateWithoutPurchasesInput>
  }

  export type UserCreateNestedOneWithoutXpEarningLogInput = {
    create?: XOR<UserCreateWithoutXpEarningLogInput, UserUncheckedCreateWithoutXpEarningLogInput>
    connectOrCreate?: UserCreateOrConnectWithoutXpEarningLogInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutXpEarningLogNestedInput = {
    create?: XOR<UserCreateWithoutXpEarningLogInput, UserUncheckedCreateWithoutXpEarningLogInput>
    connectOrCreate?: UserCreateOrConnectWithoutXpEarningLogInput
    upsert?: UserUpsertWithoutXpEarningLogInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutXpEarningLogInput, UserUpdateWithoutXpEarningLogInput>, UserUncheckedUpdateWithoutXpEarningLogInput>
  }

  export type XPPurchaseCreateNestedManyWithoutRewardInput = {
    create?: XOR<XPPurchaseCreateWithoutRewardInput, XPPurchaseUncheckedCreateWithoutRewardInput> | XPPurchaseCreateWithoutRewardInput[] | XPPurchaseUncheckedCreateWithoutRewardInput[]
    connectOrCreate?: XPPurchaseCreateOrConnectWithoutRewardInput | XPPurchaseCreateOrConnectWithoutRewardInput[]
    createMany?: XPPurchaseCreateManyRewardInputEnvelope
    connect?: XPPurchaseWhereUniqueInput | XPPurchaseWhereUniqueInput[]
  }

  export type XPPurchaseUncheckedCreateNestedManyWithoutRewardInput = {
    create?: XOR<XPPurchaseCreateWithoutRewardInput, XPPurchaseUncheckedCreateWithoutRewardInput> | XPPurchaseCreateWithoutRewardInput[] | XPPurchaseUncheckedCreateWithoutRewardInput[]
    connectOrCreate?: XPPurchaseCreateOrConnectWithoutRewardInput | XPPurchaseCreateOrConnectWithoutRewardInput[]
    createMany?: XPPurchaseCreateManyRewardInputEnvelope
    connect?: XPPurchaseWhereUniqueInput | XPPurchaseWhereUniqueInput[]
  }

  export type XPPurchaseUpdateManyWithoutRewardNestedInput = {
    create?: XOR<XPPurchaseCreateWithoutRewardInput, XPPurchaseUncheckedCreateWithoutRewardInput> | XPPurchaseCreateWithoutRewardInput[] | XPPurchaseUncheckedCreateWithoutRewardInput[]
    connectOrCreate?: XPPurchaseCreateOrConnectWithoutRewardInput | XPPurchaseCreateOrConnectWithoutRewardInput[]
    upsert?: XPPurchaseUpsertWithWhereUniqueWithoutRewardInput | XPPurchaseUpsertWithWhereUniqueWithoutRewardInput[]
    createMany?: XPPurchaseCreateManyRewardInputEnvelope
    set?: XPPurchaseWhereUniqueInput | XPPurchaseWhereUniqueInput[]
    disconnect?: XPPurchaseWhereUniqueInput | XPPurchaseWhereUniqueInput[]
    delete?: XPPurchaseWhereUniqueInput | XPPurchaseWhereUniqueInput[]
    connect?: XPPurchaseWhereUniqueInput | XPPurchaseWhereUniqueInput[]
    update?: XPPurchaseUpdateWithWhereUniqueWithoutRewardInput | XPPurchaseUpdateWithWhereUniqueWithoutRewardInput[]
    updateMany?: XPPurchaseUpdateManyWithWhereWithoutRewardInput | XPPurchaseUpdateManyWithWhereWithoutRewardInput[]
    deleteMany?: XPPurchaseScalarWhereInput | XPPurchaseScalarWhereInput[]
  }

  export type XPPurchaseUncheckedUpdateManyWithoutRewardNestedInput = {
    create?: XOR<XPPurchaseCreateWithoutRewardInput, XPPurchaseUncheckedCreateWithoutRewardInput> | XPPurchaseCreateWithoutRewardInput[] | XPPurchaseUncheckedCreateWithoutRewardInput[]
    connectOrCreate?: XPPurchaseCreateOrConnectWithoutRewardInput | XPPurchaseCreateOrConnectWithoutRewardInput[]
    upsert?: XPPurchaseUpsertWithWhereUniqueWithoutRewardInput | XPPurchaseUpsertWithWhereUniqueWithoutRewardInput[]
    createMany?: XPPurchaseCreateManyRewardInputEnvelope
    set?: XPPurchaseWhereUniqueInput | XPPurchaseWhereUniqueInput[]
    disconnect?: XPPurchaseWhereUniqueInput | XPPurchaseWhereUniqueInput[]
    delete?: XPPurchaseWhereUniqueInput | XPPurchaseWhereUniqueInput[]
    connect?: XPPurchaseWhereUniqueInput | XPPurchaseWhereUniqueInput[]
    update?: XPPurchaseUpdateWithWhereUniqueWithoutRewardInput | XPPurchaseUpdateWithWhereUniqueWithoutRewardInput[]
    updateMany?: XPPurchaseUpdateManyWithWhereWithoutRewardInput | XPPurchaseUpdateManyWithWhereWithoutRewardInput[]
    deleteMany?: XPPurchaseScalarWhereInput | XPPurchaseScalarWhereInput[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityFilter<$PrismaModel> | $Enums.Priority
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityWithAggregatesFilter<$PrismaModel> | $Enums.Priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriorityFilter<$PrismaModel>
    _max?: NestedEnumPriorityFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumAutomationCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.AutomationCategory | EnumAutomationCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.AutomationCategory[] | ListEnumAutomationCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.AutomationCategory[] | ListEnumAutomationCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumAutomationCategoryFilter<$PrismaModel> | $Enums.AutomationCategory
  }

  export type NestedEnumAutomationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AutomationStatus | EnumAutomationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AutomationStatus[] | ListEnumAutomationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AutomationStatus[] | ListEnumAutomationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAutomationStatusFilter<$PrismaModel> | $Enums.AutomationStatus
  }

  export type NestedEnumAutomationCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AutomationCategory | EnumAutomationCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.AutomationCategory[] | ListEnumAutomationCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.AutomationCategory[] | ListEnumAutomationCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumAutomationCategoryWithAggregatesFilter<$PrismaModel> | $Enums.AutomationCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAutomationCategoryFilter<$PrismaModel>
    _max?: NestedEnumAutomationCategoryFilter<$PrismaModel>
  }

  export type NestedEnumAutomationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AutomationStatus | EnumAutomationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AutomationStatus[] | ListEnumAutomationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AutomationStatus[] | ListEnumAutomationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAutomationStatusWithAggregatesFilter<$PrismaModel> | $Enums.AutomationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAutomationStatusFilter<$PrismaModel>
    _max?: NestedEnumAutomationStatusFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumRoutineTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RoutineType | EnumRoutineTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RoutineType[] | ListEnumRoutineTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoutineType[] | ListEnumRoutineTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRoutineTypeFilter<$PrismaModel> | $Enums.RoutineType
  }

  export type NestedEnumRoutineTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoutineType | EnumRoutineTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RoutineType[] | ListEnumRoutineTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoutineType[] | ListEnumRoutineTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRoutineTypeWithAggregatesFilter<$PrismaModel> | $Enums.RoutineType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoutineTypeFilter<$PrismaModel>
    _max?: NestedEnumRoutineTypeFilter<$PrismaModel>
  }

  export type NestedEnumTimeBlockCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.TimeBlockCategory | EnumTimeBlockCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.TimeBlockCategory[] | ListEnumTimeBlockCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.TimeBlockCategory[] | ListEnumTimeBlockCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumTimeBlockCategoryFilter<$PrismaModel> | $Enums.TimeBlockCategory
  }

  export type NestedEnumTimeBlockCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TimeBlockCategory | EnumTimeBlockCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.TimeBlockCategory[] | ListEnumTimeBlockCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.TimeBlockCategory[] | ListEnumTimeBlockCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumTimeBlockCategoryWithAggregatesFilter<$PrismaModel> | $Enums.TimeBlockCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTimeBlockCategoryFilter<$PrismaModel>
    _max?: NestedEnumTimeBlockCategoryFilter<$PrismaModel>
  }

  export type NestedEnumAchievementCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.AchievementCategory | EnumAchievementCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.AchievementCategory[] | ListEnumAchievementCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.AchievementCategory[] | ListEnumAchievementCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumAchievementCategoryFilter<$PrismaModel> | $Enums.AchievementCategory
  }

  export type NestedEnumAchievementCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AchievementCategory | EnumAchievementCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.AchievementCategory[] | ListEnumAchievementCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.AchievementCategory[] | ListEnumAchievementCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumAchievementCategoryWithAggregatesFilter<$PrismaModel> | $Enums.AchievementCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAchievementCategoryFilter<$PrismaModel>
    _max?: NestedEnumAchievementCategoryFilter<$PrismaModel>
  }

  export type LightWorkTaskCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    priority?: $Enums.Priority
    completed?: boolean
    originalDate: string
    currentDate: string
    estimatedDuration?: number | null
    rollovers?: number
    tags?: LightWorkTaskCreatetagsInput | string[]
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    startedAt?: Date | string | null
    actualDurationMin?: number | null
    timeEstimate?: string | null
    aiAnalyzed?: boolean
    aiReasoning?: string | null
    analyzedAt?: Date | string | null
    xpReward?: number | null
    complexity?: number | null
    confidence?: number | null
    contextualBonus?: number | null
    difficulty?: number | null
    learningValue?: number | null
    priorityRank?: number | null
    strategicImportance?: number | null
    timeAccuracy?: number | null
    subtasks?: LightWorkSubtaskCreateNestedManyWithoutTaskInput
  }

  export type LightWorkTaskUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    priority?: $Enums.Priority
    completed?: boolean
    originalDate: string
    currentDate: string
    estimatedDuration?: number | null
    rollovers?: number
    tags?: LightWorkTaskCreatetagsInput | string[]
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    startedAt?: Date | string | null
    actualDurationMin?: number | null
    timeEstimate?: string | null
    aiAnalyzed?: boolean
    aiReasoning?: string | null
    analyzedAt?: Date | string | null
    xpReward?: number | null
    complexity?: number | null
    confidence?: number | null
    contextualBonus?: number | null
    difficulty?: number | null
    learningValue?: number | null
    priorityRank?: number | null
    strategicImportance?: number | null
    timeAccuracy?: number | null
    subtasks?: LightWorkSubtaskUncheckedCreateNestedManyWithoutTaskInput
  }

  export type LightWorkTaskCreateOrConnectWithoutUserInput = {
    where: LightWorkTaskWhereUniqueInput
    create: XOR<LightWorkTaskCreateWithoutUserInput, LightWorkTaskUncheckedCreateWithoutUserInput>
  }

  export type LightWorkTaskCreateManyUserInputEnvelope = {
    data: LightWorkTaskCreateManyUserInput | LightWorkTaskCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DeepWorkTaskCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    priority?: $Enums.Priority
    completed?: boolean
    originalDate: string
    currentDate: string
    estimatedDuration?: number | null
    focusBlocks?: number
    breakDuration?: number
    interruptionMode?: boolean
    rollovers?: number
    tags?: DeepWorkTaskCreatetagsInput | string[]
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    startedAt?: Date | string | null
    actualDurationMin?: number | null
    timeEstimate?: string | null
    aiAnalyzed?: boolean
    aiReasoning?: string | null
    analyzedAt?: Date | string | null
    xpReward?: number | null
    complexity?: number | null
    confidence?: number | null
    contextualBonus?: number | null
    difficulty?: number | null
    learningValue?: number | null
    priorityRank?: number | null
    strategicImportance?: number | null
    timeAccuracy?: number | null
    subtasks?: DeepWorkSubtaskCreateNestedManyWithoutTaskInput
  }

  export type DeepWorkTaskUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    priority?: $Enums.Priority
    completed?: boolean
    originalDate: string
    currentDate: string
    estimatedDuration?: number | null
    focusBlocks?: number
    breakDuration?: number
    interruptionMode?: boolean
    rollovers?: number
    tags?: DeepWorkTaskCreatetagsInput | string[]
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    startedAt?: Date | string | null
    actualDurationMin?: number | null
    timeEstimate?: string | null
    aiAnalyzed?: boolean
    aiReasoning?: string | null
    analyzedAt?: Date | string | null
    xpReward?: number | null
    complexity?: number | null
    confidence?: number | null
    contextualBonus?: number | null
    difficulty?: number | null
    learningValue?: number | null
    priorityRank?: number | null
    strategicImportance?: number | null
    timeAccuracy?: number | null
    subtasks?: DeepWorkSubtaskUncheckedCreateNestedManyWithoutTaskInput
  }

  export type DeepWorkTaskCreateOrConnectWithoutUserInput = {
    where: DeepWorkTaskWhereUniqueInput
    create: XOR<DeepWorkTaskCreateWithoutUserInput, DeepWorkTaskUncheckedCreateWithoutUserInput>
  }

  export type DeepWorkTaskCreateManyUserInputEnvelope = {
    data: DeepWorkTaskCreateManyUserInput | DeepWorkTaskCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PersonalContextCreateWithoutUserInput = {
    id?: string
    currentGoals?: string | null
    skillPriorities?: string | null
    revenueTargets?: string | null
    timeConstraints?: string | null
    currentProjects?: string | null
    hatedTasks?: string | null
    valuedTasks?: string | null
    learningObjectives?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PersonalContextUncheckedCreateWithoutUserInput = {
    id?: string
    currentGoals?: string | null
    skillPriorities?: string | null
    revenueTargets?: string | null
    timeConstraints?: string | null
    currentProjects?: string | null
    hatedTasks?: string | null
    valuedTasks?: string | null
    learningObjectives?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PersonalContextCreateOrConnectWithoutUserInput = {
    where: PersonalContextWhereUniqueInput
    create: XOR<PersonalContextCreateWithoutUserInput, PersonalContextUncheckedCreateWithoutUserInput>
  }

  export type PersonalContextCreateManyUserInputEnvelope = {
    data: PersonalContextCreateManyUserInput | PersonalContextCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AutomationTaskCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    category: $Enums.AutomationCategory
    priority: $Enums.Priority
    status?: $Enums.AutomationStatus
    prompt: string
    allowedTools?: JsonNullValueInput | InputJsonValue
    estimatedTokens?: number
    actualTokens?: number | null
    executionTimeMs?: number | null
    result?: string | null
    error?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type AutomationTaskUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    category: $Enums.AutomationCategory
    priority: $Enums.Priority
    status?: $Enums.AutomationStatus
    prompt: string
    allowedTools?: JsonNullValueInput | InputJsonValue
    estimatedTokens?: number
    actualTokens?: number | null
    executionTimeMs?: number | null
    result?: string | null
    error?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type AutomationTaskCreateOrConnectWithoutUserInput = {
    where: AutomationTaskWhereUniqueInput
    create: XOR<AutomationTaskCreateWithoutUserInput, AutomationTaskUncheckedCreateWithoutUserInput>
  }

  export type AutomationTaskCreateManyUserInputEnvelope = {
    data: AutomationTaskCreateManyUserInput | AutomationTaskCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DailyHabitsCreateWithoutUserInput = {
    id?: string
    date: string
    screenTimeMinutes?: number
    bullshitContentMinutes?: number
    noWeed?: boolean
    noScrolling?: boolean
    deepWorkHours?: number
    lightWorkHours?: number
    habitsData?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyHabitsUncheckedCreateWithoutUserInput = {
    id?: string
    date: string
    screenTimeMinutes?: number
    bullshitContentMinutes?: number
    noWeed?: boolean
    noScrolling?: boolean
    deepWorkHours?: number
    lightWorkHours?: number
    habitsData?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyHabitsCreateOrConnectWithoutUserInput = {
    where: DailyHabitsWhereUniqueInput
    create: XOR<DailyHabitsCreateWithoutUserInput, DailyHabitsUncheckedCreateWithoutUserInput>
  }

  export type DailyHabitsCreateManyUserInputEnvelope = {
    data: DailyHabitsCreateManyUserInput | DailyHabitsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DailyHealthCreateWithoutUserInput = {
    id?: string
    date: string
    healthChecklist?: JsonNullValueInput | InputJsonValue
    meals?: JsonNullValueInput | InputJsonValue
    macros?: JsonNullValueInput | InputJsonValue
    waterIntakeMl?: number
    milkIntakeMl?: number
    sleepHours?: number
    energyLevel?: number | null
    moodLevel?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyHealthUncheckedCreateWithoutUserInput = {
    id?: string
    date: string
    healthChecklist?: JsonNullValueInput | InputJsonValue
    meals?: JsonNullValueInput | InputJsonValue
    macros?: JsonNullValueInput | InputJsonValue
    waterIntakeMl?: number
    milkIntakeMl?: number
    sleepHours?: number
    energyLevel?: number | null
    moodLevel?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyHealthCreateOrConnectWithoutUserInput = {
    where: DailyHealthWhereUniqueInput
    create: XOR<DailyHealthCreateWithoutUserInput, DailyHealthUncheckedCreateWithoutUserInput>
  }

  export type DailyHealthCreateManyUserInputEnvelope = {
    data: DailyHealthCreateManyUserInput | DailyHealthCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DailyWorkoutCreateWithoutUserInput = {
    id?: string
    date: string
    exercises?: JsonNullValueInput | InputJsonValue
    totalExercises?: number
    completedExercises?: number
    completionPercentage?: number
    durationMinutes?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyWorkoutUncheckedCreateWithoutUserInput = {
    id?: string
    date: string
    exercises?: JsonNullValueInput | InputJsonValue
    totalExercises?: number
    completedExercises?: number
    completionPercentage?: number
    durationMinutes?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyWorkoutCreateOrConnectWithoutUserInput = {
    where: DailyWorkoutWhereUniqueInput
    create: XOR<DailyWorkoutCreateWithoutUserInput, DailyWorkoutUncheckedCreateWithoutUserInput>
  }

  export type DailyWorkoutCreateManyUserInputEnvelope = {
    data: DailyWorkoutCreateManyUserInput | DailyWorkoutCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DailyRoutineCreateWithoutUserInput = {
    id?: string
    date: string
    routineType: $Enums.RoutineType
    items?: JsonNullValueInput | InputJsonValue
    completedCount?: number
    totalCount?: number
    completionPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyRoutineUncheckedCreateWithoutUserInput = {
    id?: string
    date: string
    routineType: $Enums.RoutineType
    items?: JsonNullValueInput | InputJsonValue
    completedCount?: number
    totalCount?: number
    completionPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyRoutineCreateOrConnectWithoutUserInput = {
    where: DailyRoutineWhereUniqueInput
    create: XOR<DailyRoutineCreateWithoutUserInput, DailyRoutineUncheckedCreateWithoutUserInput>
  }

  export type DailyRoutineCreateManyUserInputEnvelope = {
    data: DailyRoutineCreateManyUserInput | DailyRoutineCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DailyReflectionsCreateWithoutUserInput = {
    id?: string
    date: string
    wentWell?: DailyReflectionsCreatewentWellInput | string[]
    evenBetterIf?: DailyReflectionsCreateevenBetterIfInput | string[]
    analysis?: DailyReflectionsCreateanalysisInput | string[]
    patterns?: DailyReflectionsCreatepatternsInput | string[]
    changes?: DailyReflectionsCreatechangesInput | string[]
    overallRating?: number | null
    keyLearnings?: string | null
    tomorrowFocus?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyReflectionsUncheckedCreateWithoutUserInput = {
    id?: string
    date: string
    wentWell?: DailyReflectionsCreatewentWellInput | string[]
    evenBetterIf?: DailyReflectionsCreateevenBetterIfInput | string[]
    analysis?: DailyReflectionsCreateanalysisInput | string[]
    patterns?: DailyReflectionsCreatepatternsInput | string[]
    changes?: DailyReflectionsCreatechangesInput | string[]
    overallRating?: number | null
    keyLearnings?: string | null
    tomorrowFocus?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyReflectionsCreateOrConnectWithoutUserInput = {
    where: DailyReflectionsWhereUniqueInput
    create: XOR<DailyReflectionsCreateWithoutUserInput, DailyReflectionsUncheckedCreateWithoutUserInput>
  }

  export type DailyReflectionsCreateManyUserInputEnvelope = {
    data: DailyReflectionsCreateManyUserInput | DailyReflectionsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TimeBlockCreateWithoutUserInput = {
    id?: string
    date: string
    startTime: string
    endTime: string
    title: string
    description?: string | null
    category: $Enums.TimeBlockCategory
    completed?: boolean
    actualStart?: string | null
    actualEnd?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimeBlockUncheckedCreateWithoutUserInput = {
    id?: string
    date: string
    startTime: string
    endTime: string
    title: string
    description?: string | null
    category: $Enums.TimeBlockCategory
    completed?: boolean
    actualStart?: string | null
    actualEnd?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimeBlockCreateOrConnectWithoutUserInput = {
    where: TimeBlockWhereUniqueInput
    create: XOR<TimeBlockCreateWithoutUserInput, TimeBlockUncheckedCreateWithoutUserInput>
  }

  export type TimeBlockCreateManyUserInputEnvelope = {
    data: TimeBlockCreateManyUserInput | TimeBlockCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserProgressCreateWithoutUserInput = {
    id?: string
    currentLevel?: number
    totalXP?: number
    dailyXP?: number
    currentStreak?: number
    bestStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    achievements?: AchievementCreateNestedManyWithoutUserProgressInput
    dailyStats?: DailyStatsCreateNestedManyWithoutUserProgressInput
  }

  export type UserProgressUncheckedCreateWithoutUserInput = {
    id?: string
    currentLevel?: number
    totalXP?: number
    dailyXP?: number
    currentStreak?: number
    bestStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserProgressInput
    dailyStats?: DailyStatsUncheckedCreateNestedManyWithoutUserProgressInput
  }

  export type UserProgressCreateOrConnectWithoutUserInput = {
    where: UserProgressWhereUniqueInput
    create: XOR<UserProgressCreateWithoutUserInput, UserProgressUncheckedCreateWithoutUserInput>
  }

  export type UserProgressCreateManyUserInputEnvelope = {
    data: UserProgressCreateManyUserInput | UserProgressCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type XPBalanceCreateWithoutUserInput = {
    id?: string
    currentXP?: number
    totalEarned?: number
    totalSpent?: number
    reserveXP?: number
    pendingLoans?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type XPBalanceUncheckedCreateWithoutUserInput = {
    id?: string
    currentXP?: number
    totalEarned?: number
    totalSpent?: number
    reserveXP?: number
    pendingLoans?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type XPBalanceCreateOrConnectWithoutUserInput = {
    where: XPBalanceWhereUniqueInput
    create: XOR<XPBalanceCreateWithoutUserInput, XPBalanceUncheckedCreateWithoutUserInput>
  }

  export type XPBalanceCreateManyUserInputEnvelope = {
    data: XPBalanceCreateManyUserInput | XPBalanceCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type XPPurchaseCreateWithoutUserInput = {
    id?: string
    xpSpent: number
    actualPrice: number
    purchaseType?: string
    notes?: string | null
    satisfactionRating?: number | null
    guiltLevel?: number | null
    wasPlanned?: boolean
    celebrationLevel?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reward: RewardDefinitionCreateNestedOneWithoutPurchasesInput
  }

  export type XPPurchaseUncheckedCreateWithoutUserInput = {
    id?: string
    rewardId: string
    xpSpent: number
    actualPrice: number
    purchaseType?: string
    notes?: string | null
    satisfactionRating?: number | null
    guiltLevel?: number | null
    wasPlanned?: boolean
    celebrationLevel?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type XPPurchaseCreateOrConnectWithoutUserInput = {
    where: XPPurchaseWhereUniqueInput
    create: XOR<XPPurchaseCreateWithoutUserInput, XPPurchaseUncheckedCreateWithoutUserInput>
  }

  export type XPPurchaseCreateManyUserInputEnvelope = {
    data: XPPurchaseCreateManyUserInput | XPPurchaseCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type XPEarningLogCreateWithoutUserInput = {
    id?: string
    source: string
    sourceId?: string | null
    baseXP: number
    finalXP: number
    multipliers?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type XPEarningLogUncheckedCreateWithoutUserInput = {
    id?: string
    source: string
    sourceId?: string | null
    baseXP: number
    finalXP: number
    multipliers?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type XPEarningLogCreateOrConnectWithoutUserInput = {
    where: XPEarningLogWhereUniqueInput
    create: XOR<XPEarningLogCreateWithoutUserInput, XPEarningLogUncheckedCreateWithoutUserInput>
  }

  export type XPEarningLogCreateManyUserInputEnvelope = {
    data: XPEarningLogCreateManyUserInput | XPEarningLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LightWorkTaskUpsertWithWhereUniqueWithoutUserInput = {
    where: LightWorkTaskWhereUniqueInput
    update: XOR<LightWorkTaskUpdateWithoutUserInput, LightWorkTaskUncheckedUpdateWithoutUserInput>
    create: XOR<LightWorkTaskCreateWithoutUserInput, LightWorkTaskUncheckedCreateWithoutUserInput>
  }

  export type LightWorkTaskUpdateWithWhereUniqueWithoutUserInput = {
    where: LightWorkTaskWhereUniqueInput
    data: XOR<LightWorkTaskUpdateWithoutUserInput, LightWorkTaskUncheckedUpdateWithoutUserInput>
  }

  export type LightWorkTaskUpdateManyWithWhereWithoutUserInput = {
    where: LightWorkTaskScalarWhereInput
    data: XOR<LightWorkTaskUpdateManyMutationInput, LightWorkTaskUncheckedUpdateManyWithoutUserInput>
  }

  export type LightWorkTaskScalarWhereInput = {
    AND?: LightWorkTaskScalarWhereInput | LightWorkTaskScalarWhereInput[]
    OR?: LightWorkTaskScalarWhereInput[]
    NOT?: LightWorkTaskScalarWhereInput | LightWorkTaskScalarWhereInput[]
    id?: StringFilter<"LightWorkTask"> | string
    userId?: StringFilter<"LightWorkTask"> | string
    title?: StringFilter<"LightWorkTask"> | string
    description?: StringNullableFilter<"LightWorkTask"> | string | null
    priority?: EnumPriorityFilter<"LightWorkTask"> | $Enums.Priority
    completed?: BoolFilter<"LightWorkTask"> | boolean
    originalDate?: StringFilter<"LightWorkTask"> | string
    currentDate?: StringFilter<"LightWorkTask"> | string
    estimatedDuration?: IntNullableFilter<"LightWorkTask"> | number | null
    rollovers?: IntFilter<"LightWorkTask"> | number
    tags?: StringNullableListFilter<"LightWorkTask">
    category?: StringNullableFilter<"LightWorkTask"> | string | null
    createdAt?: DateTimeFilter<"LightWorkTask"> | Date | string
    updatedAt?: DateTimeFilter<"LightWorkTask"> | Date | string
    completedAt?: DateTimeNullableFilter<"LightWorkTask"> | Date | string | null
    startedAt?: DateTimeNullableFilter<"LightWorkTask"> | Date | string | null
    actualDurationMin?: IntNullableFilter<"LightWorkTask"> | number | null
    timeEstimate?: StringNullableFilter<"LightWorkTask"> | string | null
    aiAnalyzed?: BoolFilter<"LightWorkTask"> | boolean
    aiReasoning?: StringNullableFilter<"LightWorkTask"> | string | null
    analyzedAt?: DateTimeNullableFilter<"LightWorkTask"> | Date | string | null
    xpReward?: IntNullableFilter<"LightWorkTask"> | number | null
    complexity?: IntNullableFilter<"LightWorkTask"> | number | null
    confidence?: FloatNullableFilter<"LightWorkTask"> | number | null
    contextualBonus?: FloatNullableFilter<"LightWorkTask"> | number | null
    difficulty?: IntNullableFilter<"LightWorkTask"> | number | null
    learningValue?: IntNullableFilter<"LightWorkTask"> | number | null
    priorityRank?: IntNullableFilter<"LightWorkTask"> | number | null
    strategicImportance?: IntNullableFilter<"LightWorkTask"> | number | null
    timeAccuracy?: FloatNullableFilter<"LightWorkTask"> | number | null
  }

  export type DeepWorkTaskUpsertWithWhereUniqueWithoutUserInput = {
    where: DeepWorkTaskWhereUniqueInput
    update: XOR<DeepWorkTaskUpdateWithoutUserInput, DeepWorkTaskUncheckedUpdateWithoutUserInput>
    create: XOR<DeepWorkTaskCreateWithoutUserInput, DeepWorkTaskUncheckedCreateWithoutUserInput>
  }

  export type DeepWorkTaskUpdateWithWhereUniqueWithoutUserInput = {
    where: DeepWorkTaskWhereUniqueInput
    data: XOR<DeepWorkTaskUpdateWithoutUserInput, DeepWorkTaskUncheckedUpdateWithoutUserInput>
  }

  export type DeepWorkTaskUpdateManyWithWhereWithoutUserInput = {
    where: DeepWorkTaskScalarWhereInput
    data: XOR<DeepWorkTaskUpdateManyMutationInput, DeepWorkTaskUncheckedUpdateManyWithoutUserInput>
  }

  export type DeepWorkTaskScalarWhereInput = {
    AND?: DeepWorkTaskScalarWhereInput | DeepWorkTaskScalarWhereInput[]
    OR?: DeepWorkTaskScalarWhereInput[]
    NOT?: DeepWorkTaskScalarWhereInput | DeepWorkTaskScalarWhereInput[]
    id?: StringFilter<"DeepWorkTask"> | string
    userId?: StringFilter<"DeepWorkTask"> | string
    title?: StringFilter<"DeepWorkTask"> | string
    description?: StringNullableFilter<"DeepWorkTask"> | string | null
    priority?: EnumPriorityFilter<"DeepWorkTask"> | $Enums.Priority
    completed?: BoolFilter<"DeepWorkTask"> | boolean
    originalDate?: StringFilter<"DeepWorkTask"> | string
    currentDate?: StringFilter<"DeepWorkTask"> | string
    estimatedDuration?: IntNullableFilter<"DeepWorkTask"> | number | null
    focusBlocks?: IntFilter<"DeepWorkTask"> | number
    breakDuration?: IntFilter<"DeepWorkTask"> | number
    interruptionMode?: BoolFilter<"DeepWorkTask"> | boolean
    rollovers?: IntFilter<"DeepWorkTask"> | number
    tags?: StringNullableListFilter<"DeepWorkTask">
    category?: StringNullableFilter<"DeepWorkTask"> | string | null
    createdAt?: DateTimeFilter<"DeepWorkTask"> | Date | string
    updatedAt?: DateTimeFilter<"DeepWorkTask"> | Date | string
    completedAt?: DateTimeNullableFilter<"DeepWorkTask"> | Date | string | null
    startedAt?: DateTimeNullableFilter<"DeepWorkTask"> | Date | string | null
    actualDurationMin?: IntNullableFilter<"DeepWorkTask"> | number | null
    timeEstimate?: StringNullableFilter<"DeepWorkTask"> | string | null
    aiAnalyzed?: BoolFilter<"DeepWorkTask"> | boolean
    aiReasoning?: StringNullableFilter<"DeepWorkTask"> | string | null
    analyzedAt?: DateTimeNullableFilter<"DeepWorkTask"> | Date | string | null
    xpReward?: IntNullableFilter<"DeepWorkTask"> | number | null
    complexity?: IntNullableFilter<"DeepWorkTask"> | number | null
    confidence?: FloatNullableFilter<"DeepWorkTask"> | number | null
    contextualBonus?: FloatNullableFilter<"DeepWorkTask"> | number | null
    difficulty?: IntNullableFilter<"DeepWorkTask"> | number | null
    learningValue?: IntNullableFilter<"DeepWorkTask"> | number | null
    priorityRank?: IntNullableFilter<"DeepWorkTask"> | number | null
    strategicImportance?: IntNullableFilter<"DeepWorkTask"> | number | null
    timeAccuracy?: FloatNullableFilter<"DeepWorkTask"> | number | null
  }

  export type PersonalContextUpsertWithWhereUniqueWithoutUserInput = {
    where: PersonalContextWhereUniqueInput
    update: XOR<PersonalContextUpdateWithoutUserInput, PersonalContextUncheckedUpdateWithoutUserInput>
    create: XOR<PersonalContextCreateWithoutUserInput, PersonalContextUncheckedCreateWithoutUserInput>
  }

  export type PersonalContextUpdateWithWhereUniqueWithoutUserInput = {
    where: PersonalContextWhereUniqueInput
    data: XOR<PersonalContextUpdateWithoutUserInput, PersonalContextUncheckedUpdateWithoutUserInput>
  }

  export type PersonalContextUpdateManyWithWhereWithoutUserInput = {
    where: PersonalContextScalarWhereInput
    data: XOR<PersonalContextUpdateManyMutationInput, PersonalContextUncheckedUpdateManyWithoutUserInput>
  }

  export type PersonalContextScalarWhereInput = {
    AND?: PersonalContextScalarWhereInput | PersonalContextScalarWhereInput[]
    OR?: PersonalContextScalarWhereInput[]
    NOT?: PersonalContextScalarWhereInput | PersonalContextScalarWhereInput[]
    id?: StringFilter<"PersonalContext"> | string
    userId?: StringFilter<"PersonalContext"> | string
    currentGoals?: StringNullableFilter<"PersonalContext"> | string | null
    skillPriorities?: StringNullableFilter<"PersonalContext"> | string | null
    revenueTargets?: StringNullableFilter<"PersonalContext"> | string | null
    timeConstraints?: StringNullableFilter<"PersonalContext"> | string | null
    currentProjects?: StringNullableFilter<"PersonalContext"> | string | null
    hatedTasks?: StringNullableFilter<"PersonalContext"> | string | null
    valuedTasks?: StringNullableFilter<"PersonalContext"> | string | null
    learningObjectives?: StringNullableFilter<"PersonalContext"> | string | null
    createdAt?: DateTimeFilter<"PersonalContext"> | Date | string
    updatedAt?: DateTimeFilter<"PersonalContext"> | Date | string
  }

  export type AutomationTaskUpsertWithWhereUniqueWithoutUserInput = {
    where: AutomationTaskWhereUniqueInput
    update: XOR<AutomationTaskUpdateWithoutUserInput, AutomationTaskUncheckedUpdateWithoutUserInput>
    create: XOR<AutomationTaskCreateWithoutUserInput, AutomationTaskUncheckedCreateWithoutUserInput>
  }

  export type AutomationTaskUpdateWithWhereUniqueWithoutUserInput = {
    where: AutomationTaskWhereUniqueInput
    data: XOR<AutomationTaskUpdateWithoutUserInput, AutomationTaskUncheckedUpdateWithoutUserInput>
  }

  export type AutomationTaskUpdateManyWithWhereWithoutUserInput = {
    where: AutomationTaskScalarWhereInput
    data: XOR<AutomationTaskUpdateManyMutationInput, AutomationTaskUncheckedUpdateManyWithoutUserInput>
  }

  export type AutomationTaskScalarWhereInput = {
    AND?: AutomationTaskScalarWhereInput | AutomationTaskScalarWhereInput[]
    OR?: AutomationTaskScalarWhereInput[]
    NOT?: AutomationTaskScalarWhereInput | AutomationTaskScalarWhereInput[]
    id?: StringFilter<"AutomationTask"> | string
    userId?: StringFilter<"AutomationTask"> | string
    name?: StringFilter<"AutomationTask"> | string
    description?: StringNullableFilter<"AutomationTask"> | string | null
    category?: EnumAutomationCategoryFilter<"AutomationTask"> | $Enums.AutomationCategory
    priority?: EnumPriorityFilter<"AutomationTask"> | $Enums.Priority
    status?: EnumAutomationStatusFilter<"AutomationTask"> | $Enums.AutomationStatus
    prompt?: StringFilter<"AutomationTask"> | string
    allowedTools?: JsonFilter<"AutomationTask">
    estimatedTokens?: IntFilter<"AutomationTask"> | number
    actualTokens?: IntNullableFilter<"AutomationTask"> | number | null
    executionTimeMs?: IntNullableFilter<"AutomationTask"> | number | null
    result?: StringNullableFilter<"AutomationTask"> | string | null
    error?: StringNullableFilter<"AutomationTask"> | string | null
    metadata?: JsonFilter<"AutomationTask">
    createdAt?: DateTimeFilter<"AutomationTask"> | Date | string
    updatedAt?: DateTimeFilter<"AutomationTask"> | Date | string
    startedAt?: DateTimeNullableFilter<"AutomationTask"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"AutomationTask"> | Date | string | null
  }

  export type DailyHabitsUpsertWithWhereUniqueWithoutUserInput = {
    where: DailyHabitsWhereUniqueInput
    update: XOR<DailyHabitsUpdateWithoutUserInput, DailyHabitsUncheckedUpdateWithoutUserInput>
    create: XOR<DailyHabitsCreateWithoutUserInput, DailyHabitsUncheckedCreateWithoutUserInput>
  }

  export type DailyHabitsUpdateWithWhereUniqueWithoutUserInput = {
    where: DailyHabitsWhereUniqueInput
    data: XOR<DailyHabitsUpdateWithoutUserInput, DailyHabitsUncheckedUpdateWithoutUserInput>
  }

  export type DailyHabitsUpdateManyWithWhereWithoutUserInput = {
    where: DailyHabitsScalarWhereInput
    data: XOR<DailyHabitsUpdateManyMutationInput, DailyHabitsUncheckedUpdateManyWithoutUserInput>
  }

  export type DailyHabitsScalarWhereInput = {
    AND?: DailyHabitsScalarWhereInput | DailyHabitsScalarWhereInput[]
    OR?: DailyHabitsScalarWhereInput[]
    NOT?: DailyHabitsScalarWhereInput | DailyHabitsScalarWhereInput[]
    id?: StringFilter<"DailyHabits"> | string
    userId?: StringFilter<"DailyHabits"> | string
    date?: StringFilter<"DailyHabits"> | string
    screenTimeMinutes?: IntFilter<"DailyHabits"> | number
    bullshitContentMinutes?: IntFilter<"DailyHabits"> | number
    noWeed?: BoolFilter<"DailyHabits"> | boolean
    noScrolling?: BoolFilter<"DailyHabits"> | boolean
    deepWorkHours?: FloatFilter<"DailyHabits"> | number
    lightWorkHours?: FloatFilter<"DailyHabits"> | number
    habitsData?: JsonFilter<"DailyHabits">
    createdAt?: DateTimeFilter<"DailyHabits"> | Date | string
    updatedAt?: DateTimeFilter<"DailyHabits"> | Date | string
  }

  export type DailyHealthUpsertWithWhereUniqueWithoutUserInput = {
    where: DailyHealthWhereUniqueInput
    update: XOR<DailyHealthUpdateWithoutUserInput, DailyHealthUncheckedUpdateWithoutUserInput>
    create: XOR<DailyHealthCreateWithoutUserInput, DailyHealthUncheckedCreateWithoutUserInput>
  }

  export type DailyHealthUpdateWithWhereUniqueWithoutUserInput = {
    where: DailyHealthWhereUniqueInput
    data: XOR<DailyHealthUpdateWithoutUserInput, DailyHealthUncheckedUpdateWithoutUserInput>
  }

  export type DailyHealthUpdateManyWithWhereWithoutUserInput = {
    where: DailyHealthScalarWhereInput
    data: XOR<DailyHealthUpdateManyMutationInput, DailyHealthUncheckedUpdateManyWithoutUserInput>
  }

  export type DailyHealthScalarWhereInput = {
    AND?: DailyHealthScalarWhereInput | DailyHealthScalarWhereInput[]
    OR?: DailyHealthScalarWhereInput[]
    NOT?: DailyHealthScalarWhereInput | DailyHealthScalarWhereInput[]
    id?: StringFilter<"DailyHealth"> | string
    userId?: StringFilter<"DailyHealth"> | string
    date?: StringFilter<"DailyHealth"> | string
    healthChecklist?: JsonFilter<"DailyHealth">
    meals?: JsonFilter<"DailyHealth">
    macros?: JsonFilter<"DailyHealth">
    waterIntakeMl?: IntFilter<"DailyHealth"> | number
    milkIntakeMl?: IntFilter<"DailyHealth"> | number
    sleepHours?: FloatFilter<"DailyHealth"> | number
    energyLevel?: IntNullableFilter<"DailyHealth"> | number | null
    moodLevel?: IntNullableFilter<"DailyHealth"> | number | null
    notes?: StringNullableFilter<"DailyHealth"> | string | null
    createdAt?: DateTimeFilter<"DailyHealth"> | Date | string
    updatedAt?: DateTimeFilter<"DailyHealth"> | Date | string
  }

  export type DailyWorkoutUpsertWithWhereUniqueWithoutUserInput = {
    where: DailyWorkoutWhereUniqueInput
    update: XOR<DailyWorkoutUpdateWithoutUserInput, DailyWorkoutUncheckedUpdateWithoutUserInput>
    create: XOR<DailyWorkoutCreateWithoutUserInput, DailyWorkoutUncheckedCreateWithoutUserInput>
  }

  export type DailyWorkoutUpdateWithWhereUniqueWithoutUserInput = {
    where: DailyWorkoutWhereUniqueInput
    data: XOR<DailyWorkoutUpdateWithoutUserInput, DailyWorkoutUncheckedUpdateWithoutUserInput>
  }

  export type DailyWorkoutUpdateManyWithWhereWithoutUserInput = {
    where: DailyWorkoutScalarWhereInput
    data: XOR<DailyWorkoutUpdateManyMutationInput, DailyWorkoutUncheckedUpdateManyWithoutUserInput>
  }

  export type DailyWorkoutScalarWhereInput = {
    AND?: DailyWorkoutScalarWhereInput | DailyWorkoutScalarWhereInput[]
    OR?: DailyWorkoutScalarWhereInput[]
    NOT?: DailyWorkoutScalarWhereInput | DailyWorkoutScalarWhereInput[]
    id?: StringFilter<"DailyWorkout"> | string
    userId?: StringFilter<"DailyWorkout"> | string
    date?: StringFilter<"DailyWorkout"> | string
    exercises?: JsonFilter<"DailyWorkout">
    totalExercises?: IntFilter<"DailyWorkout"> | number
    completedExercises?: IntFilter<"DailyWorkout"> | number
    completionPercentage?: FloatFilter<"DailyWorkout"> | number
    durationMinutes?: IntNullableFilter<"DailyWorkout"> | number | null
    notes?: StringNullableFilter<"DailyWorkout"> | string | null
    createdAt?: DateTimeFilter<"DailyWorkout"> | Date | string
    updatedAt?: DateTimeFilter<"DailyWorkout"> | Date | string
  }

  export type DailyRoutineUpsertWithWhereUniqueWithoutUserInput = {
    where: DailyRoutineWhereUniqueInput
    update: XOR<DailyRoutineUpdateWithoutUserInput, DailyRoutineUncheckedUpdateWithoutUserInput>
    create: XOR<DailyRoutineCreateWithoutUserInput, DailyRoutineUncheckedCreateWithoutUserInput>
  }

  export type DailyRoutineUpdateWithWhereUniqueWithoutUserInput = {
    where: DailyRoutineWhereUniqueInput
    data: XOR<DailyRoutineUpdateWithoutUserInput, DailyRoutineUncheckedUpdateWithoutUserInput>
  }

  export type DailyRoutineUpdateManyWithWhereWithoutUserInput = {
    where: DailyRoutineScalarWhereInput
    data: XOR<DailyRoutineUpdateManyMutationInput, DailyRoutineUncheckedUpdateManyWithoutUserInput>
  }

  export type DailyRoutineScalarWhereInput = {
    AND?: DailyRoutineScalarWhereInput | DailyRoutineScalarWhereInput[]
    OR?: DailyRoutineScalarWhereInput[]
    NOT?: DailyRoutineScalarWhereInput | DailyRoutineScalarWhereInput[]
    id?: StringFilter<"DailyRoutine"> | string
    userId?: StringFilter<"DailyRoutine"> | string
    date?: StringFilter<"DailyRoutine"> | string
    routineType?: EnumRoutineTypeFilter<"DailyRoutine"> | $Enums.RoutineType
    items?: JsonFilter<"DailyRoutine">
    completedCount?: IntFilter<"DailyRoutine"> | number
    totalCount?: IntFilter<"DailyRoutine"> | number
    completionPercentage?: FloatFilter<"DailyRoutine"> | number
    createdAt?: DateTimeFilter<"DailyRoutine"> | Date | string
    updatedAt?: DateTimeFilter<"DailyRoutine"> | Date | string
  }

  export type DailyReflectionsUpsertWithWhereUniqueWithoutUserInput = {
    where: DailyReflectionsWhereUniqueInput
    update: XOR<DailyReflectionsUpdateWithoutUserInput, DailyReflectionsUncheckedUpdateWithoutUserInput>
    create: XOR<DailyReflectionsCreateWithoutUserInput, DailyReflectionsUncheckedCreateWithoutUserInput>
  }

  export type DailyReflectionsUpdateWithWhereUniqueWithoutUserInput = {
    where: DailyReflectionsWhereUniqueInput
    data: XOR<DailyReflectionsUpdateWithoutUserInput, DailyReflectionsUncheckedUpdateWithoutUserInput>
  }

  export type DailyReflectionsUpdateManyWithWhereWithoutUserInput = {
    where: DailyReflectionsScalarWhereInput
    data: XOR<DailyReflectionsUpdateManyMutationInput, DailyReflectionsUncheckedUpdateManyWithoutUserInput>
  }

  export type DailyReflectionsScalarWhereInput = {
    AND?: DailyReflectionsScalarWhereInput | DailyReflectionsScalarWhereInput[]
    OR?: DailyReflectionsScalarWhereInput[]
    NOT?: DailyReflectionsScalarWhereInput | DailyReflectionsScalarWhereInput[]
    id?: StringFilter<"DailyReflections"> | string
    userId?: StringFilter<"DailyReflections"> | string
    date?: StringFilter<"DailyReflections"> | string
    wentWell?: StringNullableListFilter<"DailyReflections">
    evenBetterIf?: StringNullableListFilter<"DailyReflections">
    analysis?: StringNullableListFilter<"DailyReflections">
    patterns?: StringNullableListFilter<"DailyReflections">
    changes?: StringNullableListFilter<"DailyReflections">
    overallRating?: IntNullableFilter<"DailyReflections"> | number | null
    keyLearnings?: StringNullableFilter<"DailyReflections"> | string | null
    tomorrowFocus?: StringNullableFilter<"DailyReflections"> | string | null
    createdAt?: DateTimeFilter<"DailyReflections"> | Date | string
    updatedAt?: DateTimeFilter<"DailyReflections"> | Date | string
  }

  export type TimeBlockUpsertWithWhereUniqueWithoutUserInput = {
    where: TimeBlockWhereUniqueInput
    update: XOR<TimeBlockUpdateWithoutUserInput, TimeBlockUncheckedUpdateWithoutUserInput>
    create: XOR<TimeBlockCreateWithoutUserInput, TimeBlockUncheckedCreateWithoutUserInput>
  }

  export type TimeBlockUpdateWithWhereUniqueWithoutUserInput = {
    where: TimeBlockWhereUniqueInput
    data: XOR<TimeBlockUpdateWithoutUserInput, TimeBlockUncheckedUpdateWithoutUserInput>
  }

  export type TimeBlockUpdateManyWithWhereWithoutUserInput = {
    where: TimeBlockScalarWhereInput
    data: XOR<TimeBlockUpdateManyMutationInput, TimeBlockUncheckedUpdateManyWithoutUserInput>
  }

  export type TimeBlockScalarWhereInput = {
    AND?: TimeBlockScalarWhereInput | TimeBlockScalarWhereInput[]
    OR?: TimeBlockScalarWhereInput[]
    NOT?: TimeBlockScalarWhereInput | TimeBlockScalarWhereInput[]
    id?: StringFilter<"TimeBlock"> | string
    userId?: StringFilter<"TimeBlock"> | string
    date?: StringFilter<"TimeBlock"> | string
    startTime?: StringFilter<"TimeBlock"> | string
    endTime?: StringFilter<"TimeBlock"> | string
    title?: StringFilter<"TimeBlock"> | string
    description?: StringNullableFilter<"TimeBlock"> | string | null
    category?: EnumTimeBlockCategoryFilter<"TimeBlock"> | $Enums.TimeBlockCategory
    completed?: BoolFilter<"TimeBlock"> | boolean
    actualStart?: StringNullableFilter<"TimeBlock"> | string | null
    actualEnd?: StringNullableFilter<"TimeBlock"> | string | null
    notes?: StringNullableFilter<"TimeBlock"> | string | null
    createdAt?: DateTimeFilter<"TimeBlock"> | Date | string
    updatedAt?: DateTimeFilter<"TimeBlock"> | Date | string
  }

  export type UserProgressUpsertWithWhereUniqueWithoutUserInput = {
    where: UserProgressWhereUniqueInput
    update: XOR<UserProgressUpdateWithoutUserInput, UserProgressUncheckedUpdateWithoutUserInput>
    create: XOR<UserProgressCreateWithoutUserInput, UserProgressUncheckedCreateWithoutUserInput>
  }

  export type UserProgressUpdateWithWhereUniqueWithoutUserInput = {
    where: UserProgressWhereUniqueInput
    data: XOR<UserProgressUpdateWithoutUserInput, UserProgressUncheckedUpdateWithoutUserInput>
  }

  export type UserProgressUpdateManyWithWhereWithoutUserInput = {
    where: UserProgressScalarWhereInput
    data: XOR<UserProgressUpdateManyMutationInput, UserProgressUncheckedUpdateManyWithoutUserInput>
  }

  export type UserProgressScalarWhereInput = {
    AND?: UserProgressScalarWhereInput | UserProgressScalarWhereInput[]
    OR?: UserProgressScalarWhereInput[]
    NOT?: UserProgressScalarWhereInput | UserProgressScalarWhereInput[]
    id?: StringFilter<"UserProgress"> | string
    userId?: StringFilter<"UserProgress"> | string
    currentLevel?: IntFilter<"UserProgress"> | number
    totalXP?: IntFilter<"UserProgress"> | number
    dailyXP?: IntFilter<"UserProgress"> | number
    currentStreak?: IntFilter<"UserProgress"> | number
    bestStreak?: IntFilter<"UserProgress"> | number
    createdAt?: DateTimeFilter<"UserProgress"> | Date | string
    updatedAt?: DateTimeFilter<"UserProgress"> | Date | string
  }

  export type XPBalanceUpsertWithWhereUniqueWithoutUserInput = {
    where: XPBalanceWhereUniqueInput
    update: XOR<XPBalanceUpdateWithoutUserInput, XPBalanceUncheckedUpdateWithoutUserInput>
    create: XOR<XPBalanceCreateWithoutUserInput, XPBalanceUncheckedCreateWithoutUserInput>
  }

  export type XPBalanceUpdateWithWhereUniqueWithoutUserInput = {
    where: XPBalanceWhereUniqueInput
    data: XOR<XPBalanceUpdateWithoutUserInput, XPBalanceUncheckedUpdateWithoutUserInput>
  }

  export type XPBalanceUpdateManyWithWhereWithoutUserInput = {
    where: XPBalanceScalarWhereInput
    data: XOR<XPBalanceUpdateManyMutationInput, XPBalanceUncheckedUpdateManyWithoutUserInput>
  }

  export type XPBalanceScalarWhereInput = {
    AND?: XPBalanceScalarWhereInput | XPBalanceScalarWhereInput[]
    OR?: XPBalanceScalarWhereInput[]
    NOT?: XPBalanceScalarWhereInput | XPBalanceScalarWhereInput[]
    id?: StringFilter<"XPBalance"> | string
    userId?: StringFilter<"XPBalance"> | string
    currentXP?: IntFilter<"XPBalance"> | number
    totalEarned?: IntFilter<"XPBalance"> | number
    totalSpent?: IntFilter<"XPBalance"> | number
    reserveXP?: IntFilter<"XPBalance"> | number
    pendingLoans?: IntFilter<"XPBalance"> | number
    createdAt?: DateTimeFilter<"XPBalance"> | Date | string
    updatedAt?: DateTimeFilter<"XPBalance"> | Date | string
  }

  export type XPPurchaseUpsertWithWhereUniqueWithoutUserInput = {
    where: XPPurchaseWhereUniqueInput
    update: XOR<XPPurchaseUpdateWithoutUserInput, XPPurchaseUncheckedUpdateWithoutUserInput>
    create: XOR<XPPurchaseCreateWithoutUserInput, XPPurchaseUncheckedCreateWithoutUserInput>
  }

  export type XPPurchaseUpdateWithWhereUniqueWithoutUserInput = {
    where: XPPurchaseWhereUniqueInput
    data: XOR<XPPurchaseUpdateWithoutUserInput, XPPurchaseUncheckedUpdateWithoutUserInput>
  }

  export type XPPurchaseUpdateManyWithWhereWithoutUserInput = {
    where: XPPurchaseScalarWhereInput
    data: XOR<XPPurchaseUpdateManyMutationInput, XPPurchaseUncheckedUpdateManyWithoutUserInput>
  }

  export type XPPurchaseScalarWhereInput = {
    AND?: XPPurchaseScalarWhereInput | XPPurchaseScalarWhereInput[]
    OR?: XPPurchaseScalarWhereInput[]
    NOT?: XPPurchaseScalarWhereInput | XPPurchaseScalarWhereInput[]
    id?: StringFilter<"XPPurchase"> | string
    userId?: StringFilter<"XPPurchase"> | string
    rewardId?: StringFilter<"XPPurchase"> | string
    xpSpent?: IntFilter<"XPPurchase"> | number
    actualPrice?: IntFilter<"XPPurchase"> | number
    purchaseType?: StringFilter<"XPPurchase"> | string
    notes?: StringNullableFilter<"XPPurchase"> | string | null
    satisfactionRating?: IntNullableFilter<"XPPurchase"> | number | null
    guiltLevel?: IntNullableFilter<"XPPurchase"> | number | null
    wasPlanned?: BoolFilter<"XPPurchase"> | boolean
    celebrationLevel?: StringNullableFilter<"XPPurchase"> | string | null
    createdAt?: DateTimeFilter<"XPPurchase"> | Date | string
    updatedAt?: DateTimeFilter<"XPPurchase"> | Date | string
  }

  export type XPEarningLogUpsertWithWhereUniqueWithoutUserInput = {
    where: XPEarningLogWhereUniqueInput
    update: XOR<XPEarningLogUpdateWithoutUserInput, XPEarningLogUncheckedUpdateWithoutUserInput>
    create: XOR<XPEarningLogCreateWithoutUserInput, XPEarningLogUncheckedCreateWithoutUserInput>
  }

  export type XPEarningLogUpdateWithWhereUniqueWithoutUserInput = {
    where: XPEarningLogWhereUniqueInput
    data: XOR<XPEarningLogUpdateWithoutUserInput, XPEarningLogUncheckedUpdateWithoutUserInput>
  }

  export type XPEarningLogUpdateManyWithWhereWithoutUserInput = {
    where: XPEarningLogScalarWhereInput
    data: XOR<XPEarningLogUpdateManyMutationInput, XPEarningLogUncheckedUpdateManyWithoutUserInput>
  }

  export type XPEarningLogScalarWhereInput = {
    AND?: XPEarningLogScalarWhereInput | XPEarningLogScalarWhereInput[]
    OR?: XPEarningLogScalarWhereInput[]
    NOT?: XPEarningLogScalarWhereInput | XPEarningLogScalarWhereInput[]
    id?: StringFilter<"XPEarningLog"> | string
    userId?: StringFilter<"XPEarningLog"> | string
    source?: StringFilter<"XPEarningLog"> | string
    sourceId?: StringNullableFilter<"XPEarningLog"> | string | null
    baseXP?: IntFilter<"XPEarningLog"> | number
    finalXP?: IntFilter<"XPEarningLog"> | number
    multipliers?: JsonFilter<"XPEarningLog">
    createdAt?: DateTimeFilter<"XPEarningLog"> | Date | string
  }

  export type UserCreateWithoutLightWorkTasksInput = {
    id?: string
    supabaseId: string
    email: string
    displayName?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    deepWorkTasks?: DeepWorkTaskCreateNestedManyWithoutUserInput
    personalContext?: PersonalContextCreateNestedManyWithoutUserInput
    automationTasks?: AutomationTaskCreateNestedManyWithoutUserInput
    dailyHabits?: DailyHabitsCreateNestedManyWithoutUserInput
    dailyHealth?: DailyHealthCreateNestedManyWithoutUserInput
    dailyWorkout?: DailyWorkoutCreateNestedManyWithoutUserInput
    dailyRoutine?: DailyRoutineCreateNestedManyWithoutUserInput
    dailyReflections?: DailyReflectionsCreateNestedManyWithoutUserInput
    timeBlocks?: TimeBlockCreateNestedManyWithoutUserInput
    userProgress?: UserProgressCreateNestedManyWithoutUserInput
    xpBalance?: XPBalanceCreateNestedManyWithoutUserInput
    xpPurchases?: XPPurchaseCreateNestedManyWithoutUserInput
    xpEarningLog?: XPEarningLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLightWorkTasksInput = {
    id?: string
    supabaseId: string
    email: string
    displayName?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    deepWorkTasks?: DeepWorkTaskUncheckedCreateNestedManyWithoutUserInput
    personalContext?: PersonalContextUncheckedCreateNestedManyWithoutUserInput
    automationTasks?: AutomationTaskUncheckedCreateNestedManyWithoutUserInput
    dailyHabits?: DailyHabitsUncheckedCreateNestedManyWithoutUserInput
    dailyHealth?: DailyHealthUncheckedCreateNestedManyWithoutUserInput
    dailyWorkout?: DailyWorkoutUncheckedCreateNestedManyWithoutUserInput
    dailyRoutine?: DailyRoutineUncheckedCreateNestedManyWithoutUserInput
    dailyReflections?: DailyReflectionsUncheckedCreateNestedManyWithoutUserInput
    timeBlocks?: TimeBlockUncheckedCreateNestedManyWithoutUserInput
    userProgress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    xpBalance?: XPBalanceUncheckedCreateNestedManyWithoutUserInput
    xpPurchases?: XPPurchaseUncheckedCreateNestedManyWithoutUserInput
    xpEarningLog?: XPEarningLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLightWorkTasksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLightWorkTasksInput, UserUncheckedCreateWithoutLightWorkTasksInput>
  }

  export type LightWorkSubtaskCreateWithoutTaskInput = {
    id?: string
    title: string
    text: string
    completed?: boolean
    priority?: string | null
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    startedAt?: Date | string | null
    actualDurationMin?: number | null
    timeAccuracy?: number | null
    aiAnalyzed?: boolean
    aiReasoning?: string | null
    analyzedAt?: Date | string | null
    xpReward?: number | null
    complexity?: number | null
    confidence?: number | null
    contextualBonus?: number | null
    difficulty?: number | null
    learningValue?: number | null
    priorityRank?: number | null
    strategicImportance?: number | null
  }

  export type LightWorkSubtaskUncheckedCreateWithoutTaskInput = {
    id?: string
    title: string
    text: string
    completed?: boolean
    priority?: string | null
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    startedAt?: Date | string | null
    actualDurationMin?: number | null
    timeAccuracy?: number | null
    aiAnalyzed?: boolean
    aiReasoning?: string | null
    analyzedAt?: Date | string | null
    xpReward?: number | null
    complexity?: number | null
    confidence?: number | null
    contextualBonus?: number | null
    difficulty?: number | null
    learningValue?: number | null
    priorityRank?: number | null
    strategicImportance?: number | null
  }

  export type LightWorkSubtaskCreateOrConnectWithoutTaskInput = {
    where: LightWorkSubtaskWhereUniqueInput
    create: XOR<LightWorkSubtaskCreateWithoutTaskInput, LightWorkSubtaskUncheckedCreateWithoutTaskInput>
  }

  export type LightWorkSubtaskCreateManyTaskInputEnvelope = {
    data: LightWorkSubtaskCreateManyTaskInput | LightWorkSubtaskCreateManyTaskInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutLightWorkTasksInput = {
    update: XOR<UserUpdateWithoutLightWorkTasksInput, UserUncheckedUpdateWithoutLightWorkTasksInput>
    create: XOR<UserCreateWithoutLightWorkTasksInput, UserUncheckedCreateWithoutLightWorkTasksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLightWorkTasksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLightWorkTasksInput, UserUncheckedUpdateWithoutLightWorkTasksInput>
  }

  export type UserUpdateWithoutLightWorkTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deepWorkTasks?: DeepWorkTaskUpdateManyWithoutUserNestedInput
    personalContext?: PersonalContextUpdateManyWithoutUserNestedInput
    automationTasks?: AutomationTaskUpdateManyWithoutUserNestedInput
    dailyHabits?: DailyHabitsUpdateManyWithoutUserNestedInput
    dailyHealth?: DailyHealthUpdateManyWithoutUserNestedInput
    dailyWorkout?: DailyWorkoutUpdateManyWithoutUserNestedInput
    dailyRoutine?: DailyRoutineUpdateManyWithoutUserNestedInput
    dailyReflections?: DailyReflectionsUpdateManyWithoutUserNestedInput
    timeBlocks?: TimeBlockUpdateManyWithoutUserNestedInput
    userProgress?: UserProgressUpdateManyWithoutUserNestedInput
    xpBalance?: XPBalanceUpdateManyWithoutUserNestedInput
    xpPurchases?: XPPurchaseUpdateManyWithoutUserNestedInput
    xpEarningLog?: XPEarningLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLightWorkTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deepWorkTasks?: DeepWorkTaskUncheckedUpdateManyWithoutUserNestedInput
    personalContext?: PersonalContextUncheckedUpdateManyWithoutUserNestedInput
    automationTasks?: AutomationTaskUncheckedUpdateManyWithoutUserNestedInput
    dailyHabits?: DailyHabitsUncheckedUpdateManyWithoutUserNestedInput
    dailyHealth?: DailyHealthUncheckedUpdateManyWithoutUserNestedInput
    dailyWorkout?: DailyWorkoutUncheckedUpdateManyWithoutUserNestedInput
    dailyRoutine?: DailyRoutineUncheckedUpdateManyWithoutUserNestedInput
    dailyReflections?: DailyReflectionsUncheckedUpdateManyWithoutUserNestedInput
    timeBlocks?: TimeBlockUncheckedUpdateManyWithoutUserNestedInput
    userProgress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    xpBalance?: XPBalanceUncheckedUpdateManyWithoutUserNestedInput
    xpPurchases?: XPPurchaseUncheckedUpdateManyWithoutUserNestedInput
    xpEarningLog?: XPEarningLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type LightWorkSubtaskUpsertWithWhereUniqueWithoutTaskInput = {
    where: LightWorkSubtaskWhereUniqueInput
    update: XOR<LightWorkSubtaskUpdateWithoutTaskInput, LightWorkSubtaskUncheckedUpdateWithoutTaskInput>
    create: XOR<LightWorkSubtaskCreateWithoutTaskInput, LightWorkSubtaskUncheckedCreateWithoutTaskInput>
  }

  export type LightWorkSubtaskUpdateWithWhereUniqueWithoutTaskInput = {
    where: LightWorkSubtaskWhereUniqueInput
    data: XOR<LightWorkSubtaskUpdateWithoutTaskInput, LightWorkSubtaskUncheckedUpdateWithoutTaskInput>
  }

  export type LightWorkSubtaskUpdateManyWithWhereWithoutTaskInput = {
    where: LightWorkSubtaskScalarWhereInput
    data: XOR<LightWorkSubtaskUpdateManyMutationInput, LightWorkSubtaskUncheckedUpdateManyWithoutTaskInput>
  }

  export type LightWorkSubtaskScalarWhereInput = {
    AND?: LightWorkSubtaskScalarWhereInput | LightWorkSubtaskScalarWhereInput[]
    OR?: LightWorkSubtaskScalarWhereInput[]
    NOT?: LightWorkSubtaskScalarWhereInput | LightWorkSubtaskScalarWhereInput[]
    id?: StringFilter<"LightWorkSubtask"> | string
    taskId?: StringFilter<"LightWorkSubtask"> | string
    title?: StringFilter<"LightWorkSubtask"> | string
    text?: StringFilter<"LightWorkSubtask"> | string
    completed?: BoolFilter<"LightWorkSubtask"> | boolean
    priority?: StringNullableFilter<"LightWorkSubtask"> | string | null
    dueDate?: DateTimeNullableFilter<"LightWorkSubtask"> | Date | string | null
    createdAt?: DateTimeFilter<"LightWorkSubtask"> | Date | string
    updatedAt?: DateTimeFilter<"LightWorkSubtask"> | Date | string
    completedAt?: DateTimeNullableFilter<"LightWorkSubtask"> | Date | string | null
    startedAt?: DateTimeNullableFilter<"LightWorkSubtask"> | Date | string | null
    actualDurationMin?: IntNullableFilter<"LightWorkSubtask"> | number | null
    timeAccuracy?: FloatNullableFilter<"LightWorkSubtask"> | number | null
    aiAnalyzed?: BoolFilter<"LightWorkSubtask"> | boolean
    aiReasoning?: StringNullableFilter<"LightWorkSubtask"> | string | null
    analyzedAt?: DateTimeNullableFilter<"LightWorkSubtask"> | Date | string | null
    xpReward?: IntNullableFilter<"LightWorkSubtask"> | number | null
    complexity?: IntNullableFilter<"LightWorkSubtask"> | number | null
    confidence?: FloatNullableFilter<"LightWorkSubtask"> | number | null
    contextualBonus?: FloatNullableFilter<"LightWorkSubtask"> | number | null
    difficulty?: IntNullableFilter<"LightWorkSubtask"> | number | null
    learningValue?: IntNullableFilter<"LightWorkSubtask"> | number | null
    priorityRank?: IntNullableFilter<"LightWorkSubtask"> | number | null
    strategicImportance?: IntNullableFilter<"LightWorkSubtask"> | number | null
  }

  export type LightWorkTaskCreateWithoutSubtasksInput = {
    id?: string
    title: string
    description?: string | null
    priority?: $Enums.Priority
    completed?: boolean
    originalDate: string
    currentDate: string
    estimatedDuration?: number | null
    rollovers?: number
    tags?: LightWorkTaskCreatetagsInput | string[]
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    startedAt?: Date | string | null
    actualDurationMin?: number | null
    timeEstimate?: string | null
    aiAnalyzed?: boolean
    aiReasoning?: string | null
    analyzedAt?: Date | string | null
    xpReward?: number | null
    complexity?: number | null
    confidence?: number | null
    contextualBonus?: number | null
    difficulty?: number | null
    learningValue?: number | null
    priorityRank?: number | null
    strategicImportance?: number | null
    timeAccuracy?: number | null
    user: UserCreateNestedOneWithoutLightWorkTasksInput
  }

  export type LightWorkTaskUncheckedCreateWithoutSubtasksInput = {
    id?: string
    userId: string
    title: string
    description?: string | null
    priority?: $Enums.Priority
    completed?: boolean
    originalDate: string
    currentDate: string
    estimatedDuration?: number | null
    rollovers?: number
    tags?: LightWorkTaskCreatetagsInput | string[]
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    startedAt?: Date | string | null
    actualDurationMin?: number | null
    timeEstimate?: string | null
    aiAnalyzed?: boolean
    aiReasoning?: string | null
    analyzedAt?: Date | string | null
    xpReward?: number | null
    complexity?: number | null
    confidence?: number | null
    contextualBonus?: number | null
    difficulty?: number | null
    learningValue?: number | null
    priorityRank?: number | null
    strategicImportance?: number | null
    timeAccuracy?: number | null
  }

  export type LightWorkTaskCreateOrConnectWithoutSubtasksInput = {
    where: LightWorkTaskWhereUniqueInput
    create: XOR<LightWorkTaskCreateWithoutSubtasksInput, LightWorkTaskUncheckedCreateWithoutSubtasksInput>
  }

  export type LightWorkTaskUpsertWithoutSubtasksInput = {
    update: XOR<LightWorkTaskUpdateWithoutSubtasksInput, LightWorkTaskUncheckedUpdateWithoutSubtasksInput>
    create: XOR<LightWorkTaskCreateWithoutSubtasksInput, LightWorkTaskUncheckedCreateWithoutSubtasksInput>
    where?: LightWorkTaskWhereInput
  }

  export type LightWorkTaskUpdateToOneWithWhereWithoutSubtasksInput = {
    where?: LightWorkTaskWhereInput
    data: XOR<LightWorkTaskUpdateWithoutSubtasksInput, LightWorkTaskUncheckedUpdateWithoutSubtasksInput>
  }

  export type LightWorkTaskUpdateWithoutSubtasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    completed?: BoolFieldUpdateOperationsInput | boolean
    originalDate?: StringFieldUpdateOperationsInput | string
    currentDate?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    rollovers?: IntFieldUpdateOperationsInput | number
    tags?: LightWorkTaskUpdatetagsInput | string[]
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDurationMin?: NullableIntFieldUpdateOperationsInput | number | null
    timeEstimate?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalyzed?: BoolFieldUpdateOperationsInput | boolean
    aiReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    analyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    xpReward?: NullableIntFieldUpdateOperationsInput | number | null
    complexity?: NullableIntFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    contextualBonus?: NullableFloatFieldUpdateOperationsInput | number | null
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    learningValue?: NullableIntFieldUpdateOperationsInput | number | null
    priorityRank?: NullableIntFieldUpdateOperationsInput | number | null
    strategicImportance?: NullableIntFieldUpdateOperationsInput | number | null
    timeAccuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    user?: UserUpdateOneRequiredWithoutLightWorkTasksNestedInput
  }

  export type LightWorkTaskUncheckedUpdateWithoutSubtasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    completed?: BoolFieldUpdateOperationsInput | boolean
    originalDate?: StringFieldUpdateOperationsInput | string
    currentDate?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    rollovers?: IntFieldUpdateOperationsInput | number
    tags?: LightWorkTaskUpdatetagsInput | string[]
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDurationMin?: NullableIntFieldUpdateOperationsInput | number | null
    timeEstimate?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalyzed?: BoolFieldUpdateOperationsInput | boolean
    aiReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    analyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    xpReward?: NullableIntFieldUpdateOperationsInput | number | null
    complexity?: NullableIntFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    contextualBonus?: NullableFloatFieldUpdateOperationsInput | number | null
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    learningValue?: NullableIntFieldUpdateOperationsInput | number | null
    priorityRank?: NullableIntFieldUpdateOperationsInput | number | null
    strategicImportance?: NullableIntFieldUpdateOperationsInput | number | null
    timeAccuracy?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type UserCreateWithoutDeepWorkTasksInput = {
    id?: string
    supabaseId: string
    email: string
    displayName?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    lightWorkTasks?: LightWorkTaskCreateNestedManyWithoutUserInput
    personalContext?: PersonalContextCreateNestedManyWithoutUserInput
    automationTasks?: AutomationTaskCreateNestedManyWithoutUserInput
    dailyHabits?: DailyHabitsCreateNestedManyWithoutUserInput
    dailyHealth?: DailyHealthCreateNestedManyWithoutUserInput
    dailyWorkout?: DailyWorkoutCreateNestedManyWithoutUserInput
    dailyRoutine?: DailyRoutineCreateNestedManyWithoutUserInput
    dailyReflections?: DailyReflectionsCreateNestedManyWithoutUserInput
    timeBlocks?: TimeBlockCreateNestedManyWithoutUserInput
    userProgress?: UserProgressCreateNestedManyWithoutUserInput
    xpBalance?: XPBalanceCreateNestedManyWithoutUserInput
    xpPurchases?: XPPurchaseCreateNestedManyWithoutUserInput
    xpEarningLog?: XPEarningLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDeepWorkTasksInput = {
    id?: string
    supabaseId: string
    email: string
    displayName?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    lightWorkTasks?: LightWorkTaskUncheckedCreateNestedManyWithoutUserInput
    personalContext?: PersonalContextUncheckedCreateNestedManyWithoutUserInput
    automationTasks?: AutomationTaskUncheckedCreateNestedManyWithoutUserInput
    dailyHabits?: DailyHabitsUncheckedCreateNestedManyWithoutUserInput
    dailyHealth?: DailyHealthUncheckedCreateNestedManyWithoutUserInput
    dailyWorkout?: DailyWorkoutUncheckedCreateNestedManyWithoutUserInput
    dailyRoutine?: DailyRoutineUncheckedCreateNestedManyWithoutUserInput
    dailyReflections?: DailyReflectionsUncheckedCreateNestedManyWithoutUserInput
    timeBlocks?: TimeBlockUncheckedCreateNestedManyWithoutUserInput
    userProgress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    xpBalance?: XPBalanceUncheckedCreateNestedManyWithoutUserInput
    xpPurchases?: XPPurchaseUncheckedCreateNestedManyWithoutUserInput
    xpEarningLog?: XPEarningLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDeepWorkTasksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDeepWorkTasksInput, UserUncheckedCreateWithoutDeepWorkTasksInput>
  }

  export type DeepWorkSubtaskCreateWithoutTaskInput = {
    id?: string
    title: string
    text: string
    completed?: boolean
    priority?: string | null
    dueDate?: Date | string | null
    requiresFocus?: boolean
    complexityLevel?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    startedAt?: Date | string | null
    actualDurationMin?: number | null
    timeAccuracy?: number | null
    aiAnalyzed?: boolean
    aiReasoning?: string | null
    analyzedAt?: Date | string | null
    xpReward?: number | null
    complexity?: number | null
    confidence?: number | null
    contextualBonus?: number | null
    difficulty?: number | null
    learningValue?: number | null
    priorityRank?: number | null
    strategicImportance?: number | null
  }

  export type DeepWorkSubtaskUncheckedCreateWithoutTaskInput = {
    id?: string
    title: string
    text: string
    completed?: boolean
    priority?: string | null
    dueDate?: Date | string | null
    requiresFocus?: boolean
    complexityLevel?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    startedAt?: Date | string | null
    actualDurationMin?: number | null
    timeAccuracy?: number | null
    aiAnalyzed?: boolean
    aiReasoning?: string | null
    analyzedAt?: Date | string | null
    xpReward?: number | null
    complexity?: number | null
    confidence?: number | null
    contextualBonus?: number | null
    difficulty?: number | null
    learningValue?: number | null
    priorityRank?: number | null
    strategicImportance?: number | null
  }

  export type DeepWorkSubtaskCreateOrConnectWithoutTaskInput = {
    where: DeepWorkSubtaskWhereUniqueInput
    create: XOR<DeepWorkSubtaskCreateWithoutTaskInput, DeepWorkSubtaskUncheckedCreateWithoutTaskInput>
  }

  export type DeepWorkSubtaskCreateManyTaskInputEnvelope = {
    data: DeepWorkSubtaskCreateManyTaskInput | DeepWorkSubtaskCreateManyTaskInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutDeepWorkTasksInput = {
    update: XOR<UserUpdateWithoutDeepWorkTasksInput, UserUncheckedUpdateWithoutDeepWorkTasksInput>
    create: XOR<UserCreateWithoutDeepWorkTasksInput, UserUncheckedCreateWithoutDeepWorkTasksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDeepWorkTasksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDeepWorkTasksInput, UserUncheckedUpdateWithoutDeepWorkTasksInput>
  }

  export type UserUpdateWithoutDeepWorkTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lightWorkTasks?: LightWorkTaskUpdateManyWithoutUserNestedInput
    personalContext?: PersonalContextUpdateManyWithoutUserNestedInput
    automationTasks?: AutomationTaskUpdateManyWithoutUserNestedInput
    dailyHabits?: DailyHabitsUpdateManyWithoutUserNestedInput
    dailyHealth?: DailyHealthUpdateManyWithoutUserNestedInput
    dailyWorkout?: DailyWorkoutUpdateManyWithoutUserNestedInput
    dailyRoutine?: DailyRoutineUpdateManyWithoutUserNestedInput
    dailyReflections?: DailyReflectionsUpdateManyWithoutUserNestedInput
    timeBlocks?: TimeBlockUpdateManyWithoutUserNestedInput
    userProgress?: UserProgressUpdateManyWithoutUserNestedInput
    xpBalance?: XPBalanceUpdateManyWithoutUserNestedInput
    xpPurchases?: XPPurchaseUpdateManyWithoutUserNestedInput
    xpEarningLog?: XPEarningLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDeepWorkTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lightWorkTasks?: LightWorkTaskUncheckedUpdateManyWithoutUserNestedInput
    personalContext?: PersonalContextUncheckedUpdateManyWithoutUserNestedInput
    automationTasks?: AutomationTaskUncheckedUpdateManyWithoutUserNestedInput
    dailyHabits?: DailyHabitsUncheckedUpdateManyWithoutUserNestedInput
    dailyHealth?: DailyHealthUncheckedUpdateManyWithoutUserNestedInput
    dailyWorkout?: DailyWorkoutUncheckedUpdateManyWithoutUserNestedInput
    dailyRoutine?: DailyRoutineUncheckedUpdateManyWithoutUserNestedInput
    dailyReflections?: DailyReflectionsUncheckedUpdateManyWithoutUserNestedInput
    timeBlocks?: TimeBlockUncheckedUpdateManyWithoutUserNestedInput
    userProgress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    xpBalance?: XPBalanceUncheckedUpdateManyWithoutUserNestedInput
    xpPurchases?: XPPurchaseUncheckedUpdateManyWithoutUserNestedInput
    xpEarningLog?: XPEarningLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DeepWorkSubtaskUpsertWithWhereUniqueWithoutTaskInput = {
    where: DeepWorkSubtaskWhereUniqueInput
    update: XOR<DeepWorkSubtaskUpdateWithoutTaskInput, DeepWorkSubtaskUncheckedUpdateWithoutTaskInput>
    create: XOR<DeepWorkSubtaskCreateWithoutTaskInput, DeepWorkSubtaskUncheckedCreateWithoutTaskInput>
  }

  export type DeepWorkSubtaskUpdateWithWhereUniqueWithoutTaskInput = {
    where: DeepWorkSubtaskWhereUniqueInput
    data: XOR<DeepWorkSubtaskUpdateWithoutTaskInput, DeepWorkSubtaskUncheckedUpdateWithoutTaskInput>
  }

  export type DeepWorkSubtaskUpdateManyWithWhereWithoutTaskInput = {
    where: DeepWorkSubtaskScalarWhereInput
    data: XOR<DeepWorkSubtaskUpdateManyMutationInput, DeepWorkSubtaskUncheckedUpdateManyWithoutTaskInput>
  }

  export type DeepWorkSubtaskScalarWhereInput = {
    AND?: DeepWorkSubtaskScalarWhereInput | DeepWorkSubtaskScalarWhereInput[]
    OR?: DeepWorkSubtaskScalarWhereInput[]
    NOT?: DeepWorkSubtaskScalarWhereInput | DeepWorkSubtaskScalarWhereInput[]
    id?: StringFilter<"DeepWorkSubtask"> | string
    taskId?: StringFilter<"DeepWorkSubtask"> | string
    title?: StringFilter<"DeepWorkSubtask"> | string
    text?: StringFilter<"DeepWorkSubtask"> | string
    completed?: BoolFilter<"DeepWorkSubtask"> | boolean
    priority?: StringNullableFilter<"DeepWorkSubtask"> | string | null
    dueDate?: DateTimeNullableFilter<"DeepWorkSubtask"> | Date | string | null
    requiresFocus?: BoolFilter<"DeepWorkSubtask"> | boolean
    complexityLevel?: IntNullableFilter<"DeepWorkSubtask"> | number | null
    createdAt?: DateTimeFilter<"DeepWorkSubtask"> | Date | string
    updatedAt?: DateTimeFilter<"DeepWorkSubtask"> | Date | string
    completedAt?: DateTimeNullableFilter<"DeepWorkSubtask"> | Date | string | null
    startedAt?: DateTimeNullableFilter<"DeepWorkSubtask"> | Date | string | null
    actualDurationMin?: IntNullableFilter<"DeepWorkSubtask"> | number | null
    timeAccuracy?: FloatNullableFilter<"DeepWorkSubtask"> | number | null
    aiAnalyzed?: BoolFilter<"DeepWorkSubtask"> | boolean
    aiReasoning?: StringNullableFilter<"DeepWorkSubtask"> | string | null
    analyzedAt?: DateTimeNullableFilter<"DeepWorkSubtask"> | Date | string | null
    xpReward?: IntNullableFilter<"DeepWorkSubtask"> | number | null
    complexity?: IntNullableFilter<"DeepWorkSubtask"> | number | null
    confidence?: FloatNullableFilter<"DeepWorkSubtask"> | number | null
    contextualBonus?: FloatNullableFilter<"DeepWorkSubtask"> | number | null
    difficulty?: IntNullableFilter<"DeepWorkSubtask"> | number | null
    learningValue?: IntNullableFilter<"DeepWorkSubtask"> | number | null
    priorityRank?: IntNullableFilter<"DeepWorkSubtask"> | number | null
    strategicImportance?: IntNullableFilter<"DeepWorkSubtask"> | number | null
  }

  export type DeepWorkTaskCreateWithoutSubtasksInput = {
    id?: string
    title: string
    description?: string | null
    priority?: $Enums.Priority
    completed?: boolean
    originalDate: string
    currentDate: string
    estimatedDuration?: number | null
    focusBlocks?: number
    breakDuration?: number
    interruptionMode?: boolean
    rollovers?: number
    tags?: DeepWorkTaskCreatetagsInput | string[]
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    startedAt?: Date | string | null
    actualDurationMin?: number | null
    timeEstimate?: string | null
    aiAnalyzed?: boolean
    aiReasoning?: string | null
    analyzedAt?: Date | string | null
    xpReward?: number | null
    complexity?: number | null
    confidence?: number | null
    contextualBonus?: number | null
    difficulty?: number | null
    learningValue?: number | null
    priorityRank?: number | null
    strategicImportance?: number | null
    timeAccuracy?: number | null
    user: UserCreateNestedOneWithoutDeepWorkTasksInput
  }

  export type DeepWorkTaskUncheckedCreateWithoutSubtasksInput = {
    id?: string
    userId: string
    title: string
    description?: string | null
    priority?: $Enums.Priority
    completed?: boolean
    originalDate: string
    currentDate: string
    estimatedDuration?: number | null
    focusBlocks?: number
    breakDuration?: number
    interruptionMode?: boolean
    rollovers?: number
    tags?: DeepWorkTaskCreatetagsInput | string[]
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    startedAt?: Date | string | null
    actualDurationMin?: number | null
    timeEstimate?: string | null
    aiAnalyzed?: boolean
    aiReasoning?: string | null
    analyzedAt?: Date | string | null
    xpReward?: number | null
    complexity?: number | null
    confidence?: number | null
    contextualBonus?: number | null
    difficulty?: number | null
    learningValue?: number | null
    priorityRank?: number | null
    strategicImportance?: number | null
    timeAccuracy?: number | null
  }

  export type DeepWorkTaskCreateOrConnectWithoutSubtasksInput = {
    where: DeepWorkTaskWhereUniqueInput
    create: XOR<DeepWorkTaskCreateWithoutSubtasksInput, DeepWorkTaskUncheckedCreateWithoutSubtasksInput>
  }

  export type DeepWorkTaskUpsertWithoutSubtasksInput = {
    update: XOR<DeepWorkTaskUpdateWithoutSubtasksInput, DeepWorkTaskUncheckedUpdateWithoutSubtasksInput>
    create: XOR<DeepWorkTaskCreateWithoutSubtasksInput, DeepWorkTaskUncheckedCreateWithoutSubtasksInput>
    where?: DeepWorkTaskWhereInput
  }

  export type DeepWorkTaskUpdateToOneWithWhereWithoutSubtasksInput = {
    where?: DeepWorkTaskWhereInput
    data: XOR<DeepWorkTaskUpdateWithoutSubtasksInput, DeepWorkTaskUncheckedUpdateWithoutSubtasksInput>
  }

  export type DeepWorkTaskUpdateWithoutSubtasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    completed?: BoolFieldUpdateOperationsInput | boolean
    originalDate?: StringFieldUpdateOperationsInput | string
    currentDate?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    focusBlocks?: IntFieldUpdateOperationsInput | number
    breakDuration?: IntFieldUpdateOperationsInput | number
    interruptionMode?: BoolFieldUpdateOperationsInput | boolean
    rollovers?: IntFieldUpdateOperationsInput | number
    tags?: DeepWorkTaskUpdatetagsInput | string[]
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDurationMin?: NullableIntFieldUpdateOperationsInput | number | null
    timeEstimate?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalyzed?: BoolFieldUpdateOperationsInput | boolean
    aiReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    analyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    xpReward?: NullableIntFieldUpdateOperationsInput | number | null
    complexity?: NullableIntFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    contextualBonus?: NullableFloatFieldUpdateOperationsInput | number | null
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    learningValue?: NullableIntFieldUpdateOperationsInput | number | null
    priorityRank?: NullableIntFieldUpdateOperationsInput | number | null
    strategicImportance?: NullableIntFieldUpdateOperationsInput | number | null
    timeAccuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    user?: UserUpdateOneRequiredWithoutDeepWorkTasksNestedInput
  }

  export type DeepWorkTaskUncheckedUpdateWithoutSubtasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    completed?: BoolFieldUpdateOperationsInput | boolean
    originalDate?: StringFieldUpdateOperationsInput | string
    currentDate?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    focusBlocks?: IntFieldUpdateOperationsInput | number
    breakDuration?: IntFieldUpdateOperationsInput | number
    interruptionMode?: BoolFieldUpdateOperationsInput | boolean
    rollovers?: IntFieldUpdateOperationsInput | number
    tags?: DeepWorkTaskUpdatetagsInput | string[]
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDurationMin?: NullableIntFieldUpdateOperationsInput | number | null
    timeEstimate?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalyzed?: BoolFieldUpdateOperationsInput | boolean
    aiReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    analyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    xpReward?: NullableIntFieldUpdateOperationsInput | number | null
    complexity?: NullableIntFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    contextualBonus?: NullableFloatFieldUpdateOperationsInput | number | null
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    learningValue?: NullableIntFieldUpdateOperationsInput | number | null
    priorityRank?: NullableIntFieldUpdateOperationsInput | number | null
    strategicImportance?: NullableIntFieldUpdateOperationsInput | number | null
    timeAccuracy?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type UserCreateWithoutAutomationTasksInput = {
    id?: string
    supabaseId: string
    email: string
    displayName?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    lightWorkTasks?: LightWorkTaskCreateNestedManyWithoutUserInput
    deepWorkTasks?: DeepWorkTaskCreateNestedManyWithoutUserInput
    personalContext?: PersonalContextCreateNestedManyWithoutUserInput
    dailyHabits?: DailyHabitsCreateNestedManyWithoutUserInput
    dailyHealth?: DailyHealthCreateNestedManyWithoutUserInput
    dailyWorkout?: DailyWorkoutCreateNestedManyWithoutUserInput
    dailyRoutine?: DailyRoutineCreateNestedManyWithoutUserInput
    dailyReflections?: DailyReflectionsCreateNestedManyWithoutUserInput
    timeBlocks?: TimeBlockCreateNestedManyWithoutUserInput
    userProgress?: UserProgressCreateNestedManyWithoutUserInput
    xpBalance?: XPBalanceCreateNestedManyWithoutUserInput
    xpPurchases?: XPPurchaseCreateNestedManyWithoutUserInput
    xpEarningLog?: XPEarningLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAutomationTasksInput = {
    id?: string
    supabaseId: string
    email: string
    displayName?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    lightWorkTasks?: LightWorkTaskUncheckedCreateNestedManyWithoutUserInput
    deepWorkTasks?: DeepWorkTaskUncheckedCreateNestedManyWithoutUserInput
    personalContext?: PersonalContextUncheckedCreateNestedManyWithoutUserInput
    dailyHabits?: DailyHabitsUncheckedCreateNestedManyWithoutUserInput
    dailyHealth?: DailyHealthUncheckedCreateNestedManyWithoutUserInput
    dailyWorkout?: DailyWorkoutUncheckedCreateNestedManyWithoutUserInput
    dailyRoutine?: DailyRoutineUncheckedCreateNestedManyWithoutUserInput
    dailyReflections?: DailyReflectionsUncheckedCreateNestedManyWithoutUserInput
    timeBlocks?: TimeBlockUncheckedCreateNestedManyWithoutUserInput
    userProgress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    xpBalance?: XPBalanceUncheckedCreateNestedManyWithoutUserInput
    xpPurchases?: XPPurchaseUncheckedCreateNestedManyWithoutUserInput
    xpEarningLog?: XPEarningLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAutomationTasksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAutomationTasksInput, UserUncheckedCreateWithoutAutomationTasksInput>
  }

  export type UserUpsertWithoutAutomationTasksInput = {
    update: XOR<UserUpdateWithoutAutomationTasksInput, UserUncheckedUpdateWithoutAutomationTasksInput>
    create: XOR<UserCreateWithoutAutomationTasksInput, UserUncheckedCreateWithoutAutomationTasksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAutomationTasksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAutomationTasksInput, UserUncheckedUpdateWithoutAutomationTasksInput>
  }

  export type UserUpdateWithoutAutomationTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lightWorkTasks?: LightWorkTaskUpdateManyWithoutUserNestedInput
    deepWorkTasks?: DeepWorkTaskUpdateManyWithoutUserNestedInput
    personalContext?: PersonalContextUpdateManyWithoutUserNestedInput
    dailyHabits?: DailyHabitsUpdateManyWithoutUserNestedInput
    dailyHealth?: DailyHealthUpdateManyWithoutUserNestedInput
    dailyWorkout?: DailyWorkoutUpdateManyWithoutUserNestedInput
    dailyRoutine?: DailyRoutineUpdateManyWithoutUserNestedInput
    dailyReflections?: DailyReflectionsUpdateManyWithoutUserNestedInput
    timeBlocks?: TimeBlockUpdateManyWithoutUserNestedInput
    userProgress?: UserProgressUpdateManyWithoutUserNestedInput
    xpBalance?: XPBalanceUpdateManyWithoutUserNestedInput
    xpPurchases?: XPPurchaseUpdateManyWithoutUserNestedInput
    xpEarningLog?: XPEarningLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAutomationTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lightWorkTasks?: LightWorkTaskUncheckedUpdateManyWithoutUserNestedInput
    deepWorkTasks?: DeepWorkTaskUncheckedUpdateManyWithoutUserNestedInput
    personalContext?: PersonalContextUncheckedUpdateManyWithoutUserNestedInput
    dailyHabits?: DailyHabitsUncheckedUpdateManyWithoutUserNestedInput
    dailyHealth?: DailyHealthUncheckedUpdateManyWithoutUserNestedInput
    dailyWorkout?: DailyWorkoutUncheckedUpdateManyWithoutUserNestedInput
    dailyRoutine?: DailyRoutineUncheckedUpdateManyWithoutUserNestedInput
    dailyReflections?: DailyReflectionsUncheckedUpdateManyWithoutUserNestedInput
    timeBlocks?: TimeBlockUncheckedUpdateManyWithoutUserNestedInput
    userProgress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    xpBalance?: XPBalanceUncheckedUpdateManyWithoutUserNestedInput
    xpPurchases?: XPPurchaseUncheckedUpdateManyWithoutUserNestedInput
    xpEarningLog?: XPEarningLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutDailyHabitsInput = {
    id?: string
    supabaseId: string
    email: string
    displayName?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    lightWorkTasks?: LightWorkTaskCreateNestedManyWithoutUserInput
    deepWorkTasks?: DeepWorkTaskCreateNestedManyWithoutUserInput
    personalContext?: PersonalContextCreateNestedManyWithoutUserInput
    automationTasks?: AutomationTaskCreateNestedManyWithoutUserInput
    dailyHealth?: DailyHealthCreateNestedManyWithoutUserInput
    dailyWorkout?: DailyWorkoutCreateNestedManyWithoutUserInput
    dailyRoutine?: DailyRoutineCreateNestedManyWithoutUserInput
    dailyReflections?: DailyReflectionsCreateNestedManyWithoutUserInput
    timeBlocks?: TimeBlockCreateNestedManyWithoutUserInput
    userProgress?: UserProgressCreateNestedManyWithoutUserInput
    xpBalance?: XPBalanceCreateNestedManyWithoutUserInput
    xpPurchases?: XPPurchaseCreateNestedManyWithoutUserInput
    xpEarningLog?: XPEarningLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDailyHabitsInput = {
    id?: string
    supabaseId: string
    email: string
    displayName?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    lightWorkTasks?: LightWorkTaskUncheckedCreateNestedManyWithoutUserInput
    deepWorkTasks?: DeepWorkTaskUncheckedCreateNestedManyWithoutUserInput
    personalContext?: PersonalContextUncheckedCreateNestedManyWithoutUserInput
    automationTasks?: AutomationTaskUncheckedCreateNestedManyWithoutUserInput
    dailyHealth?: DailyHealthUncheckedCreateNestedManyWithoutUserInput
    dailyWorkout?: DailyWorkoutUncheckedCreateNestedManyWithoutUserInput
    dailyRoutine?: DailyRoutineUncheckedCreateNestedManyWithoutUserInput
    dailyReflections?: DailyReflectionsUncheckedCreateNestedManyWithoutUserInput
    timeBlocks?: TimeBlockUncheckedCreateNestedManyWithoutUserInput
    userProgress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    xpBalance?: XPBalanceUncheckedCreateNestedManyWithoutUserInput
    xpPurchases?: XPPurchaseUncheckedCreateNestedManyWithoutUserInput
    xpEarningLog?: XPEarningLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDailyHabitsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDailyHabitsInput, UserUncheckedCreateWithoutDailyHabitsInput>
  }

  export type UserUpsertWithoutDailyHabitsInput = {
    update: XOR<UserUpdateWithoutDailyHabitsInput, UserUncheckedUpdateWithoutDailyHabitsInput>
    create: XOR<UserCreateWithoutDailyHabitsInput, UserUncheckedCreateWithoutDailyHabitsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDailyHabitsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDailyHabitsInput, UserUncheckedUpdateWithoutDailyHabitsInput>
  }

  export type UserUpdateWithoutDailyHabitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lightWorkTasks?: LightWorkTaskUpdateManyWithoutUserNestedInput
    deepWorkTasks?: DeepWorkTaskUpdateManyWithoutUserNestedInput
    personalContext?: PersonalContextUpdateManyWithoutUserNestedInput
    automationTasks?: AutomationTaskUpdateManyWithoutUserNestedInput
    dailyHealth?: DailyHealthUpdateManyWithoutUserNestedInput
    dailyWorkout?: DailyWorkoutUpdateManyWithoutUserNestedInput
    dailyRoutine?: DailyRoutineUpdateManyWithoutUserNestedInput
    dailyReflections?: DailyReflectionsUpdateManyWithoutUserNestedInput
    timeBlocks?: TimeBlockUpdateManyWithoutUserNestedInput
    userProgress?: UserProgressUpdateManyWithoutUserNestedInput
    xpBalance?: XPBalanceUpdateManyWithoutUserNestedInput
    xpPurchases?: XPPurchaseUpdateManyWithoutUserNestedInput
    xpEarningLog?: XPEarningLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDailyHabitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lightWorkTasks?: LightWorkTaskUncheckedUpdateManyWithoutUserNestedInput
    deepWorkTasks?: DeepWorkTaskUncheckedUpdateManyWithoutUserNestedInput
    personalContext?: PersonalContextUncheckedUpdateManyWithoutUserNestedInput
    automationTasks?: AutomationTaskUncheckedUpdateManyWithoutUserNestedInput
    dailyHealth?: DailyHealthUncheckedUpdateManyWithoutUserNestedInput
    dailyWorkout?: DailyWorkoutUncheckedUpdateManyWithoutUserNestedInput
    dailyRoutine?: DailyRoutineUncheckedUpdateManyWithoutUserNestedInput
    dailyReflections?: DailyReflectionsUncheckedUpdateManyWithoutUserNestedInput
    timeBlocks?: TimeBlockUncheckedUpdateManyWithoutUserNestedInput
    userProgress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    xpBalance?: XPBalanceUncheckedUpdateManyWithoutUserNestedInput
    xpPurchases?: XPPurchaseUncheckedUpdateManyWithoutUserNestedInput
    xpEarningLog?: XPEarningLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutDailyHealthInput = {
    id?: string
    supabaseId: string
    email: string
    displayName?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    lightWorkTasks?: LightWorkTaskCreateNestedManyWithoutUserInput
    deepWorkTasks?: DeepWorkTaskCreateNestedManyWithoutUserInput
    personalContext?: PersonalContextCreateNestedManyWithoutUserInput
    automationTasks?: AutomationTaskCreateNestedManyWithoutUserInput
    dailyHabits?: DailyHabitsCreateNestedManyWithoutUserInput
    dailyWorkout?: DailyWorkoutCreateNestedManyWithoutUserInput
    dailyRoutine?: DailyRoutineCreateNestedManyWithoutUserInput
    dailyReflections?: DailyReflectionsCreateNestedManyWithoutUserInput
    timeBlocks?: TimeBlockCreateNestedManyWithoutUserInput
    userProgress?: UserProgressCreateNestedManyWithoutUserInput
    xpBalance?: XPBalanceCreateNestedManyWithoutUserInput
    xpPurchases?: XPPurchaseCreateNestedManyWithoutUserInput
    xpEarningLog?: XPEarningLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDailyHealthInput = {
    id?: string
    supabaseId: string
    email: string
    displayName?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    lightWorkTasks?: LightWorkTaskUncheckedCreateNestedManyWithoutUserInput
    deepWorkTasks?: DeepWorkTaskUncheckedCreateNestedManyWithoutUserInput
    personalContext?: PersonalContextUncheckedCreateNestedManyWithoutUserInput
    automationTasks?: AutomationTaskUncheckedCreateNestedManyWithoutUserInput
    dailyHabits?: DailyHabitsUncheckedCreateNestedManyWithoutUserInput
    dailyWorkout?: DailyWorkoutUncheckedCreateNestedManyWithoutUserInput
    dailyRoutine?: DailyRoutineUncheckedCreateNestedManyWithoutUserInput
    dailyReflections?: DailyReflectionsUncheckedCreateNestedManyWithoutUserInput
    timeBlocks?: TimeBlockUncheckedCreateNestedManyWithoutUserInput
    userProgress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    xpBalance?: XPBalanceUncheckedCreateNestedManyWithoutUserInput
    xpPurchases?: XPPurchaseUncheckedCreateNestedManyWithoutUserInput
    xpEarningLog?: XPEarningLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDailyHealthInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDailyHealthInput, UserUncheckedCreateWithoutDailyHealthInput>
  }

  export type UserUpsertWithoutDailyHealthInput = {
    update: XOR<UserUpdateWithoutDailyHealthInput, UserUncheckedUpdateWithoutDailyHealthInput>
    create: XOR<UserCreateWithoutDailyHealthInput, UserUncheckedCreateWithoutDailyHealthInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDailyHealthInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDailyHealthInput, UserUncheckedUpdateWithoutDailyHealthInput>
  }

  export type UserUpdateWithoutDailyHealthInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lightWorkTasks?: LightWorkTaskUpdateManyWithoutUserNestedInput
    deepWorkTasks?: DeepWorkTaskUpdateManyWithoutUserNestedInput
    personalContext?: PersonalContextUpdateManyWithoutUserNestedInput
    automationTasks?: AutomationTaskUpdateManyWithoutUserNestedInput
    dailyHabits?: DailyHabitsUpdateManyWithoutUserNestedInput
    dailyWorkout?: DailyWorkoutUpdateManyWithoutUserNestedInput
    dailyRoutine?: DailyRoutineUpdateManyWithoutUserNestedInput
    dailyReflections?: DailyReflectionsUpdateManyWithoutUserNestedInput
    timeBlocks?: TimeBlockUpdateManyWithoutUserNestedInput
    userProgress?: UserProgressUpdateManyWithoutUserNestedInput
    xpBalance?: XPBalanceUpdateManyWithoutUserNestedInput
    xpPurchases?: XPPurchaseUpdateManyWithoutUserNestedInput
    xpEarningLog?: XPEarningLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDailyHealthInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lightWorkTasks?: LightWorkTaskUncheckedUpdateManyWithoutUserNestedInput
    deepWorkTasks?: DeepWorkTaskUncheckedUpdateManyWithoutUserNestedInput
    personalContext?: PersonalContextUncheckedUpdateManyWithoutUserNestedInput
    automationTasks?: AutomationTaskUncheckedUpdateManyWithoutUserNestedInput
    dailyHabits?: DailyHabitsUncheckedUpdateManyWithoutUserNestedInput
    dailyWorkout?: DailyWorkoutUncheckedUpdateManyWithoutUserNestedInput
    dailyRoutine?: DailyRoutineUncheckedUpdateManyWithoutUserNestedInput
    dailyReflections?: DailyReflectionsUncheckedUpdateManyWithoutUserNestedInput
    timeBlocks?: TimeBlockUncheckedUpdateManyWithoutUserNestedInput
    userProgress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    xpBalance?: XPBalanceUncheckedUpdateManyWithoutUserNestedInput
    xpPurchases?: XPPurchaseUncheckedUpdateManyWithoutUserNestedInput
    xpEarningLog?: XPEarningLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutDailyWorkoutInput = {
    id?: string
    supabaseId: string
    email: string
    displayName?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    lightWorkTasks?: LightWorkTaskCreateNestedManyWithoutUserInput
    deepWorkTasks?: DeepWorkTaskCreateNestedManyWithoutUserInput
    personalContext?: PersonalContextCreateNestedManyWithoutUserInput
    automationTasks?: AutomationTaskCreateNestedManyWithoutUserInput
    dailyHabits?: DailyHabitsCreateNestedManyWithoutUserInput
    dailyHealth?: DailyHealthCreateNestedManyWithoutUserInput
    dailyRoutine?: DailyRoutineCreateNestedManyWithoutUserInput
    dailyReflections?: DailyReflectionsCreateNestedManyWithoutUserInput
    timeBlocks?: TimeBlockCreateNestedManyWithoutUserInput
    userProgress?: UserProgressCreateNestedManyWithoutUserInput
    xpBalance?: XPBalanceCreateNestedManyWithoutUserInput
    xpPurchases?: XPPurchaseCreateNestedManyWithoutUserInput
    xpEarningLog?: XPEarningLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDailyWorkoutInput = {
    id?: string
    supabaseId: string
    email: string
    displayName?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    lightWorkTasks?: LightWorkTaskUncheckedCreateNestedManyWithoutUserInput
    deepWorkTasks?: DeepWorkTaskUncheckedCreateNestedManyWithoutUserInput
    personalContext?: PersonalContextUncheckedCreateNestedManyWithoutUserInput
    automationTasks?: AutomationTaskUncheckedCreateNestedManyWithoutUserInput
    dailyHabits?: DailyHabitsUncheckedCreateNestedManyWithoutUserInput
    dailyHealth?: DailyHealthUncheckedCreateNestedManyWithoutUserInput
    dailyRoutine?: DailyRoutineUncheckedCreateNestedManyWithoutUserInput
    dailyReflections?: DailyReflectionsUncheckedCreateNestedManyWithoutUserInput
    timeBlocks?: TimeBlockUncheckedCreateNestedManyWithoutUserInput
    userProgress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    xpBalance?: XPBalanceUncheckedCreateNestedManyWithoutUserInput
    xpPurchases?: XPPurchaseUncheckedCreateNestedManyWithoutUserInput
    xpEarningLog?: XPEarningLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDailyWorkoutInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDailyWorkoutInput, UserUncheckedCreateWithoutDailyWorkoutInput>
  }

  export type UserUpsertWithoutDailyWorkoutInput = {
    update: XOR<UserUpdateWithoutDailyWorkoutInput, UserUncheckedUpdateWithoutDailyWorkoutInput>
    create: XOR<UserCreateWithoutDailyWorkoutInput, UserUncheckedCreateWithoutDailyWorkoutInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDailyWorkoutInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDailyWorkoutInput, UserUncheckedUpdateWithoutDailyWorkoutInput>
  }

  export type UserUpdateWithoutDailyWorkoutInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lightWorkTasks?: LightWorkTaskUpdateManyWithoutUserNestedInput
    deepWorkTasks?: DeepWorkTaskUpdateManyWithoutUserNestedInput
    personalContext?: PersonalContextUpdateManyWithoutUserNestedInput
    automationTasks?: AutomationTaskUpdateManyWithoutUserNestedInput
    dailyHabits?: DailyHabitsUpdateManyWithoutUserNestedInput
    dailyHealth?: DailyHealthUpdateManyWithoutUserNestedInput
    dailyRoutine?: DailyRoutineUpdateManyWithoutUserNestedInput
    dailyReflections?: DailyReflectionsUpdateManyWithoutUserNestedInput
    timeBlocks?: TimeBlockUpdateManyWithoutUserNestedInput
    userProgress?: UserProgressUpdateManyWithoutUserNestedInput
    xpBalance?: XPBalanceUpdateManyWithoutUserNestedInput
    xpPurchases?: XPPurchaseUpdateManyWithoutUserNestedInput
    xpEarningLog?: XPEarningLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDailyWorkoutInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lightWorkTasks?: LightWorkTaskUncheckedUpdateManyWithoutUserNestedInput
    deepWorkTasks?: DeepWorkTaskUncheckedUpdateManyWithoutUserNestedInput
    personalContext?: PersonalContextUncheckedUpdateManyWithoutUserNestedInput
    automationTasks?: AutomationTaskUncheckedUpdateManyWithoutUserNestedInput
    dailyHabits?: DailyHabitsUncheckedUpdateManyWithoutUserNestedInput
    dailyHealth?: DailyHealthUncheckedUpdateManyWithoutUserNestedInput
    dailyRoutine?: DailyRoutineUncheckedUpdateManyWithoutUserNestedInput
    dailyReflections?: DailyReflectionsUncheckedUpdateManyWithoutUserNestedInput
    timeBlocks?: TimeBlockUncheckedUpdateManyWithoutUserNestedInput
    userProgress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    xpBalance?: XPBalanceUncheckedUpdateManyWithoutUserNestedInput
    xpPurchases?: XPPurchaseUncheckedUpdateManyWithoutUserNestedInput
    xpEarningLog?: XPEarningLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutDailyRoutineInput = {
    id?: string
    supabaseId: string
    email: string
    displayName?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    lightWorkTasks?: LightWorkTaskCreateNestedManyWithoutUserInput
    deepWorkTasks?: DeepWorkTaskCreateNestedManyWithoutUserInput
    personalContext?: PersonalContextCreateNestedManyWithoutUserInput
    automationTasks?: AutomationTaskCreateNestedManyWithoutUserInput
    dailyHabits?: DailyHabitsCreateNestedManyWithoutUserInput
    dailyHealth?: DailyHealthCreateNestedManyWithoutUserInput
    dailyWorkout?: DailyWorkoutCreateNestedManyWithoutUserInput
    dailyReflections?: DailyReflectionsCreateNestedManyWithoutUserInput
    timeBlocks?: TimeBlockCreateNestedManyWithoutUserInput
    userProgress?: UserProgressCreateNestedManyWithoutUserInput
    xpBalance?: XPBalanceCreateNestedManyWithoutUserInput
    xpPurchases?: XPPurchaseCreateNestedManyWithoutUserInput
    xpEarningLog?: XPEarningLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDailyRoutineInput = {
    id?: string
    supabaseId: string
    email: string
    displayName?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    lightWorkTasks?: LightWorkTaskUncheckedCreateNestedManyWithoutUserInput
    deepWorkTasks?: DeepWorkTaskUncheckedCreateNestedManyWithoutUserInput
    personalContext?: PersonalContextUncheckedCreateNestedManyWithoutUserInput
    automationTasks?: AutomationTaskUncheckedCreateNestedManyWithoutUserInput
    dailyHabits?: DailyHabitsUncheckedCreateNestedManyWithoutUserInput
    dailyHealth?: DailyHealthUncheckedCreateNestedManyWithoutUserInput
    dailyWorkout?: DailyWorkoutUncheckedCreateNestedManyWithoutUserInput
    dailyReflections?: DailyReflectionsUncheckedCreateNestedManyWithoutUserInput
    timeBlocks?: TimeBlockUncheckedCreateNestedManyWithoutUserInput
    userProgress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    xpBalance?: XPBalanceUncheckedCreateNestedManyWithoutUserInput
    xpPurchases?: XPPurchaseUncheckedCreateNestedManyWithoutUserInput
    xpEarningLog?: XPEarningLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDailyRoutineInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDailyRoutineInput, UserUncheckedCreateWithoutDailyRoutineInput>
  }

  export type UserUpsertWithoutDailyRoutineInput = {
    update: XOR<UserUpdateWithoutDailyRoutineInput, UserUncheckedUpdateWithoutDailyRoutineInput>
    create: XOR<UserCreateWithoutDailyRoutineInput, UserUncheckedCreateWithoutDailyRoutineInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDailyRoutineInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDailyRoutineInput, UserUncheckedUpdateWithoutDailyRoutineInput>
  }

  export type UserUpdateWithoutDailyRoutineInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lightWorkTasks?: LightWorkTaskUpdateManyWithoutUserNestedInput
    deepWorkTasks?: DeepWorkTaskUpdateManyWithoutUserNestedInput
    personalContext?: PersonalContextUpdateManyWithoutUserNestedInput
    automationTasks?: AutomationTaskUpdateManyWithoutUserNestedInput
    dailyHabits?: DailyHabitsUpdateManyWithoutUserNestedInput
    dailyHealth?: DailyHealthUpdateManyWithoutUserNestedInput
    dailyWorkout?: DailyWorkoutUpdateManyWithoutUserNestedInput
    dailyReflections?: DailyReflectionsUpdateManyWithoutUserNestedInput
    timeBlocks?: TimeBlockUpdateManyWithoutUserNestedInput
    userProgress?: UserProgressUpdateManyWithoutUserNestedInput
    xpBalance?: XPBalanceUpdateManyWithoutUserNestedInput
    xpPurchases?: XPPurchaseUpdateManyWithoutUserNestedInput
    xpEarningLog?: XPEarningLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDailyRoutineInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lightWorkTasks?: LightWorkTaskUncheckedUpdateManyWithoutUserNestedInput
    deepWorkTasks?: DeepWorkTaskUncheckedUpdateManyWithoutUserNestedInput
    personalContext?: PersonalContextUncheckedUpdateManyWithoutUserNestedInput
    automationTasks?: AutomationTaskUncheckedUpdateManyWithoutUserNestedInput
    dailyHabits?: DailyHabitsUncheckedUpdateManyWithoutUserNestedInput
    dailyHealth?: DailyHealthUncheckedUpdateManyWithoutUserNestedInput
    dailyWorkout?: DailyWorkoutUncheckedUpdateManyWithoutUserNestedInput
    dailyReflections?: DailyReflectionsUncheckedUpdateManyWithoutUserNestedInput
    timeBlocks?: TimeBlockUncheckedUpdateManyWithoutUserNestedInput
    userProgress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    xpBalance?: XPBalanceUncheckedUpdateManyWithoutUserNestedInput
    xpPurchases?: XPPurchaseUncheckedUpdateManyWithoutUserNestedInput
    xpEarningLog?: XPEarningLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutDailyReflectionsInput = {
    id?: string
    supabaseId: string
    email: string
    displayName?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    lightWorkTasks?: LightWorkTaskCreateNestedManyWithoutUserInput
    deepWorkTasks?: DeepWorkTaskCreateNestedManyWithoutUserInput
    personalContext?: PersonalContextCreateNestedManyWithoutUserInput
    automationTasks?: AutomationTaskCreateNestedManyWithoutUserInput
    dailyHabits?: DailyHabitsCreateNestedManyWithoutUserInput
    dailyHealth?: DailyHealthCreateNestedManyWithoutUserInput
    dailyWorkout?: DailyWorkoutCreateNestedManyWithoutUserInput
    dailyRoutine?: DailyRoutineCreateNestedManyWithoutUserInput
    timeBlocks?: TimeBlockCreateNestedManyWithoutUserInput
    userProgress?: UserProgressCreateNestedManyWithoutUserInput
    xpBalance?: XPBalanceCreateNestedManyWithoutUserInput
    xpPurchases?: XPPurchaseCreateNestedManyWithoutUserInput
    xpEarningLog?: XPEarningLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDailyReflectionsInput = {
    id?: string
    supabaseId: string
    email: string
    displayName?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    lightWorkTasks?: LightWorkTaskUncheckedCreateNestedManyWithoutUserInput
    deepWorkTasks?: DeepWorkTaskUncheckedCreateNestedManyWithoutUserInput
    personalContext?: PersonalContextUncheckedCreateNestedManyWithoutUserInput
    automationTasks?: AutomationTaskUncheckedCreateNestedManyWithoutUserInput
    dailyHabits?: DailyHabitsUncheckedCreateNestedManyWithoutUserInput
    dailyHealth?: DailyHealthUncheckedCreateNestedManyWithoutUserInput
    dailyWorkout?: DailyWorkoutUncheckedCreateNestedManyWithoutUserInput
    dailyRoutine?: DailyRoutineUncheckedCreateNestedManyWithoutUserInput
    timeBlocks?: TimeBlockUncheckedCreateNestedManyWithoutUserInput
    userProgress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    xpBalance?: XPBalanceUncheckedCreateNestedManyWithoutUserInput
    xpPurchases?: XPPurchaseUncheckedCreateNestedManyWithoutUserInput
    xpEarningLog?: XPEarningLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDailyReflectionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDailyReflectionsInput, UserUncheckedCreateWithoutDailyReflectionsInput>
  }

  export type UserUpsertWithoutDailyReflectionsInput = {
    update: XOR<UserUpdateWithoutDailyReflectionsInput, UserUncheckedUpdateWithoutDailyReflectionsInput>
    create: XOR<UserCreateWithoutDailyReflectionsInput, UserUncheckedCreateWithoutDailyReflectionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDailyReflectionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDailyReflectionsInput, UserUncheckedUpdateWithoutDailyReflectionsInput>
  }

  export type UserUpdateWithoutDailyReflectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lightWorkTasks?: LightWorkTaskUpdateManyWithoutUserNestedInput
    deepWorkTasks?: DeepWorkTaskUpdateManyWithoutUserNestedInput
    personalContext?: PersonalContextUpdateManyWithoutUserNestedInput
    automationTasks?: AutomationTaskUpdateManyWithoutUserNestedInput
    dailyHabits?: DailyHabitsUpdateManyWithoutUserNestedInput
    dailyHealth?: DailyHealthUpdateManyWithoutUserNestedInput
    dailyWorkout?: DailyWorkoutUpdateManyWithoutUserNestedInput
    dailyRoutine?: DailyRoutineUpdateManyWithoutUserNestedInput
    timeBlocks?: TimeBlockUpdateManyWithoutUserNestedInput
    userProgress?: UserProgressUpdateManyWithoutUserNestedInput
    xpBalance?: XPBalanceUpdateManyWithoutUserNestedInput
    xpPurchases?: XPPurchaseUpdateManyWithoutUserNestedInput
    xpEarningLog?: XPEarningLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDailyReflectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lightWorkTasks?: LightWorkTaskUncheckedUpdateManyWithoutUserNestedInput
    deepWorkTasks?: DeepWorkTaskUncheckedUpdateManyWithoutUserNestedInput
    personalContext?: PersonalContextUncheckedUpdateManyWithoutUserNestedInput
    automationTasks?: AutomationTaskUncheckedUpdateManyWithoutUserNestedInput
    dailyHabits?: DailyHabitsUncheckedUpdateManyWithoutUserNestedInput
    dailyHealth?: DailyHealthUncheckedUpdateManyWithoutUserNestedInput
    dailyWorkout?: DailyWorkoutUncheckedUpdateManyWithoutUserNestedInput
    dailyRoutine?: DailyRoutineUncheckedUpdateManyWithoutUserNestedInput
    timeBlocks?: TimeBlockUncheckedUpdateManyWithoutUserNestedInput
    userProgress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    xpBalance?: XPBalanceUncheckedUpdateManyWithoutUserNestedInput
    xpPurchases?: XPPurchaseUncheckedUpdateManyWithoutUserNestedInput
    xpEarningLog?: XPEarningLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutTimeBlocksInput = {
    id?: string
    supabaseId: string
    email: string
    displayName?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    lightWorkTasks?: LightWorkTaskCreateNestedManyWithoutUserInput
    deepWorkTasks?: DeepWorkTaskCreateNestedManyWithoutUserInput
    personalContext?: PersonalContextCreateNestedManyWithoutUserInput
    automationTasks?: AutomationTaskCreateNestedManyWithoutUserInput
    dailyHabits?: DailyHabitsCreateNestedManyWithoutUserInput
    dailyHealth?: DailyHealthCreateNestedManyWithoutUserInput
    dailyWorkout?: DailyWorkoutCreateNestedManyWithoutUserInput
    dailyRoutine?: DailyRoutineCreateNestedManyWithoutUserInput
    dailyReflections?: DailyReflectionsCreateNestedManyWithoutUserInput
    userProgress?: UserProgressCreateNestedManyWithoutUserInput
    xpBalance?: XPBalanceCreateNestedManyWithoutUserInput
    xpPurchases?: XPPurchaseCreateNestedManyWithoutUserInput
    xpEarningLog?: XPEarningLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTimeBlocksInput = {
    id?: string
    supabaseId: string
    email: string
    displayName?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    lightWorkTasks?: LightWorkTaskUncheckedCreateNestedManyWithoutUserInput
    deepWorkTasks?: DeepWorkTaskUncheckedCreateNestedManyWithoutUserInput
    personalContext?: PersonalContextUncheckedCreateNestedManyWithoutUserInput
    automationTasks?: AutomationTaskUncheckedCreateNestedManyWithoutUserInput
    dailyHabits?: DailyHabitsUncheckedCreateNestedManyWithoutUserInput
    dailyHealth?: DailyHealthUncheckedCreateNestedManyWithoutUserInput
    dailyWorkout?: DailyWorkoutUncheckedCreateNestedManyWithoutUserInput
    dailyRoutine?: DailyRoutineUncheckedCreateNestedManyWithoutUserInput
    dailyReflections?: DailyReflectionsUncheckedCreateNestedManyWithoutUserInput
    userProgress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    xpBalance?: XPBalanceUncheckedCreateNestedManyWithoutUserInput
    xpPurchases?: XPPurchaseUncheckedCreateNestedManyWithoutUserInput
    xpEarningLog?: XPEarningLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTimeBlocksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTimeBlocksInput, UserUncheckedCreateWithoutTimeBlocksInput>
  }

  export type UserUpsertWithoutTimeBlocksInput = {
    update: XOR<UserUpdateWithoutTimeBlocksInput, UserUncheckedUpdateWithoutTimeBlocksInput>
    create: XOR<UserCreateWithoutTimeBlocksInput, UserUncheckedCreateWithoutTimeBlocksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTimeBlocksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTimeBlocksInput, UserUncheckedUpdateWithoutTimeBlocksInput>
  }

  export type UserUpdateWithoutTimeBlocksInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lightWorkTasks?: LightWorkTaskUpdateManyWithoutUserNestedInput
    deepWorkTasks?: DeepWorkTaskUpdateManyWithoutUserNestedInput
    personalContext?: PersonalContextUpdateManyWithoutUserNestedInput
    automationTasks?: AutomationTaskUpdateManyWithoutUserNestedInput
    dailyHabits?: DailyHabitsUpdateManyWithoutUserNestedInput
    dailyHealth?: DailyHealthUpdateManyWithoutUserNestedInput
    dailyWorkout?: DailyWorkoutUpdateManyWithoutUserNestedInput
    dailyRoutine?: DailyRoutineUpdateManyWithoutUserNestedInput
    dailyReflections?: DailyReflectionsUpdateManyWithoutUserNestedInput
    userProgress?: UserProgressUpdateManyWithoutUserNestedInput
    xpBalance?: XPBalanceUpdateManyWithoutUserNestedInput
    xpPurchases?: XPPurchaseUpdateManyWithoutUserNestedInput
    xpEarningLog?: XPEarningLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTimeBlocksInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lightWorkTasks?: LightWorkTaskUncheckedUpdateManyWithoutUserNestedInput
    deepWorkTasks?: DeepWorkTaskUncheckedUpdateManyWithoutUserNestedInput
    personalContext?: PersonalContextUncheckedUpdateManyWithoutUserNestedInput
    automationTasks?: AutomationTaskUncheckedUpdateManyWithoutUserNestedInput
    dailyHabits?: DailyHabitsUncheckedUpdateManyWithoutUserNestedInput
    dailyHealth?: DailyHealthUncheckedUpdateManyWithoutUserNestedInput
    dailyWorkout?: DailyWorkoutUncheckedUpdateManyWithoutUserNestedInput
    dailyRoutine?: DailyRoutineUncheckedUpdateManyWithoutUserNestedInput
    dailyReflections?: DailyReflectionsUncheckedUpdateManyWithoutUserNestedInput
    userProgress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    xpBalance?: XPBalanceUncheckedUpdateManyWithoutUserNestedInput
    xpPurchases?: XPPurchaseUncheckedUpdateManyWithoutUserNestedInput
    xpEarningLog?: XPEarningLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPersonalContextInput = {
    id?: string
    supabaseId: string
    email: string
    displayName?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    lightWorkTasks?: LightWorkTaskCreateNestedManyWithoutUserInput
    deepWorkTasks?: DeepWorkTaskCreateNestedManyWithoutUserInput
    automationTasks?: AutomationTaskCreateNestedManyWithoutUserInput
    dailyHabits?: DailyHabitsCreateNestedManyWithoutUserInput
    dailyHealth?: DailyHealthCreateNestedManyWithoutUserInput
    dailyWorkout?: DailyWorkoutCreateNestedManyWithoutUserInput
    dailyRoutine?: DailyRoutineCreateNestedManyWithoutUserInput
    dailyReflections?: DailyReflectionsCreateNestedManyWithoutUserInput
    timeBlocks?: TimeBlockCreateNestedManyWithoutUserInput
    userProgress?: UserProgressCreateNestedManyWithoutUserInput
    xpBalance?: XPBalanceCreateNestedManyWithoutUserInput
    xpPurchases?: XPPurchaseCreateNestedManyWithoutUserInput
    xpEarningLog?: XPEarningLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPersonalContextInput = {
    id?: string
    supabaseId: string
    email: string
    displayName?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    lightWorkTasks?: LightWorkTaskUncheckedCreateNestedManyWithoutUserInput
    deepWorkTasks?: DeepWorkTaskUncheckedCreateNestedManyWithoutUserInput
    automationTasks?: AutomationTaskUncheckedCreateNestedManyWithoutUserInput
    dailyHabits?: DailyHabitsUncheckedCreateNestedManyWithoutUserInput
    dailyHealth?: DailyHealthUncheckedCreateNestedManyWithoutUserInput
    dailyWorkout?: DailyWorkoutUncheckedCreateNestedManyWithoutUserInput
    dailyRoutine?: DailyRoutineUncheckedCreateNestedManyWithoutUserInput
    dailyReflections?: DailyReflectionsUncheckedCreateNestedManyWithoutUserInput
    timeBlocks?: TimeBlockUncheckedCreateNestedManyWithoutUserInput
    userProgress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    xpBalance?: XPBalanceUncheckedCreateNestedManyWithoutUserInput
    xpPurchases?: XPPurchaseUncheckedCreateNestedManyWithoutUserInput
    xpEarningLog?: XPEarningLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPersonalContextInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPersonalContextInput, UserUncheckedCreateWithoutPersonalContextInput>
  }

  export type UserUpsertWithoutPersonalContextInput = {
    update: XOR<UserUpdateWithoutPersonalContextInput, UserUncheckedUpdateWithoutPersonalContextInput>
    create: XOR<UserCreateWithoutPersonalContextInput, UserUncheckedCreateWithoutPersonalContextInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPersonalContextInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPersonalContextInput, UserUncheckedUpdateWithoutPersonalContextInput>
  }

  export type UserUpdateWithoutPersonalContextInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lightWorkTasks?: LightWorkTaskUpdateManyWithoutUserNestedInput
    deepWorkTasks?: DeepWorkTaskUpdateManyWithoutUserNestedInput
    automationTasks?: AutomationTaskUpdateManyWithoutUserNestedInput
    dailyHabits?: DailyHabitsUpdateManyWithoutUserNestedInput
    dailyHealth?: DailyHealthUpdateManyWithoutUserNestedInput
    dailyWorkout?: DailyWorkoutUpdateManyWithoutUserNestedInput
    dailyRoutine?: DailyRoutineUpdateManyWithoutUserNestedInput
    dailyReflections?: DailyReflectionsUpdateManyWithoutUserNestedInput
    timeBlocks?: TimeBlockUpdateManyWithoutUserNestedInput
    userProgress?: UserProgressUpdateManyWithoutUserNestedInput
    xpBalance?: XPBalanceUpdateManyWithoutUserNestedInput
    xpPurchases?: XPPurchaseUpdateManyWithoutUserNestedInput
    xpEarningLog?: XPEarningLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPersonalContextInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lightWorkTasks?: LightWorkTaskUncheckedUpdateManyWithoutUserNestedInput
    deepWorkTasks?: DeepWorkTaskUncheckedUpdateManyWithoutUserNestedInput
    automationTasks?: AutomationTaskUncheckedUpdateManyWithoutUserNestedInput
    dailyHabits?: DailyHabitsUncheckedUpdateManyWithoutUserNestedInput
    dailyHealth?: DailyHealthUncheckedUpdateManyWithoutUserNestedInput
    dailyWorkout?: DailyWorkoutUncheckedUpdateManyWithoutUserNestedInput
    dailyRoutine?: DailyRoutineUncheckedUpdateManyWithoutUserNestedInput
    dailyReflections?: DailyReflectionsUncheckedUpdateManyWithoutUserNestedInput
    timeBlocks?: TimeBlockUncheckedUpdateManyWithoutUserNestedInput
    userProgress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    xpBalance?: XPBalanceUncheckedUpdateManyWithoutUserNestedInput
    xpPurchases?: XPPurchaseUncheckedUpdateManyWithoutUserNestedInput
    xpEarningLog?: XPEarningLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AchievementCreateWithoutUserProgressInput = {
    id?: string
    name: string
    description: string
    badge: string
    category: $Enums.AchievementCategory
    requirement: number
    unlocked?: boolean
    progress?: number
    maxProgress: number
    unlockedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AchievementUncheckedCreateWithoutUserProgressInput = {
    id?: string
    name: string
    description: string
    badge: string
    category: $Enums.AchievementCategory
    requirement: number
    unlocked?: boolean
    progress?: number
    maxProgress: number
    unlockedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AchievementCreateOrConnectWithoutUserProgressInput = {
    where: AchievementWhereUniqueInput
    create: XOR<AchievementCreateWithoutUserProgressInput, AchievementUncheckedCreateWithoutUserProgressInput>
  }

  export type AchievementCreateManyUserProgressInputEnvelope = {
    data: AchievementCreateManyUserProgressInput | AchievementCreateManyUserProgressInput[]
    skipDuplicates?: boolean
  }

  export type DailyStatsCreateWithoutUserProgressInput = {
    id?: string
    date: string
    totalXP?: number
    activitiesCompleted?: number
    streakCount?: number
    level?: number
    routineXP?: number
    taskXP?: number
    healthXP?: number
    focusXP?: number
    habitXP?: number
    createdAt?: Date | string
  }

  export type DailyStatsUncheckedCreateWithoutUserProgressInput = {
    id?: string
    date: string
    totalXP?: number
    activitiesCompleted?: number
    streakCount?: number
    level?: number
    routineXP?: number
    taskXP?: number
    healthXP?: number
    focusXP?: number
    habitXP?: number
    createdAt?: Date | string
  }

  export type DailyStatsCreateOrConnectWithoutUserProgressInput = {
    where: DailyStatsWhereUniqueInput
    create: XOR<DailyStatsCreateWithoutUserProgressInput, DailyStatsUncheckedCreateWithoutUserProgressInput>
  }

  export type DailyStatsCreateManyUserProgressInputEnvelope = {
    data: DailyStatsCreateManyUserProgressInput | DailyStatsCreateManyUserProgressInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutUserProgressInput = {
    id?: string
    supabaseId: string
    email: string
    displayName?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    lightWorkTasks?: LightWorkTaskCreateNestedManyWithoutUserInput
    deepWorkTasks?: DeepWorkTaskCreateNestedManyWithoutUserInput
    personalContext?: PersonalContextCreateNestedManyWithoutUserInput
    automationTasks?: AutomationTaskCreateNestedManyWithoutUserInput
    dailyHabits?: DailyHabitsCreateNestedManyWithoutUserInput
    dailyHealth?: DailyHealthCreateNestedManyWithoutUserInput
    dailyWorkout?: DailyWorkoutCreateNestedManyWithoutUserInput
    dailyRoutine?: DailyRoutineCreateNestedManyWithoutUserInput
    dailyReflections?: DailyReflectionsCreateNestedManyWithoutUserInput
    timeBlocks?: TimeBlockCreateNestedManyWithoutUserInput
    xpBalance?: XPBalanceCreateNestedManyWithoutUserInput
    xpPurchases?: XPPurchaseCreateNestedManyWithoutUserInput
    xpEarningLog?: XPEarningLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserProgressInput = {
    id?: string
    supabaseId: string
    email: string
    displayName?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    lightWorkTasks?: LightWorkTaskUncheckedCreateNestedManyWithoutUserInput
    deepWorkTasks?: DeepWorkTaskUncheckedCreateNestedManyWithoutUserInput
    personalContext?: PersonalContextUncheckedCreateNestedManyWithoutUserInput
    automationTasks?: AutomationTaskUncheckedCreateNestedManyWithoutUserInput
    dailyHabits?: DailyHabitsUncheckedCreateNestedManyWithoutUserInput
    dailyHealth?: DailyHealthUncheckedCreateNestedManyWithoutUserInput
    dailyWorkout?: DailyWorkoutUncheckedCreateNestedManyWithoutUserInput
    dailyRoutine?: DailyRoutineUncheckedCreateNestedManyWithoutUserInput
    dailyReflections?: DailyReflectionsUncheckedCreateNestedManyWithoutUserInput
    timeBlocks?: TimeBlockUncheckedCreateNestedManyWithoutUserInput
    xpBalance?: XPBalanceUncheckedCreateNestedManyWithoutUserInput
    xpPurchases?: XPPurchaseUncheckedCreateNestedManyWithoutUserInput
    xpEarningLog?: XPEarningLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserProgressInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserProgressInput, UserUncheckedCreateWithoutUserProgressInput>
  }

  export type AchievementUpsertWithWhereUniqueWithoutUserProgressInput = {
    where: AchievementWhereUniqueInput
    update: XOR<AchievementUpdateWithoutUserProgressInput, AchievementUncheckedUpdateWithoutUserProgressInput>
    create: XOR<AchievementCreateWithoutUserProgressInput, AchievementUncheckedCreateWithoutUserProgressInput>
  }

  export type AchievementUpdateWithWhereUniqueWithoutUserProgressInput = {
    where: AchievementWhereUniqueInput
    data: XOR<AchievementUpdateWithoutUserProgressInput, AchievementUncheckedUpdateWithoutUserProgressInput>
  }

  export type AchievementUpdateManyWithWhereWithoutUserProgressInput = {
    where: AchievementScalarWhereInput
    data: XOR<AchievementUpdateManyMutationInput, AchievementUncheckedUpdateManyWithoutUserProgressInput>
  }

  export type AchievementScalarWhereInput = {
    AND?: AchievementScalarWhereInput | AchievementScalarWhereInput[]
    OR?: AchievementScalarWhereInput[]
    NOT?: AchievementScalarWhereInput | AchievementScalarWhereInput[]
    id?: StringFilter<"Achievement"> | string
    progressId?: StringFilter<"Achievement"> | string
    name?: StringFilter<"Achievement"> | string
    description?: StringFilter<"Achievement"> | string
    badge?: StringFilter<"Achievement"> | string
    category?: EnumAchievementCategoryFilter<"Achievement"> | $Enums.AchievementCategory
    requirement?: IntFilter<"Achievement"> | number
    unlocked?: BoolFilter<"Achievement"> | boolean
    progress?: IntFilter<"Achievement"> | number
    maxProgress?: IntFilter<"Achievement"> | number
    unlockedAt?: DateTimeNullableFilter<"Achievement"> | Date | string | null
    createdAt?: DateTimeFilter<"Achievement"> | Date | string
  }

  export type DailyStatsUpsertWithWhereUniqueWithoutUserProgressInput = {
    where: DailyStatsWhereUniqueInput
    update: XOR<DailyStatsUpdateWithoutUserProgressInput, DailyStatsUncheckedUpdateWithoutUserProgressInput>
    create: XOR<DailyStatsCreateWithoutUserProgressInput, DailyStatsUncheckedCreateWithoutUserProgressInput>
  }

  export type DailyStatsUpdateWithWhereUniqueWithoutUserProgressInput = {
    where: DailyStatsWhereUniqueInput
    data: XOR<DailyStatsUpdateWithoutUserProgressInput, DailyStatsUncheckedUpdateWithoutUserProgressInput>
  }

  export type DailyStatsUpdateManyWithWhereWithoutUserProgressInput = {
    where: DailyStatsScalarWhereInput
    data: XOR<DailyStatsUpdateManyMutationInput, DailyStatsUncheckedUpdateManyWithoutUserProgressInput>
  }

  export type DailyStatsScalarWhereInput = {
    AND?: DailyStatsScalarWhereInput | DailyStatsScalarWhereInput[]
    OR?: DailyStatsScalarWhereInput[]
    NOT?: DailyStatsScalarWhereInput | DailyStatsScalarWhereInput[]
    id?: StringFilter<"DailyStats"> | string
    progressId?: StringFilter<"DailyStats"> | string
    date?: StringFilter<"DailyStats"> | string
    totalXP?: IntFilter<"DailyStats"> | number
    activitiesCompleted?: IntFilter<"DailyStats"> | number
    streakCount?: IntFilter<"DailyStats"> | number
    level?: IntFilter<"DailyStats"> | number
    routineXP?: IntFilter<"DailyStats"> | number
    taskXP?: IntFilter<"DailyStats"> | number
    healthXP?: IntFilter<"DailyStats"> | number
    focusXP?: IntFilter<"DailyStats"> | number
    habitXP?: IntFilter<"DailyStats"> | number
    createdAt?: DateTimeFilter<"DailyStats"> | Date | string
  }

  export type UserUpsertWithoutUserProgressInput = {
    update: XOR<UserUpdateWithoutUserProgressInput, UserUncheckedUpdateWithoutUserProgressInput>
    create: XOR<UserCreateWithoutUserProgressInput, UserUncheckedCreateWithoutUserProgressInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserProgressInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserProgressInput, UserUncheckedUpdateWithoutUserProgressInput>
  }

  export type UserUpdateWithoutUserProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lightWorkTasks?: LightWorkTaskUpdateManyWithoutUserNestedInput
    deepWorkTasks?: DeepWorkTaskUpdateManyWithoutUserNestedInput
    personalContext?: PersonalContextUpdateManyWithoutUserNestedInput
    automationTasks?: AutomationTaskUpdateManyWithoutUserNestedInput
    dailyHabits?: DailyHabitsUpdateManyWithoutUserNestedInput
    dailyHealth?: DailyHealthUpdateManyWithoutUserNestedInput
    dailyWorkout?: DailyWorkoutUpdateManyWithoutUserNestedInput
    dailyRoutine?: DailyRoutineUpdateManyWithoutUserNestedInput
    dailyReflections?: DailyReflectionsUpdateManyWithoutUserNestedInput
    timeBlocks?: TimeBlockUpdateManyWithoutUserNestedInput
    xpBalance?: XPBalanceUpdateManyWithoutUserNestedInput
    xpPurchases?: XPPurchaseUpdateManyWithoutUserNestedInput
    xpEarningLog?: XPEarningLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lightWorkTasks?: LightWorkTaskUncheckedUpdateManyWithoutUserNestedInput
    deepWorkTasks?: DeepWorkTaskUncheckedUpdateManyWithoutUserNestedInput
    personalContext?: PersonalContextUncheckedUpdateManyWithoutUserNestedInput
    automationTasks?: AutomationTaskUncheckedUpdateManyWithoutUserNestedInput
    dailyHabits?: DailyHabitsUncheckedUpdateManyWithoutUserNestedInput
    dailyHealth?: DailyHealthUncheckedUpdateManyWithoutUserNestedInput
    dailyWorkout?: DailyWorkoutUncheckedUpdateManyWithoutUserNestedInput
    dailyRoutine?: DailyRoutineUncheckedUpdateManyWithoutUserNestedInput
    dailyReflections?: DailyReflectionsUncheckedUpdateManyWithoutUserNestedInput
    timeBlocks?: TimeBlockUncheckedUpdateManyWithoutUserNestedInput
    xpBalance?: XPBalanceUncheckedUpdateManyWithoutUserNestedInput
    xpPurchases?: XPPurchaseUncheckedUpdateManyWithoutUserNestedInput
    xpEarningLog?: XPEarningLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserProgressCreateWithoutAchievementsInput = {
    id?: string
    currentLevel?: number
    totalXP?: number
    dailyXP?: number
    currentStreak?: number
    bestStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    dailyStats?: DailyStatsCreateNestedManyWithoutUserProgressInput
    user: UserCreateNestedOneWithoutUserProgressInput
  }

  export type UserProgressUncheckedCreateWithoutAchievementsInput = {
    id?: string
    userId: string
    currentLevel?: number
    totalXP?: number
    dailyXP?: number
    currentStreak?: number
    bestStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    dailyStats?: DailyStatsUncheckedCreateNestedManyWithoutUserProgressInput
  }

  export type UserProgressCreateOrConnectWithoutAchievementsInput = {
    where: UserProgressWhereUniqueInput
    create: XOR<UserProgressCreateWithoutAchievementsInput, UserProgressUncheckedCreateWithoutAchievementsInput>
  }

  export type UserProgressUpsertWithoutAchievementsInput = {
    update: XOR<UserProgressUpdateWithoutAchievementsInput, UserProgressUncheckedUpdateWithoutAchievementsInput>
    create: XOR<UserProgressCreateWithoutAchievementsInput, UserProgressUncheckedCreateWithoutAchievementsInput>
    where?: UserProgressWhereInput
  }

  export type UserProgressUpdateToOneWithWhereWithoutAchievementsInput = {
    where?: UserProgressWhereInput
    data: XOR<UserProgressUpdateWithoutAchievementsInput, UserProgressUncheckedUpdateWithoutAchievementsInput>
  }

  export type UserProgressUpdateWithoutAchievementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentLevel?: IntFieldUpdateOperationsInput | number
    totalXP?: IntFieldUpdateOperationsInput | number
    dailyXP?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dailyStats?: DailyStatsUpdateManyWithoutUserProgressNestedInput
    user?: UserUpdateOneRequiredWithoutUserProgressNestedInput
  }

  export type UserProgressUncheckedUpdateWithoutAchievementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    currentLevel?: IntFieldUpdateOperationsInput | number
    totalXP?: IntFieldUpdateOperationsInput | number
    dailyXP?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dailyStats?: DailyStatsUncheckedUpdateManyWithoutUserProgressNestedInput
  }

  export type UserProgressCreateWithoutDailyStatsInput = {
    id?: string
    currentLevel?: number
    totalXP?: number
    dailyXP?: number
    currentStreak?: number
    bestStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    achievements?: AchievementCreateNestedManyWithoutUserProgressInput
    user: UserCreateNestedOneWithoutUserProgressInput
  }

  export type UserProgressUncheckedCreateWithoutDailyStatsInput = {
    id?: string
    userId: string
    currentLevel?: number
    totalXP?: number
    dailyXP?: number
    currentStreak?: number
    bestStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserProgressInput
  }

  export type UserProgressCreateOrConnectWithoutDailyStatsInput = {
    where: UserProgressWhereUniqueInput
    create: XOR<UserProgressCreateWithoutDailyStatsInput, UserProgressUncheckedCreateWithoutDailyStatsInput>
  }

  export type UserProgressUpsertWithoutDailyStatsInput = {
    update: XOR<UserProgressUpdateWithoutDailyStatsInput, UserProgressUncheckedUpdateWithoutDailyStatsInput>
    create: XOR<UserProgressCreateWithoutDailyStatsInput, UserProgressUncheckedCreateWithoutDailyStatsInput>
    where?: UserProgressWhereInput
  }

  export type UserProgressUpdateToOneWithWhereWithoutDailyStatsInput = {
    where?: UserProgressWhereInput
    data: XOR<UserProgressUpdateWithoutDailyStatsInput, UserProgressUncheckedUpdateWithoutDailyStatsInput>
  }

  export type UserProgressUpdateWithoutDailyStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentLevel?: IntFieldUpdateOperationsInput | number
    totalXP?: IntFieldUpdateOperationsInput | number
    dailyXP?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    achievements?: AchievementUpdateManyWithoutUserProgressNestedInput
    user?: UserUpdateOneRequiredWithoutUserProgressNestedInput
  }

  export type UserProgressUncheckedUpdateWithoutDailyStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    currentLevel?: IntFieldUpdateOperationsInput | number
    totalXP?: IntFieldUpdateOperationsInput | number
    dailyXP?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    achievements?: AchievementUncheckedUpdateManyWithoutUserProgressNestedInput
  }

  export type UserCreateWithoutXpBalanceInput = {
    id?: string
    supabaseId: string
    email: string
    displayName?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    lightWorkTasks?: LightWorkTaskCreateNestedManyWithoutUserInput
    deepWorkTasks?: DeepWorkTaskCreateNestedManyWithoutUserInput
    personalContext?: PersonalContextCreateNestedManyWithoutUserInput
    automationTasks?: AutomationTaskCreateNestedManyWithoutUserInput
    dailyHabits?: DailyHabitsCreateNestedManyWithoutUserInput
    dailyHealth?: DailyHealthCreateNestedManyWithoutUserInput
    dailyWorkout?: DailyWorkoutCreateNestedManyWithoutUserInput
    dailyRoutine?: DailyRoutineCreateNestedManyWithoutUserInput
    dailyReflections?: DailyReflectionsCreateNestedManyWithoutUserInput
    timeBlocks?: TimeBlockCreateNestedManyWithoutUserInput
    userProgress?: UserProgressCreateNestedManyWithoutUserInput
    xpPurchases?: XPPurchaseCreateNestedManyWithoutUserInput
    xpEarningLog?: XPEarningLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutXpBalanceInput = {
    id?: string
    supabaseId: string
    email: string
    displayName?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    lightWorkTasks?: LightWorkTaskUncheckedCreateNestedManyWithoutUserInput
    deepWorkTasks?: DeepWorkTaskUncheckedCreateNestedManyWithoutUserInput
    personalContext?: PersonalContextUncheckedCreateNestedManyWithoutUserInput
    automationTasks?: AutomationTaskUncheckedCreateNestedManyWithoutUserInput
    dailyHabits?: DailyHabitsUncheckedCreateNestedManyWithoutUserInput
    dailyHealth?: DailyHealthUncheckedCreateNestedManyWithoutUserInput
    dailyWorkout?: DailyWorkoutUncheckedCreateNestedManyWithoutUserInput
    dailyRoutine?: DailyRoutineUncheckedCreateNestedManyWithoutUserInput
    dailyReflections?: DailyReflectionsUncheckedCreateNestedManyWithoutUserInput
    timeBlocks?: TimeBlockUncheckedCreateNestedManyWithoutUserInput
    userProgress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    xpPurchases?: XPPurchaseUncheckedCreateNestedManyWithoutUserInput
    xpEarningLog?: XPEarningLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutXpBalanceInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutXpBalanceInput, UserUncheckedCreateWithoutXpBalanceInput>
  }

  export type UserUpsertWithoutXpBalanceInput = {
    update: XOR<UserUpdateWithoutXpBalanceInput, UserUncheckedUpdateWithoutXpBalanceInput>
    create: XOR<UserCreateWithoutXpBalanceInput, UserUncheckedCreateWithoutXpBalanceInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutXpBalanceInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutXpBalanceInput, UserUncheckedUpdateWithoutXpBalanceInput>
  }

  export type UserUpdateWithoutXpBalanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lightWorkTasks?: LightWorkTaskUpdateManyWithoutUserNestedInput
    deepWorkTasks?: DeepWorkTaskUpdateManyWithoutUserNestedInput
    personalContext?: PersonalContextUpdateManyWithoutUserNestedInput
    automationTasks?: AutomationTaskUpdateManyWithoutUserNestedInput
    dailyHabits?: DailyHabitsUpdateManyWithoutUserNestedInput
    dailyHealth?: DailyHealthUpdateManyWithoutUserNestedInput
    dailyWorkout?: DailyWorkoutUpdateManyWithoutUserNestedInput
    dailyRoutine?: DailyRoutineUpdateManyWithoutUserNestedInput
    dailyReflections?: DailyReflectionsUpdateManyWithoutUserNestedInput
    timeBlocks?: TimeBlockUpdateManyWithoutUserNestedInput
    userProgress?: UserProgressUpdateManyWithoutUserNestedInput
    xpPurchases?: XPPurchaseUpdateManyWithoutUserNestedInput
    xpEarningLog?: XPEarningLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutXpBalanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lightWorkTasks?: LightWorkTaskUncheckedUpdateManyWithoutUserNestedInput
    deepWorkTasks?: DeepWorkTaskUncheckedUpdateManyWithoutUserNestedInput
    personalContext?: PersonalContextUncheckedUpdateManyWithoutUserNestedInput
    automationTasks?: AutomationTaskUncheckedUpdateManyWithoutUserNestedInput
    dailyHabits?: DailyHabitsUncheckedUpdateManyWithoutUserNestedInput
    dailyHealth?: DailyHealthUncheckedUpdateManyWithoutUserNestedInput
    dailyWorkout?: DailyWorkoutUncheckedUpdateManyWithoutUserNestedInput
    dailyRoutine?: DailyRoutineUncheckedUpdateManyWithoutUserNestedInput
    dailyReflections?: DailyReflectionsUncheckedUpdateManyWithoutUserNestedInput
    timeBlocks?: TimeBlockUncheckedUpdateManyWithoutUserNestedInput
    userProgress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    xpPurchases?: XPPurchaseUncheckedUpdateManyWithoutUserNestedInput
    xpEarningLog?: XPEarningLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutXpPurchasesInput = {
    id?: string
    supabaseId: string
    email: string
    displayName?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    lightWorkTasks?: LightWorkTaskCreateNestedManyWithoutUserInput
    deepWorkTasks?: DeepWorkTaskCreateNestedManyWithoutUserInput
    personalContext?: PersonalContextCreateNestedManyWithoutUserInput
    automationTasks?: AutomationTaskCreateNestedManyWithoutUserInput
    dailyHabits?: DailyHabitsCreateNestedManyWithoutUserInput
    dailyHealth?: DailyHealthCreateNestedManyWithoutUserInput
    dailyWorkout?: DailyWorkoutCreateNestedManyWithoutUserInput
    dailyRoutine?: DailyRoutineCreateNestedManyWithoutUserInput
    dailyReflections?: DailyReflectionsCreateNestedManyWithoutUserInput
    timeBlocks?: TimeBlockCreateNestedManyWithoutUserInput
    userProgress?: UserProgressCreateNestedManyWithoutUserInput
    xpBalance?: XPBalanceCreateNestedManyWithoutUserInput
    xpEarningLog?: XPEarningLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutXpPurchasesInput = {
    id?: string
    supabaseId: string
    email: string
    displayName?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    lightWorkTasks?: LightWorkTaskUncheckedCreateNestedManyWithoutUserInput
    deepWorkTasks?: DeepWorkTaskUncheckedCreateNestedManyWithoutUserInput
    personalContext?: PersonalContextUncheckedCreateNestedManyWithoutUserInput
    automationTasks?: AutomationTaskUncheckedCreateNestedManyWithoutUserInput
    dailyHabits?: DailyHabitsUncheckedCreateNestedManyWithoutUserInput
    dailyHealth?: DailyHealthUncheckedCreateNestedManyWithoutUserInput
    dailyWorkout?: DailyWorkoutUncheckedCreateNestedManyWithoutUserInput
    dailyRoutine?: DailyRoutineUncheckedCreateNestedManyWithoutUserInput
    dailyReflections?: DailyReflectionsUncheckedCreateNestedManyWithoutUserInput
    timeBlocks?: TimeBlockUncheckedCreateNestedManyWithoutUserInput
    userProgress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    xpBalance?: XPBalanceUncheckedCreateNestedManyWithoutUserInput
    xpEarningLog?: XPEarningLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutXpPurchasesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutXpPurchasesInput, UserUncheckedCreateWithoutXpPurchasesInput>
  }

  export type RewardDefinitionCreateWithoutPurchasesInput = {
    id?: string
    category: string
    name: string
    description: string
    basePrice: number
    iconEmoji: string
    isActive?: boolean
    requiresStreak?: number | null
    maxDailyUse?: number
    availabilityWindow?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RewardDefinitionUncheckedCreateWithoutPurchasesInput = {
    id?: string
    category: string
    name: string
    description: string
    basePrice: number
    iconEmoji: string
    isActive?: boolean
    requiresStreak?: number | null
    maxDailyUse?: number
    availabilityWindow?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RewardDefinitionCreateOrConnectWithoutPurchasesInput = {
    where: RewardDefinitionWhereUniqueInput
    create: XOR<RewardDefinitionCreateWithoutPurchasesInput, RewardDefinitionUncheckedCreateWithoutPurchasesInput>
  }

  export type UserUpsertWithoutXpPurchasesInput = {
    update: XOR<UserUpdateWithoutXpPurchasesInput, UserUncheckedUpdateWithoutXpPurchasesInput>
    create: XOR<UserCreateWithoutXpPurchasesInput, UserUncheckedCreateWithoutXpPurchasesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutXpPurchasesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutXpPurchasesInput, UserUncheckedUpdateWithoutXpPurchasesInput>
  }

  export type UserUpdateWithoutXpPurchasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lightWorkTasks?: LightWorkTaskUpdateManyWithoutUserNestedInput
    deepWorkTasks?: DeepWorkTaskUpdateManyWithoutUserNestedInput
    personalContext?: PersonalContextUpdateManyWithoutUserNestedInput
    automationTasks?: AutomationTaskUpdateManyWithoutUserNestedInput
    dailyHabits?: DailyHabitsUpdateManyWithoutUserNestedInput
    dailyHealth?: DailyHealthUpdateManyWithoutUserNestedInput
    dailyWorkout?: DailyWorkoutUpdateManyWithoutUserNestedInput
    dailyRoutine?: DailyRoutineUpdateManyWithoutUserNestedInput
    dailyReflections?: DailyReflectionsUpdateManyWithoutUserNestedInput
    timeBlocks?: TimeBlockUpdateManyWithoutUserNestedInput
    userProgress?: UserProgressUpdateManyWithoutUserNestedInput
    xpBalance?: XPBalanceUpdateManyWithoutUserNestedInput
    xpEarningLog?: XPEarningLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutXpPurchasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lightWorkTasks?: LightWorkTaskUncheckedUpdateManyWithoutUserNestedInput
    deepWorkTasks?: DeepWorkTaskUncheckedUpdateManyWithoutUserNestedInput
    personalContext?: PersonalContextUncheckedUpdateManyWithoutUserNestedInput
    automationTasks?: AutomationTaskUncheckedUpdateManyWithoutUserNestedInput
    dailyHabits?: DailyHabitsUncheckedUpdateManyWithoutUserNestedInput
    dailyHealth?: DailyHealthUncheckedUpdateManyWithoutUserNestedInput
    dailyWorkout?: DailyWorkoutUncheckedUpdateManyWithoutUserNestedInput
    dailyRoutine?: DailyRoutineUncheckedUpdateManyWithoutUserNestedInput
    dailyReflections?: DailyReflectionsUncheckedUpdateManyWithoutUserNestedInput
    timeBlocks?: TimeBlockUncheckedUpdateManyWithoutUserNestedInput
    userProgress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    xpBalance?: XPBalanceUncheckedUpdateManyWithoutUserNestedInput
    xpEarningLog?: XPEarningLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RewardDefinitionUpsertWithoutPurchasesInput = {
    update: XOR<RewardDefinitionUpdateWithoutPurchasesInput, RewardDefinitionUncheckedUpdateWithoutPurchasesInput>
    create: XOR<RewardDefinitionCreateWithoutPurchasesInput, RewardDefinitionUncheckedCreateWithoutPurchasesInput>
    where?: RewardDefinitionWhereInput
  }

  export type RewardDefinitionUpdateToOneWithWhereWithoutPurchasesInput = {
    where?: RewardDefinitionWhereInput
    data: XOR<RewardDefinitionUpdateWithoutPurchasesInput, RewardDefinitionUncheckedUpdateWithoutPurchasesInput>
  }

  export type RewardDefinitionUpdateWithoutPurchasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    basePrice?: IntFieldUpdateOperationsInput | number
    iconEmoji?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requiresStreak?: NullableIntFieldUpdateOperationsInput | number | null
    maxDailyUse?: IntFieldUpdateOperationsInput | number
    availabilityWindow?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RewardDefinitionUncheckedUpdateWithoutPurchasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    basePrice?: IntFieldUpdateOperationsInput | number
    iconEmoji?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requiresStreak?: NullableIntFieldUpdateOperationsInput | number | null
    maxDailyUse?: IntFieldUpdateOperationsInput | number
    availabilityWindow?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutXpEarningLogInput = {
    id?: string
    supabaseId: string
    email: string
    displayName?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    lightWorkTasks?: LightWorkTaskCreateNestedManyWithoutUserInput
    deepWorkTasks?: DeepWorkTaskCreateNestedManyWithoutUserInput
    personalContext?: PersonalContextCreateNestedManyWithoutUserInput
    automationTasks?: AutomationTaskCreateNestedManyWithoutUserInput
    dailyHabits?: DailyHabitsCreateNestedManyWithoutUserInput
    dailyHealth?: DailyHealthCreateNestedManyWithoutUserInput
    dailyWorkout?: DailyWorkoutCreateNestedManyWithoutUserInput
    dailyRoutine?: DailyRoutineCreateNestedManyWithoutUserInput
    dailyReflections?: DailyReflectionsCreateNestedManyWithoutUserInput
    timeBlocks?: TimeBlockCreateNestedManyWithoutUserInput
    userProgress?: UserProgressCreateNestedManyWithoutUserInput
    xpBalance?: XPBalanceCreateNestedManyWithoutUserInput
    xpPurchases?: XPPurchaseCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutXpEarningLogInput = {
    id?: string
    supabaseId: string
    email: string
    displayName?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    lightWorkTasks?: LightWorkTaskUncheckedCreateNestedManyWithoutUserInput
    deepWorkTasks?: DeepWorkTaskUncheckedCreateNestedManyWithoutUserInput
    personalContext?: PersonalContextUncheckedCreateNestedManyWithoutUserInput
    automationTasks?: AutomationTaskUncheckedCreateNestedManyWithoutUserInput
    dailyHabits?: DailyHabitsUncheckedCreateNestedManyWithoutUserInput
    dailyHealth?: DailyHealthUncheckedCreateNestedManyWithoutUserInput
    dailyWorkout?: DailyWorkoutUncheckedCreateNestedManyWithoutUserInput
    dailyRoutine?: DailyRoutineUncheckedCreateNestedManyWithoutUserInput
    dailyReflections?: DailyReflectionsUncheckedCreateNestedManyWithoutUserInput
    timeBlocks?: TimeBlockUncheckedCreateNestedManyWithoutUserInput
    userProgress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    xpBalance?: XPBalanceUncheckedCreateNestedManyWithoutUserInput
    xpPurchases?: XPPurchaseUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutXpEarningLogInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutXpEarningLogInput, UserUncheckedCreateWithoutXpEarningLogInput>
  }

  export type UserUpsertWithoutXpEarningLogInput = {
    update: XOR<UserUpdateWithoutXpEarningLogInput, UserUncheckedUpdateWithoutXpEarningLogInput>
    create: XOR<UserCreateWithoutXpEarningLogInput, UserUncheckedCreateWithoutXpEarningLogInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutXpEarningLogInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutXpEarningLogInput, UserUncheckedUpdateWithoutXpEarningLogInput>
  }

  export type UserUpdateWithoutXpEarningLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lightWorkTasks?: LightWorkTaskUpdateManyWithoutUserNestedInput
    deepWorkTasks?: DeepWorkTaskUpdateManyWithoutUserNestedInput
    personalContext?: PersonalContextUpdateManyWithoutUserNestedInput
    automationTasks?: AutomationTaskUpdateManyWithoutUserNestedInput
    dailyHabits?: DailyHabitsUpdateManyWithoutUserNestedInput
    dailyHealth?: DailyHealthUpdateManyWithoutUserNestedInput
    dailyWorkout?: DailyWorkoutUpdateManyWithoutUserNestedInput
    dailyRoutine?: DailyRoutineUpdateManyWithoutUserNestedInput
    dailyReflections?: DailyReflectionsUpdateManyWithoutUserNestedInput
    timeBlocks?: TimeBlockUpdateManyWithoutUserNestedInput
    userProgress?: UserProgressUpdateManyWithoutUserNestedInput
    xpBalance?: XPBalanceUpdateManyWithoutUserNestedInput
    xpPurchases?: XPPurchaseUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutXpEarningLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lightWorkTasks?: LightWorkTaskUncheckedUpdateManyWithoutUserNestedInput
    deepWorkTasks?: DeepWorkTaskUncheckedUpdateManyWithoutUserNestedInput
    personalContext?: PersonalContextUncheckedUpdateManyWithoutUserNestedInput
    automationTasks?: AutomationTaskUncheckedUpdateManyWithoutUserNestedInput
    dailyHabits?: DailyHabitsUncheckedUpdateManyWithoutUserNestedInput
    dailyHealth?: DailyHealthUncheckedUpdateManyWithoutUserNestedInput
    dailyWorkout?: DailyWorkoutUncheckedUpdateManyWithoutUserNestedInput
    dailyRoutine?: DailyRoutineUncheckedUpdateManyWithoutUserNestedInput
    dailyReflections?: DailyReflectionsUncheckedUpdateManyWithoutUserNestedInput
    timeBlocks?: TimeBlockUncheckedUpdateManyWithoutUserNestedInput
    userProgress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    xpBalance?: XPBalanceUncheckedUpdateManyWithoutUserNestedInput
    xpPurchases?: XPPurchaseUncheckedUpdateManyWithoutUserNestedInput
  }

  export type XPPurchaseCreateWithoutRewardInput = {
    id?: string
    xpSpent: number
    actualPrice: number
    purchaseType?: string
    notes?: string | null
    satisfactionRating?: number | null
    guiltLevel?: number | null
    wasPlanned?: boolean
    celebrationLevel?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutXpPurchasesInput
  }

  export type XPPurchaseUncheckedCreateWithoutRewardInput = {
    id?: string
    userId: string
    xpSpent: number
    actualPrice: number
    purchaseType?: string
    notes?: string | null
    satisfactionRating?: number | null
    guiltLevel?: number | null
    wasPlanned?: boolean
    celebrationLevel?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type XPPurchaseCreateOrConnectWithoutRewardInput = {
    where: XPPurchaseWhereUniqueInput
    create: XOR<XPPurchaseCreateWithoutRewardInput, XPPurchaseUncheckedCreateWithoutRewardInput>
  }

  export type XPPurchaseCreateManyRewardInputEnvelope = {
    data: XPPurchaseCreateManyRewardInput | XPPurchaseCreateManyRewardInput[]
    skipDuplicates?: boolean
  }

  export type XPPurchaseUpsertWithWhereUniqueWithoutRewardInput = {
    where: XPPurchaseWhereUniqueInput
    update: XOR<XPPurchaseUpdateWithoutRewardInput, XPPurchaseUncheckedUpdateWithoutRewardInput>
    create: XOR<XPPurchaseCreateWithoutRewardInput, XPPurchaseUncheckedCreateWithoutRewardInput>
  }

  export type XPPurchaseUpdateWithWhereUniqueWithoutRewardInput = {
    where: XPPurchaseWhereUniqueInput
    data: XOR<XPPurchaseUpdateWithoutRewardInput, XPPurchaseUncheckedUpdateWithoutRewardInput>
  }

  export type XPPurchaseUpdateManyWithWhereWithoutRewardInput = {
    where: XPPurchaseScalarWhereInput
    data: XOR<XPPurchaseUpdateManyMutationInput, XPPurchaseUncheckedUpdateManyWithoutRewardInput>
  }

  export type LightWorkTaskCreateManyUserInput = {
    id?: string
    title: string
    description?: string | null
    priority?: $Enums.Priority
    completed?: boolean
    originalDate: string
    currentDate: string
    estimatedDuration?: number | null
    rollovers?: number
    tags?: LightWorkTaskCreatetagsInput | string[]
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    startedAt?: Date | string | null
    actualDurationMin?: number | null
    timeEstimate?: string | null
    aiAnalyzed?: boolean
    aiReasoning?: string | null
    analyzedAt?: Date | string | null
    xpReward?: number | null
    complexity?: number | null
    confidence?: number | null
    contextualBonus?: number | null
    difficulty?: number | null
    learningValue?: number | null
    priorityRank?: number | null
    strategicImportance?: number | null
    timeAccuracy?: number | null
  }

  export type DeepWorkTaskCreateManyUserInput = {
    id?: string
    title: string
    description?: string | null
    priority?: $Enums.Priority
    completed?: boolean
    originalDate: string
    currentDate: string
    estimatedDuration?: number | null
    focusBlocks?: number
    breakDuration?: number
    interruptionMode?: boolean
    rollovers?: number
    tags?: DeepWorkTaskCreatetagsInput | string[]
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    startedAt?: Date | string | null
    actualDurationMin?: number | null
    timeEstimate?: string | null
    aiAnalyzed?: boolean
    aiReasoning?: string | null
    analyzedAt?: Date | string | null
    xpReward?: number | null
    complexity?: number | null
    confidence?: number | null
    contextualBonus?: number | null
    difficulty?: number | null
    learningValue?: number | null
    priorityRank?: number | null
    strategicImportance?: number | null
    timeAccuracy?: number | null
  }

  export type PersonalContextCreateManyUserInput = {
    id?: string
    currentGoals?: string | null
    skillPriorities?: string | null
    revenueTargets?: string | null
    timeConstraints?: string | null
    currentProjects?: string | null
    hatedTasks?: string | null
    valuedTasks?: string | null
    learningObjectives?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AutomationTaskCreateManyUserInput = {
    id?: string
    name: string
    description?: string | null
    category: $Enums.AutomationCategory
    priority: $Enums.Priority
    status?: $Enums.AutomationStatus
    prompt: string
    allowedTools?: JsonNullValueInput | InputJsonValue
    estimatedTokens?: number
    actualTokens?: number | null
    executionTimeMs?: number | null
    result?: string | null
    error?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type DailyHabitsCreateManyUserInput = {
    id?: string
    date: string
    screenTimeMinutes?: number
    bullshitContentMinutes?: number
    noWeed?: boolean
    noScrolling?: boolean
    deepWorkHours?: number
    lightWorkHours?: number
    habitsData?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyHealthCreateManyUserInput = {
    id?: string
    date: string
    healthChecklist?: JsonNullValueInput | InputJsonValue
    meals?: JsonNullValueInput | InputJsonValue
    macros?: JsonNullValueInput | InputJsonValue
    waterIntakeMl?: number
    milkIntakeMl?: number
    sleepHours?: number
    energyLevel?: number | null
    moodLevel?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyWorkoutCreateManyUserInput = {
    id?: string
    date: string
    exercises?: JsonNullValueInput | InputJsonValue
    totalExercises?: number
    completedExercises?: number
    completionPercentage?: number
    durationMinutes?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyRoutineCreateManyUserInput = {
    id?: string
    date: string
    routineType: $Enums.RoutineType
    items?: JsonNullValueInput | InputJsonValue
    completedCount?: number
    totalCount?: number
    completionPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyReflectionsCreateManyUserInput = {
    id?: string
    date: string
    wentWell?: DailyReflectionsCreatewentWellInput | string[]
    evenBetterIf?: DailyReflectionsCreateevenBetterIfInput | string[]
    analysis?: DailyReflectionsCreateanalysisInput | string[]
    patterns?: DailyReflectionsCreatepatternsInput | string[]
    changes?: DailyReflectionsCreatechangesInput | string[]
    overallRating?: number | null
    keyLearnings?: string | null
    tomorrowFocus?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimeBlockCreateManyUserInput = {
    id?: string
    date: string
    startTime: string
    endTime: string
    title: string
    description?: string | null
    category: $Enums.TimeBlockCategory
    completed?: boolean
    actualStart?: string | null
    actualEnd?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserProgressCreateManyUserInput = {
    id?: string
    currentLevel?: number
    totalXP?: number
    dailyXP?: number
    currentStreak?: number
    bestStreak?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type XPBalanceCreateManyUserInput = {
    id?: string
    currentXP?: number
    totalEarned?: number
    totalSpent?: number
    reserveXP?: number
    pendingLoans?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type XPPurchaseCreateManyUserInput = {
    id?: string
    rewardId: string
    xpSpent: number
    actualPrice: number
    purchaseType?: string
    notes?: string | null
    satisfactionRating?: number | null
    guiltLevel?: number | null
    wasPlanned?: boolean
    celebrationLevel?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type XPEarningLogCreateManyUserInput = {
    id?: string
    source: string
    sourceId?: string | null
    baseXP: number
    finalXP: number
    multipliers?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type LightWorkTaskUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    completed?: BoolFieldUpdateOperationsInput | boolean
    originalDate?: StringFieldUpdateOperationsInput | string
    currentDate?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    rollovers?: IntFieldUpdateOperationsInput | number
    tags?: LightWorkTaskUpdatetagsInput | string[]
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDurationMin?: NullableIntFieldUpdateOperationsInput | number | null
    timeEstimate?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalyzed?: BoolFieldUpdateOperationsInput | boolean
    aiReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    analyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    xpReward?: NullableIntFieldUpdateOperationsInput | number | null
    complexity?: NullableIntFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    contextualBonus?: NullableFloatFieldUpdateOperationsInput | number | null
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    learningValue?: NullableIntFieldUpdateOperationsInput | number | null
    priorityRank?: NullableIntFieldUpdateOperationsInput | number | null
    strategicImportance?: NullableIntFieldUpdateOperationsInput | number | null
    timeAccuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    subtasks?: LightWorkSubtaskUpdateManyWithoutTaskNestedInput
  }

  export type LightWorkTaskUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    completed?: BoolFieldUpdateOperationsInput | boolean
    originalDate?: StringFieldUpdateOperationsInput | string
    currentDate?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    rollovers?: IntFieldUpdateOperationsInput | number
    tags?: LightWorkTaskUpdatetagsInput | string[]
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDurationMin?: NullableIntFieldUpdateOperationsInput | number | null
    timeEstimate?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalyzed?: BoolFieldUpdateOperationsInput | boolean
    aiReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    analyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    xpReward?: NullableIntFieldUpdateOperationsInput | number | null
    complexity?: NullableIntFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    contextualBonus?: NullableFloatFieldUpdateOperationsInput | number | null
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    learningValue?: NullableIntFieldUpdateOperationsInput | number | null
    priorityRank?: NullableIntFieldUpdateOperationsInput | number | null
    strategicImportance?: NullableIntFieldUpdateOperationsInput | number | null
    timeAccuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    subtasks?: LightWorkSubtaskUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type LightWorkTaskUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    completed?: BoolFieldUpdateOperationsInput | boolean
    originalDate?: StringFieldUpdateOperationsInput | string
    currentDate?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    rollovers?: IntFieldUpdateOperationsInput | number
    tags?: LightWorkTaskUpdatetagsInput | string[]
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDurationMin?: NullableIntFieldUpdateOperationsInput | number | null
    timeEstimate?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalyzed?: BoolFieldUpdateOperationsInput | boolean
    aiReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    analyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    xpReward?: NullableIntFieldUpdateOperationsInput | number | null
    complexity?: NullableIntFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    contextualBonus?: NullableFloatFieldUpdateOperationsInput | number | null
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    learningValue?: NullableIntFieldUpdateOperationsInput | number | null
    priorityRank?: NullableIntFieldUpdateOperationsInput | number | null
    strategicImportance?: NullableIntFieldUpdateOperationsInput | number | null
    timeAccuracy?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type DeepWorkTaskUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    completed?: BoolFieldUpdateOperationsInput | boolean
    originalDate?: StringFieldUpdateOperationsInput | string
    currentDate?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    focusBlocks?: IntFieldUpdateOperationsInput | number
    breakDuration?: IntFieldUpdateOperationsInput | number
    interruptionMode?: BoolFieldUpdateOperationsInput | boolean
    rollovers?: IntFieldUpdateOperationsInput | number
    tags?: DeepWorkTaskUpdatetagsInput | string[]
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDurationMin?: NullableIntFieldUpdateOperationsInput | number | null
    timeEstimate?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalyzed?: BoolFieldUpdateOperationsInput | boolean
    aiReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    analyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    xpReward?: NullableIntFieldUpdateOperationsInput | number | null
    complexity?: NullableIntFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    contextualBonus?: NullableFloatFieldUpdateOperationsInput | number | null
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    learningValue?: NullableIntFieldUpdateOperationsInput | number | null
    priorityRank?: NullableIntFieldUpdateOperationsInput | number | null
    strategicImportance?: NullableIntFieldUpdateOperationsInput | number | null
    timeAccuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    subtasks?: DeepWorkSubtaskUpdateManyWithoutTaskNestedInput
  }

  export type DeepWorkTaskUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    completed?: BoolFieldUpdateOperationsInput | boolean
    originalDate?: StringFieldUpdateOperationsInput | string
    currentDate?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    focusBlocks?: IntFieldUpdateOperationsInput | number
    breakDuration?: IntFieldUpdateOperationsInput | number
    interruptionMode?: BoolFieldUpdateOperationsInput | boolean
    rollovers?: IntFieldUpdateOperationsInput | number
    tags?: DeepWorkTaskUpdatetagsInput | string[]
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDurationMin?: NullableIntFieldUpdateOperationsInput | number | null
    timeEstimate?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalyzed?: BoolFieldUpdateOperationsInput | boolean
    aiReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    analyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    xpReward?: NullableIntFieldUpdateOperationsInput | number | null
    complexity?: NullableIntFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    contextualBonus?: NullableFloatFieldUpdateOperationsInput | number | null
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    learningValue?: NullableIntFieldUpdateOperationsInput | number | null
    priorityRank?: NullableIntFieldUpdateOperationsInput | number | null
    strategicImportance?: NullableIntFieldUpdateOperationsInput | number | null
    timeAccuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    subtasks?: DeepWorkSubtaskUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type DeepWorkTaskUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    completed?: BoolFieldUpdateOperationsInput | boolean
    originalDate?: StringFieldUpdateOperationsInput | string
    currentDate?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    focusBlocks?: IntFieldUpdateOperationsInput | number
    breakDuration?: IntFieldUpdateOperationsInput | number
    interruptionMode?: BoolFieldUpdateOperationsInput | boolean
    rollovers?: IntFieldUpdateOperationsInput | number
    tags?: DeepWorkTaskUpdatetagsInput | string[]
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDurationMin?: NullableIntFieldUpdateOperationsInput | number | null
    timeEstimate?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalyzed?: BoolFieldUpdateOperationsInput | boolean
    aiReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    analyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    xpReward?: NullableIntFieldUpdateOperationsInput | number | null
    complexity?: NullableIntFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    contextualBonus?: NullableFloatFieldUpdateOperationsInput | number | null
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    learningValue?: NullableIntFieldUpdateOperationsInput | number | null
    priorityRank?: NullableIntFieldUpdateOperationsInput | number | null
    strategicImportance?: NullableIntFieldUpdateOperationsInput | number | null
    timeAccuracy?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type PersonalContextUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentGoals?: NullableStringFieldUpdateOperationsInput | string | null
    skillPriorities?: NullableStringFieldUpdateOperationsInput | string | null
    revenueTargets?: NullableStringFieldUpdateOperationsInput | string | null
    timeConstraints?: NullableStringFieldUpdateOperationsInput | string | null
    currentProjects?: NullableStringFieldUpdateOperationsInput | string | null
    hatedTasks?: NullableStringFieldUpdateOperationsInput | string | null
    valuedTasks?: NullableStringFieldUpdateOperationsInput | string | null
    learningObjectives?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonalContextUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentGoals?: NullableStringFieldUpdateOperationsInput | string | null
    skillPriorities?: NullableStringFieldUpdateOperationsInput | string | null
    revenueTargets?: NullableStringFieldUpdateOperationsInput | string | null
    timeConstraints?: NullableStringFieldUpdateOperationsInput | string | null
    currentProjects?: NullableStringFieldUpdateOperationsInput | string | null
    hatedTasks?: NullableStringFieldUpdateOperationsInput | string | null
    valuedTasks?: NullableStringFieldUpdateOperationsInput | string | null
    learningObjectives?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonalContextUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentGoals?: NullableStringFieldUpdateOperationsInput | string | null
    skillPriorities?: NullableStringFieldUpdateOperationsInput | string | null
    revenueTargets?: NullableStringFieldUpdateOperationsInput | string | null
    timeConstraints?: NullableStringFieldUpdateOperationsInput | string | null
    currentProjects?: NullableStringFieldUpdateOperationsInput | string | null
    hatedTasks?: NullableStringFieldUpdateOperationsInput | string | null
    valuedTasks?: NullableStringFieldUpdateOperationsInput | string | null
    learningObjectives?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutomationTaskUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumAutomationCategoryFieldUpdateOperationsInput | $Enums.AutomationCategory
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumAutomationStatusFieldUpdateOperationsInput | $Enums.AutomationStatus
    prompt?: StringFieldUpdateOperationsInput | string
    allowedTools?: JsonNullValueInput | InputJsonValue
    estimatedTokens?: IntFieldUpdateOperationsInput | number
    actualTokens?: NullableIntFieldUpdateOperationsInput | number | null
    executionTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AutomationTaskUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumAutomationCategoryFieldUpdateOperationsInput | $Enums.AutomationCategory
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumAutomationStatusFieldUpdateOperationsInput | $Enums.AutomationStatus
    prompt?: StringFieldUpdateOperationsInput | string
    allowedTools?: JsonNullValueInput | InputJsonValue
    estimatedTokens?: IntFieldUpdateOperationsInput | number
    actualTokens?: NullableIntFieldUpdateOperationsInput | number | null
    executionTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AutomationTaskUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumAutomationCategoryFieldUpdateOperationsInput | $Enums.AutomationCategory
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumAutomationStatusFieldUpdateOperationsInput | $Enums.AutomationStatus
    prompt?: StringFieldUpdateOperationsInput | string
    allowedTools?: JsonNullValueInput | InputJsonValue
    estimatedTokens?: IntFieldUpdateOperationsInput | number
    actualTokens?: NullableIntFieldUpdateOperationsInput | number | null
    executionTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DailyHabitsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    screenTimeMinutes?: IntFieldUpdateOperationsInput | number
    bullshitContentMinutes?: IntFieldUpdateOperationsInput | number
    noWeed?: BoolFieldUpdateOperationsInput | boolean
    noScrolling?: BoolFieldUpdateOperationsInput | boolean
    deepWorkHours?: FloatFieldUpdateOperationsInput | number
    lightWorkHours?: FloatFieldUpdateOperationsInput | number
    habitsData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyHabitsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    screenTimeMinutes?: IntFieldUpdateOperationsInput | number
    bullshitContentMinutes?: IntFieldUpdateOperationsInput | number
    noWeed?: BoolFieldUpdateOperationsInput | boolean
    noScrolling?: BoolFieldUpdateOperationsInput | boolean
    deepWorkHours?: FloatFieldUpdateOperationsInput | number
    lightWorkHours?: FloatFieldUpdateOperationsInput | number
    habitsData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyHabitsUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    screenTimeMinutes?: IntFieldUpdateOperationsInput | number
    bullshitContentMinutes?: IntFieldUpdateOperationsInput | number
    noWeed?: BoolFieldUpdateOperationsInput | boolean
    noScrolling?: BoolFieldUpdateOperationsInput | boolean
    deepWorkHours?: FloatFieldUpdateOperationsInput | number
    lightWorkHours?: FloatFieldUpdateOperationsInput | number
    habitsData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyHealthUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    healthChecklist?: JsonNullValueInput | InputJsonValue
    meals?: JsonNullValueInput | InputJsonValue
    macros?: JsonNullValueInput | InputJsonValue
    waterIntakeMl?: IntFieldUpdateOperationsInput | number
    milkIntakeMl?: IntFieldUpdateOperationsInput | number
    sleepHours?: FloatFieldUpdateOperationsInput | number
    energyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    moodLevel?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyHealthUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    healthChecklist?: JsonNullValueInput | InputJsonValue
    meals?: JsonNullValueInput | InputJsonValue
    macros?: JsonNullValueInput | InputJsonValue
    waterIntakeMl?: IntFieldUpdateOperationsInput | number
    milkIntakeMl?: IntFieldUpdateOperationsInput | number
    sleepHours?: FloatFieldUpdateOperationsInput | number
    energyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    moodLevel?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyHealthUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    healthChecklist?: JsonNullValueInput | InputJsonValue
    meals?: JsonNullValueInput | InputJsonValue
    macros?: JsonNullValueInput | InputJsonValue
    waterIntakeMl?: IntFieldUpdateOperationsInput | number
    milkIntakeMl?: IntFieldUpdateOperationsInput | number
    sleepHours?: FloatFieldUpdateOperationsInput | number
    energyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    moodLevel?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyWorkoutUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    exercises?: JsonNullValueInput | InputJsonValue
    totalExercises?: IntFieldUpdateOperationsInput | number
    completedExercises?: IntFieldUpdateOperationsInput | number
    completionPercentage?: FloatFieldUpdateOperationsInput | number
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyWorkoutUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    exercises?: JsonNullValueInput | InputJsonValue
    totalExercises?: IntFieldUpdateOperationsInput | number
    completedExercises?: IntFieldUpdateOperationsInput | number
    completionPercentage?: FloatFieldUpdateOperationsInput | number
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyWorkoutUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    exercises?: JsonNullValueInput | InputJsonValue
    totalExercises?: IntFieldUpdateOperationsInput | number
    completedExercises?: IntFieldUpdateOperationsInput | number
    completionPercentage?: FloatFieldUpdateOperationsInput | number
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyRoutineUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    routineType?: EnumRoutineTypeFieldUpdateOperationsInput | $Enums.RoutineType
    items?: JsonNullValueInput | InputJsonValue
    completedCount?: IntFieldUpdateOperationsInput | number
    totalCount?: IntFieldUpdateOperationsInput | number
    completionPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyRoutineUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    routineType?: EnumRoutineTypeFieldUpdateOperationsInput | $Enums.RoutineType
    items?: JsonNullValueInput | InputJsonValue
    completedCount?: IntFieldUpdateOperationsInput | number
    totalCount?: IntFieldUpdateOperationsInput | number
    completionPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyRoutineUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    routineType?: EnumRoutineTypeFieldUpdateOperationsInput | $Enums.RoutineType
    items?: JsonNullValueInput | InputJsonValue
    completedCount?: IntFieldUpdateOperationsInput | number
    totalCount?: IntFieldUpdateOperationsInput | number
    completionPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyReflectionsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    wentWell?: DailyReflectionsUpdatewentWellInput | string[]
    evenBetterIf?: DailyReflectionsUpdateevenBetterIfInput | string[]
    analysis?: DailyReflectionsUpdateanalysisInput | string[]
    patterns?: DailyReflectionsUpdatepatternsInput | string[]
    changes?: DailyReflectionsUpdatechangesInput | string[]
    overallRating?: NullableIntFieldUpdateOperationsInput | number | null
    keyLearnings?: NullableStringFieldUpdateOperationsInput | string | null
    tomorrowFocus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyReflectionsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    wentWell?: DailyReflectionsUpdatewentWellInput | string[]
    evenBetterIf?: DailyReflectionsUpdateevenBetterIfInput | string[]
    analysis?: DailyReflectionsUpdateanalysisInput | string[]
    patterns?: DailyReflectionsUpdatepatternsInput | string[]
    changes?: DailyReflectionsUpdatechangesInput | string[]
    overallRating?: NullableIntFieldUpdateOperationsInput | number | null
    keyLearnings?: NullableStringFieldUpdateOperationsInput | string | null
    tomorrowFocus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyReflectionsUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    wentWell?: DailyReflectionsUpdatewentWellInput | string[]
    evenBetterIf?: DailyReflectionsUpdateevenBetterIfInput | string[]
    analysis?: DailyReflectionsUpdateanalysisInput | string[]
    patterns?: DailyReflectionsUpdatepatternsInput | string[]
    changes?: DailyReflectionsUpdatechangesInput | string[]
    overallRating?: NullableIntFieldUpdateOperationsInput | number | null
    keyLearnings?: NullableStringFieldUpdateOperationsInput | string | null
    tomorrowFocus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimeBlockUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumTimeBlockCategoryFieldUpdateOperationsInput | $Enums.TimeBlockCategory
    completed?: BoolFieldUpdateOperationsInput | boolean
    actualStart?: NullableStringFieldUpdateOperationsInput | string | null
    actualEnd?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimeBlockUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumTimeBlockCategoryFieldUpdateOperationsInput | $Enums.TimeBlockCategory
    completed?: BoolFieldUpdateOperationsInput | boolean
    actualStart?: NullableStringFieldUpdateOperationsInput | string | null
    actualEnd?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimeBlockUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumTimeBlockCategoryFieldUpdateOperationsInput | $Enums.TimeBlockCategory
    completed?: BoolFieldUpdateOperationsInput | boolean
    actualStart?: NullableStringFieldUpdateOperationsInput | string | null
    actualEnd?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProgressUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentLevel?: IntFieldUpdateOperationsInput | number
    totalXP?: IntFieldUpdateOperationsInput | number
    dailyXP?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    achievements?: AchievementUpdateManyWithoutUserProgressNestedInput
    dailyStats?: DailyStatsUpdateManyWithoutUserProgressNestedInput
  }

  export type UserProgressUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentLevel?: IntFieldUpdateOperationsInput | number
    totalXP?: IntFieldUpdateOperationsInput | number
    dailyXP?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    achievements?: AchievementUncheckedUpdateManyWithoutUserProgressNestedInput
    dailyStats?: DailyStatsUncheckedUpdateManyWithoutUserProgressNestedInput
  }

  export type UserProgressUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentLevel?: IntFieldUpdateOperationsInput | number
    totalXP?: IntFieldUpdateOperationsInput | number
    dailyXP?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XPBalanceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentXP?: IntFieldUpdateOperationsInput | number
    totalEarned?: IntFieldUpdateOperationsInput | number
    totalSpent?: IntFieldUpdateOperationsInput | number
    reserveXP?: IntFieldUpdateOperationsInput | number
    pendingLoans?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XPBalanceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentXP?: IntFieldUpdateOperationsInput | number
    totalEarned?: IntFieldUpdateOperationsInput | number
    totalSpent?: IntFieldUpdateOperationsInput | number
    reserveXP?: IntFieldUpdateOperationsInput | number
    pendingLoans?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XPBalanceUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentXP?: IntFieldUpdateOperationsInput | number
    totalEarned?: IntFieldUpdateOperationsInput | number
    totalSpent?: IntFieldUpdateOperationsInput | number
    reserveXP?: IntFieldUpdateOperationsInput | number
    pendingLoans?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XPPurchaseUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    xpSpent?: IntFieldUpdateOperationsInput | number
    actualPrice?: IntFieldUpdateOperationsInput | number
    purchaseType?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    satisfactionRating?: NullableIntFieldUpdateOperationsInput | number | null
    guiltLevel?: NullableIntFieldUpdateOperationsInput | number | null
    wasPlanned?: BoolFieldUpdateOperationsInput | boolean
    celebrationLevel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reward?: RewardDefinitionUpdateOneRequiredWithoutPurchasesNestedInput
  }

  export type XPPurchaseUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rewardId?: StringFieldUpdateOperationsInput | string
    xpSpent?: IntFieldUpdateOperationsInput | number
    actualPrice?: IntFieldUpdateOperationsInput | number
    purchaseType?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    satisfactionRating?: NullableIntFieldUpdateOperationsInput | number | null
    guiltLevel?: NullableIntFieldUpdateOperationsInput | number | null
    wasPlanned?: BoolFieldUpdateOperationsInput | boolean
    celebrationLevel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XPPurchaseUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rewardId?: StringFieldUpdateOperationsInput | string
    xpSpent?: IntFieldUpdateOperationsInput | number
    actualPrice?: IntFieldUpdateOperationsInput | number
    purchaseType?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    satisfactionRating?: NullableIntFieldUpdateOperationsInput | number | null
    guiltLevel?: NullableIntFieldUpdateOperationsInput | number | null
    wasPlanned?: BoolFieldUpdateOperationsInput | boolean
    celebrationLevel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XPEarningLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    baseXP?: IntFieldUpdateOperationsInput | number
    finalXP?: IntFieldUpdateOperationsInput | number
    multipliers?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XPEarningLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    baseXP?: IntFieldUpdateOperationsInput | number
    finalXP?: IntFieldUpdateOperationsInput | number
    multipliers?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XPEarningLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    baseXP?: IntFieldUpdateOperationsInput | number
    finalXP?: IntFieldUpdateOperationsInput | number
    multipliers?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LightWorkSubtaskCreateManyTaskInput = {
    id?: string
    title: string
    text: string
    completed?: boolean
    priority?: string | null
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    startedAt?: Date | string | null
    actualDurationMin?: number | null
    timeAccuracy?: number | null
    aiAnalyzed?: boolean
    aiReasoning?: string | null
    analyzedAt?: Date | string | null
    xpReward?: number | null
    complexity?: number | null
    confidence?: number | null
    contextualBonus?: number | null
    difficulty?: number | null
    learningValue?: number | null
    priorityRank?: number | null
    strategicImportance?: number | null
  }

  export type LightWorkSubtaskUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDurationMin?: NullableIntFieldUpdateOperationsInput | number | null
    timeAccuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    aiAnalyzed?: BoolFieldUpdateOperationsInput | boolean
    aiReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    analyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    xpReward?: NullableIntFieldUpdateOperationsInput | number | null
    complexity?: NullableIntFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    contextualBonus?: NullableFloatFieldUpdateOperationsInput | number | null
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    learningValue?: NullableIntFieldUpdateOperationsInput | number | null
    priorityRank?: NullableIntFieldUpdateOperationsInput | number | null
    strategicImportance?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LightWorkSubtaskUncheckedUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDurationMin?: NullableIntFieldUpdateOperationsInput | number | null
    timeAccuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    aiAnalyzed?: BoolFieldUpdateOperationsInput | boolean
    aiReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    analyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    xpReward?: NullableIntFieldUpdateOperationsInput | number | null
    complexity?: NullableIntFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    contextualBonus?: NullableFloatFieldUpdateOperationsInput | number | null
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    learningValue?: NullableIntFieldUpdateOperationsInput | number | null
    priorityRank?: NullableIntFieldUpdateOperationsInput | number | null
    strategicImportance?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LightWorkSubtaskUncheckedUpdateManyWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDurationMin?: NullableIntFieldUpdateOperationsInput | number | null
    timeAccuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    aiAnalyzed?: BoolFieldUpdateOperationsInput | boolean
    aiReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    analyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    xpReward?: NullableIntFieldUpdateOperationsInput | number | null
    complexity?: NullableIntFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    contextualBonus?: NullableFloatFieldUpdateOperationsInput | number | null
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    learningValue?: NullableIntFieldUpdateOperationsInput | number | null
    priorityRank?: NullableIntFieldUpdateOperationsInput | number | null
    strategicImportance?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DeepWorkSubtaskCreateManyTaskInput = {
    id?: string
    title: string
    text: string
    completed?: boolean
    priority?: string | null
    dueDate?: Date | string | null
    requiresFocus?: boolean
    complexityLevel?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    startedAt?: Date | string | null
    actualDurationMin?: number | null
    timeAccuracy?: number | null
    aiAnalyzed?: boolean
    aiReasoning?: string | null
    analyzedAt?: Date | string | null
    xpReward?: number | null
    complexity?: number | null
    confidence?: number | null
    contextualBonus?: number | null
    difficulty?: number | null
    learningValue?: number | null
    priorityRank?: number | null
    strategicImportance?: number | null
  }

  export type DeepWorkSubtaskUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requiresFocus?: BoolFieldUpdateOperationsInput | boolean
    complexityLevel?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDurationMin?: NullableIntFieldUpdateOperationsInput | number | null
    timeAccuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    aiAnalyzed?: BoolFieldUpdateOperationsInput | boolean
    aiReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    analyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    xpReward?: NullableIntFieldUpdateOperationsInput | number | null
    complexity?: NullableIntFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    contextualBonus?: NullableFloatFieldUpdateOperationsInput | number | null
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    learningValue?: NullableIntFieldUpdateOperationsInput | number | null
    priorityRank?: NullableIntFieldUpdateOperationsInput | number | null
    strategicImportance?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DeepWorkSubtaskUncheckedUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requiresFocus?: BoolFieldUpdateOperationsInput | boolean
    complexityLevel?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDurationMin?: NullableIntFieldUpdateOperationsInput | number | null
    timeAccuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    aiAnalyzed?: BoolFieldUpdateOperationsInput | boolean
    aiReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    analyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    xpReward?: NullableIntFieldUpdateOperationsInput | number | null
    complexity?: NullableIntFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    contextualBonus?: NullableFloatFieldUpdateOperationsInput | number | null
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    learningValue?: NullableIntFieldUpdateOperationsInput | number | null
    priorityRank?: NullableIntFieldUpdateOperationsInput | number | null
    strategicImportance?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DeepWorkSubtaskUncheckedUpdateManyWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requiresFocus?: BoolFieldUpdateOperationsInput | boolean
    complexityLevel?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDurationMin?: NullableIntFieldUpdateOperationsInput | number | null
    timeAccuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    aiAnalyzed?: BoolFieldUpdateOperationsInput | boolean
    aiReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    analyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    xpReward?: NullableIntFieldUpdateOperationsInput | number | null
    complexity?: NullableIntFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    contextualBonus?: NullableFloatFieldUpdateOperationsInput | number | null
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    learningValue?: NullableIntFieldUpdateOperationsInput | number | null
    priorityRank?: NullableIntFieldUpdateOperationsInput | number | null
    strategicImportance?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AchievementCreateManyUserProgressInput = {
    id?: string
    name: string
    description: string
    badge: string
    category: $Enums.AchievementCategory
    requirement: number
    unlocked?: boolean
    progress?: number
    maxProgress: number
    unlockedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type DailyStatsCreateManyUserProgressInput = {
    id?: string
    date: string
    totalXP?: number
    activitiesCompleted?: number
    streakCount?: number
    level?: number
    routineXP?: number
    taskXP?: number
    healthXP?: number
    focusXP?: number
    habitXP?: number
    createdAt?: Date | string
  }

  export type AchievementUpdateWithoutUserProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    badge?: StringFieldUpdateOperationsInput | string
    category?: EnumAchievementCategoryFieldUpdateOperationsInput | $Enums.AchievementCategory
    requirement?: IntFieldUpdateOperationsInput | number
    unlocked?: BoolFieldUpdateOperationsInput | boolean
    progress?: IntFieldUpdateOperationsInput | number
    maxProgress?: IntFieldUpdateOperationsInput | number
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementUncheckedUpdateWithoutUserProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    badge?: StringFieldUpdateOperationsInput | string
    category?: EnumAchievementCategoryFieldUpdateOperationsInput | $Enums.AchievementCategory
    requirement?: IntFieldUpdateOperationsInput | number
    unlocked?: BoolFieldUpdateOperationsInput | boolean
    progress?: IntFieldUpdateOperationsInput | number
    maxProgress?: IntFieldUpdateOperationsInput | number
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementUncheckedUpdateManyWithoutUserProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    badge?: StringFieldUpdateOperationsInput | string
    category?: EnumAchievementCategoryFieldUpdateOperationsInput | $Enums.AchievementCategory
    requirement?: IntFieldUpdateOperationsInput | number
    unlocked?: BoolFieldUpdateOperationsInput | boolean
    progress?: IntFieldUpdateOperationsInput | number
    maxProgress?: IntFieldUpdateOperationsInput | number
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyStatsUpdateWithoutUserProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    totalXP?: IntFieldUpdateOperationsInput | number
    activitiesCompleted?: IntFieldUpdateOperationsInput | number
    streakCount?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    routineXP?: IntFieldUpdateOperationsInput | number
    taskXP?: IntFieldUpdateOperationsInput | number
    healthXP?: IntFieldUpdateOperationsInput | number
    focusXP?: IntFieldUpdateOperationsInput | number
    habitXP?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyStatsUncheckedUpdateWithoutUserProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    totalXP?: IntFieldUpdateOperationsInput | number
    activitiesCompleted?: IntFieldUpdateOperationsInput | number
    streakCount?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    routineXP?: IntFieldUpdateOperationsInput | number
    taskXP?: IntFieldUpdateOperationsInput | number
    healthXP?: IntFieldUpdateOperationsInput | number
    focusXP?: IntFieldUpdateOperationsInput | number
    habitXP?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyStatsUncheckedUpdateManyWithoutUserProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    totalXP?: IntFieldUpdateOperationsInput | number
    activitiesCompleted?: IntFieldUpdateOperationsInput | number
    streakCount?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    routineXP?: IntFieldUpdateOperationsInput | number
    taskXP?: IntFieldUpdateOperationsInput | number
    healthXP?: IntFieldUpdateOperationsInput | number
    focusXP?: IntFieldUpdateOperationsInput | number
    habitXP?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XPPurchaseCreateManyRewardInput = {
    id?: string
    userId: string
    xpSpent: number
    actualPrice: number
    purchaseType?: string
    notes?: string | null
    satisfactionRating?: number | null
    guiltLevel?: number | null
    wasPlanned?: boolean
    celebrationLevel?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type XPPurchaseUpdateWithoutRewardInput = {
    id?: StringFieldUpdateOperationsInput | string
    xpSpent?: IntFieldUpdateOperationsInput | number
    actualPrice?: IntFieldUpdateOperationsInput | number
    purchaseType?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    satisfactionRating?: NullableIntFieldUpdateOperationsInput | number | null
    guiltLevel?: NullableIntFieldUpdateOperationsInput | number | null
    wasPlanned?: BoolFieldUpdateOperationsInput | boolean
    celebrationLevel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutXpPurchasesNestedInput
  }

  export type XPPurchaseUncheckedUpdateWithoutRewardInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    xpSpent?: IntFieldUpdateOperationsInput | number
    actualPrice?: IntFieldUpdateOperationsInput | number
    purchaseType?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    satisfactionRating?: NullableIntFieldUpdateOperationsInput | number | null
    guiltLevel?: NullableIntFieldUpdateOperationsInput | number | null
    wasPlanned?: BoolFieldUpdateOperationsInput | boolean
    celebrationLevel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XPPurchaseUncheckedUpdateManyWithoutRewardInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    xpSpent?: IntFieldUpdateOperationsInput | number
    actualPrice?: IntFieldUpdateOperationsInput | number
    purchaseType?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    satisfactionRating?: NullableIntFieldUpdateOperationsInput | number | null
    guiltLevel?: NullableIntFieldUpdateOperationsInput | number | null
    wasPlanned?: BoolFieldUpdateOperationsInput | boolean
    celebrationLevel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}