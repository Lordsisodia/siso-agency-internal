---
name: Create Custom Hooks for Profile Management
status: open
created: 2026-01-18T08:24:04Z
parallel: false
effort: 4 hours
depends_on: [005, 006, 007]
conflicts_with: []
---

# Task: 008 - Create Custom Hooks for Profile Management

## Specification
Create custom React hooks that integrate TanStack Query for caching and state management. These hooks provide a clean interface for components to interact with profile data.

## Acceptance Criteria
- [ ] `useUserProfile` hook for fetching profile data
- [ ] `useProfileUpdate` hook for updating profile
- [ ] `useAvatarUpload` hook for avatar management
- [ ] `usePrivacySettings` hook for privacy settings
- [ ] All hooks use TanStack Query for caching
- [ ] Proper loading and error states
- [ ] Optimistic updates where appropriate
- [ ] Cache invalidation implemented
- [ ] Type-safe implementation

## Files
- `src/domains/user/profile/_shared/hooks/useUserProfile.ts` (new)
- `src/domains/user/profile/_shared/hooks/useProfileUpdate.ts` (new)
- `src/domains/user/profile/_shared/hooks/useAvatarUpload.ts` (new)
- `src/domains/user/profile/_shared/hooks/usePrivacySettings.ts` (new)
- `src/domains/user/profile/_shared/hooks/index.ts` (new)

## Technical Approach

### Step 1: Create useUserProfile Hook
```typescript
// src/domains/user/profile/_shared/hooks/useUserProfile.ts
import { useQuery } from '@tanstack/react-query'
import { profileService } from '../services/profileService'
import type { Profile } from '../types'

/**
 * Hook for fetching user profile
 * @param userId - User ID (defaults to current user)
 */
export function useUserProfile(userId?: string) {
  return useQuery({
    queryKey: ['profile', userId],
    queryFn: () => profileService.getProfile(userId),
    staleTime: 5 * 60 * 1000, // 5 minutes
    gcTime: 10 * 60 * 1000, // 10 minutes
    retry: 1,
    refetchOnWindowFocus: false
  })
}

/**
 * Hook for fetching profile with automatic creation if missing
 * @param userId - User ID
 */
export function useUserProfileOrCreate(userId: string) {
  const query = useQuery({
    queryKey: ['profile', userId],
    queryFn: async () => {
      let profile = await profileService.getProfile(userId)

      // Create profile if it doesn't exist
      if (!profile) {
        profile = await profileService.createProfile(userId)
      }

      return profile
    },
    staleTime: 5 * 60 * 1000,
    retry: 1
  })

  return query
}
```

### Step 2: Create useProfileUpdate Hook
```typescript
// src/domains/user/profile/_shared/hooks/useProfileUpdate.ts
import { useMutation, useQueryClient } from '@tanstack/react-query'
import { profileService } from '../services/profileService'
import type { ProfileUpdate } from '../types'

/**
 * Hook for updating user profile
 */
export function useProfileUpdate() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: ({ userId, updates }: { userId: string; updates: ProfileUpdate }) =>
      profileService.updateProfile(userId, updates),

    onMutate: async ({ userId, updates }) => {
      // Cancel outgoing refetches
      await queryClient.cancelQueries({ queryKey: ['profile', userId] })

      // Snapshot previous value
      const previousProfile = queryClient.getQueryData(['profile', userId])

      // Optimistically update to the new value
      queryClient.setQueryData(['profile', userId], (old: any) => ({
        ...old,
        ...updates,
        updated_at: new Date().toISOString()
      }))

      // Return context with previous value
      return { previousProfile }
    },

    onError: (error, variables, context) => {
      // Rollback to previous value on error
      if (context?.previousProfile) {
        queryClient.setQueryData(
          ['profile', variables.userId],
          context.previousProfile
        )
      }
    },

    onSuccess: (data, variables) => {
      // Refetch to ensure server state
      queryClient.invalidateQueries({ queryKey: ['profile', variables.userId] })
    }
  })
}

/**
 * Hook for scheduling account deletion
 */
export function useScheduleDeletion() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: (userId: string) => profileService.scheduleDeletion(userId),

    onSuccess: (data, userId) => {
      queryClient.invalidateQueries({ queryKey: ['profile', userId] })
    }
  })
}

/**
 * Hook for canceling account deletion
 */
export function useCancelDeletion() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: (userId: string) => profileService.cancelDeletion(userId),

    onSuccess: (data, userId) => {
      queryClient.invalidateQueries({ queryKey: ['profile', userId] })
    }
  })
}
```

### Step 3: Create useAvatarUpload Hook
```typescript
// src/domains/user/profile/_shared/hooks/useAvatarUpload.ts
import { useState, useCallback } from 'react'
import { useMutation, useQueryClient } from '@tanstack/react-query'
import { avatarService } from '../services/avatarService'
import { profileService } from '../services/profileService'

export interface AvatarUploadState {
  uploading: boolean
  progress: number
  preview: string | null
  error: string | null
}

/**
 * Hook for avatar upload and management
 */
export function useAvatarUpload(userId: string) {
  const queryClient = useQueryClient()
  const [state, setState] = useState<AvatarUploadState>({
    uploading: false,
    progress: 0,
    preview: null,
    error: null
  })

  const uploadMutation = useMutation({
    mutationFn: (file: File) =>
      avatarService.uploadAvatar(userId, file, (progress) => {
        setState(prev => ({ ...prev, progress }))
      }),

    onMutate: (file) => {
      // Create preview
      const preview = avatarService.createPreview(file)
      setState(prev => ({
        ...prev,
        uploading: true,
        progress: 0,
        preview,
        error: null
      }))
      return { preview }
    },

    onSuccess: async (result, file, context) => {
      // Update profile with new avatar URL
      await profileService.updateProfile(userId, {
        avatar_url: result.publicUrl
      })

      // Invalidate profile cache
      queryClient.invalidateQueries({ queryKey: ['profile', userId] })

      setState(prev => ({
        ...prev,
        uploading: false,
        progress: 100
      }))
    },

    onError: (error, file, context) => {
      // Clean up preview on error
      if (context?.preview) {
        avatarService.cleanupPreview(context.preview)
      }

      setState(prev => ({
        ...prev,
        uploading: false,
        error: error.message,
        preview: null
      }))
    }
  })

  const deleteMutation = useMutation({
    mutationFn: () => avatarService.deleteAllAvatars(userId),

    onSuccess: async () => {
      // Update profile to remove avatar URL
      await profileService.updateProfile(userId, {
        avatar_url: null
      })

      queryClient.invalidateQueries({ queryKey: ['profile', userId] })
      setState(prev => ({ ...prev, preview: null }))
    }
  })

  const upload = useCallback((file: File) => {
    uploadMutation.mutate(file)
  }, [uploadMutation])

  const remove = useCallback(() => {
    deleteMutation.mutate()
  }, [deleteMutation])

  const clearPreview = useCallback(() => {
    if (state.preview) {
      avatarService.cleanupPreview(state.preview)
      setState(prev => ({ ...prev, preview: null }))
    }
  }, [state.preview])

  return {
    ...state,
    upload,
    remove,
    clearPreview,
    isUploading: uploadMutation.isPending,
    isDeleting: deleteMutation.isPending
  }
}
```

### Step 4: Create usePrivacySettings Hook
```typescript
// src/domains/user/profile/_shared/hooks/usePrivacySettings.ts
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query'
import { privacyService } from '../services/privacyService'
import type { PrivacySettings } from '../types'

/**
 * Hook for fetching privacy settings
 */
export function usePrivacySettings(userId: string) {
  return useQuery({
    queryKey: ['privacy', userId],
    queryFn: () => privacyService.getPrivacySettings(userId),
    staleTime: 10 * 60 * 1000 // 10 minutes
  })
}

/**
 * Hook for updating privacy settings
 */
export function useUpdatePrivacySettings() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: ({ userId, settings }: {
      userId: string
      settings: Partial<PrivacySettings>
    }) => privacyService.updatePrivacySettings(userId, settings),

    onMutate: async ({ userId, settings }) => {
      await queryClient.cancelQueries({ queryKey: ['privacy', userId] })

      const previous = queryClient.getQueryData(['privacy', userId])

      queryClient.setQueryData(['privacy', userId], (old: any) => ({
        ...old,
        ...settings
      }))

      return { previous }
    },

    onError: (error, variables, context) => {
      if (context?.previous) {
        queryClient.setQueryData(
          ['privacy', variables.userId],
          context.previous
        )
      }
    },

    onSuccess: (data, variables) => {
      queryClient.invalidateQueries({ queryKey: ['privacy', variables.userId] })
    }
  })
}

/**
 * Hook for exporting user data
 */
export function useExportUserData() {
  return useMutation({
    mutationFn: (userId: string) => privacyService.downloadDataExport(userId)
  })
}

/**
 * Hook for checking profile visibility
 */
export function useProfileVisibility(userId: string) {
  return useQuery({
    queryKey: ['profile-visibility', userId],
    queryFn: () => privacyService.isProfileVisible(userId),
    staleTime: 5 * 60 * 1000
  })
}
```

### Step 5: Create Index File
```typescript
// src/domains/user/profile/_shared/hooks/index.ts
export * from './useUserProfile'
export * from './useProfileUpdate'
export * from './useAvatarUpload'
export * from './usePrivacySettings'
```

## Dependencies
- Task 005 (Profile service must exist)
- Task 006 (Avatar service must exist)
- Task 007 (Privacy service must exist)

## Conflicts
None

## Testing
```bash
# Test all hooks
npm run test -- hooks

# Test individual hooks
npm run test -- useUserProfile
npm run test -- useProfileUpdate
npm run test -- useAvatarUpload
npm run test -- usePrivacySettings
```

## Verification
- [ ] useUserProfile hook works
- [ ] useProfileUpdate hook works with optimistic updates
- [ ] useAvatarUpload hook works with progress tracking
- [ ] usePrivacySettings hook works
- [ ] Cache invalidation implemented
- [ ] Loading states handled
- [ ] Error states handled
- [ ] TypeScript types correct
- [ ] All hooks exported from index

## TanStack Query Benefits
- Automatic caching
- Background refetching
- Optimistic updates
- Loading/error states
- Deduplication
- Retry logic
- Cache invalidation

## Notes
- Use query keys consistently for cache management
- Implement proper stale time for each query
- Use optimistic updates for better UX
- Clean up previews to avoid memory leaks
- Consider adding request deduplication
