---
name: Create Component Tests
status: open
created: 2026-01-18T08:24:04Z
parallel: true
effort: 6 hours
depends_on: [015]
conflicts_with: []
---

# Task: 017 - Create Component Tests

## Specification
Create comprehensive component tests using React Testing Library. This ensures all UI components work correctly and handle user interactions properly.

## Acceptance Criteria
- [ ] Tests for ProfileDisplay component
- [ ] Tests for ProfileEdit component
- [ ] Tests for AvatarUpload component
- [ ] Tests for PrivacySettings component
- [ ] Tests for AccountManagement component
- [ ] User interactions tested
- [ ] Form validation tested
- [ ] Loading states tested
- [ ] Error states tested
- [ ] Accessibility tested

## Files
- `src/domains/user/profile/1-display/ui/components/__tests__/ProfileDisplay.test.tsx` (new)
- `src/domains/user/profile/2-edit/ui/components/__tests__/ProfileEditForm.test.tsx` (new)
- `src/domains/user/profile/3-avatar/ui/components/__tests__/AvatarUpload.test.tsx` (new)
- `src/domains/user/profile/4-privacy/ui/components/__tests__/PrivacySettings.test.tsx` (new)
- `src/domains/user/profile/5-account/ui/components/__tests__/AccountManagement.test.tsx` (new)

## Technical Approach

### Step 1: Test ProfileDisplay Component
```typescript
// src/domains/user/profile/1-display/ui/components/__tests__/ProfileDisplay.test.tsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen, waitFor } from '@testing-library/react'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { ProfileDisplay } from '../ProfileDisplay'

const mockProfile = {
  id: 'user-123',
  name: 'John Doe',
  bio: 'Software developer',
  avatar_url: 'https://example.com/avatar.jpg',
  location: 'San Francisco',
  timezone: 'PST',
  twitter_url: 'https://twitter.com/johndoe',
  linkedin_url: null,
  youtube_url: null,
  instagram_url: null,
  sisos_tokens: 100,
  created_at: '2024-01-01',
  updated_at: '2024-01-01'
}

const createTestQueryClient = () =>
  new QueryClient({
    defaultOptions: {
      queries: { retry: false },
      mutations: { retry: false }
    }
  })

describe('ProfileDisplay', () => {
  it('should display profile information', async () => {
    const queryClient = createTestQueryClient()
    queryClient.setQueryData(['profile', 'user-123'], mockProfile)

    render(
      <QueryClientProvider client={queryClient}>
        <ProfileDisplay userId="user-123" />
      </QueryClientProvider>
    )

    expect(screen.getByText('John Doe')).toBeInTheDocument()
    expect(screen.getByText('Software developer')).toBeInTheDocument()
    expect(screen.getByText('San Francisco')).toBeInTheDocument()
  })

  it('should show loading skeleton', () => {
    const queryClient = createTestQueryClient()

    render(
      <QueryClientProvider client={queryClient}>
        <ProfileDisplay userId="user-123" />
      </QueryClientProvider>
    )

    expect(screen.getByTestId('profile-skeleton')).toBeInTheDocument()
  })

  it('should show error state on error', async () => {
    const queryClient = createTestQueryClient()
    queryClient.setQueryData(['profile', 'user-123'], new Error('Failed'))

    render(
      <QueryClientProvider client={queryClient}>
        <ProfileDisplay userId="user-123" />
      </QueryClientProvider>
    )

    expect(screen.getByText(/failed to load profile/i)).toBeInTheDocument()
  })

  it('should show empty state when no profile', async () => {
    const queryClient = createTestQueryClient()
    queryClient.setQueryData(['profile', 'user-123'], null)

    render(
      <QueryClientProvider client={queryClient}>
        <ProfileDisplay userId="user-123" />
      </QueryClientProvider>
    )

    expect(screen.getByText(/no profile found/i)).toBeInTheDocument()
  })

  it('should display social links', () => {
    const queryClient = createTestQueryClient()
    queryClient.setQueryData(['profile', 'user-123'], mockProfile)

    render(
      <QueryClientProvider client={queryClient}>
        <ProfileDisplay userId="user-123" />
      </QueryClientProvider>
    )

    const twitterLink = screen.getByRole('link', { name: /twitter/i })
    expect(twitterLink).toHaveAttribute('href', 'https://twitter.com/johndoe')
  })

  it('should call onEdit when edit button clicked', () => {
    const onEdit = vi.fn()
    const queryClient = createTestQueryClient()
    queryClient.setQueryData(['profile', 'user-123'], mockProfile)

    render(
      <QueryClientProvider client={queryClient}>
        <ProfileDisplay userId="user-123" editable onEdit={onEdit} />
      </QueryClientProvider>
    )

    const editButton = screen.getByRole('button', { name: /edit profile/i })
    editButton.click()
    expect(onEdit).toHaveBeenCalled()
  })
})
```

### Step 2: Test ProfileEdit Form
```typescript
// src/domains/user/profile/2-edit/ui/components/__tests__/ProfileEditForm.test.tsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen, waitFor } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import { ProfileEditForm } from '../ProfileEditForm'

const mockProfile = {
  id: 'user-123',
  name: 'John Doe',
  bio: 'Software developer',
  avatar_url: null,
  location: 'San Francisco',
  timezone: 'PST',
  twitter_url: null,
  linkedin_url: null,
  youtube_url: null,
  instagram_url: null,
  sisos_tokens: 100,
  created_at: '2024-01-01',
  updated_at: '2024-01-01'
}

describe('ProfileEditForm', () => {
  it('should render form with current values', () => {
    render(
      <ProfileEditForm
        profile={mockProfile}
        onCancel={vi.fn()}
      />
    )

    expect(screen.getByLabelText(/bio/i)).toHaveValue('Software developer')
    expect(screen.getByLabelText(/location/i)).toHaveValue('San Francisco')
  })

  it('should show character counter for bio', () => {
    render(
      <ProfileEditForm
        profile={mockProfile}
        onCancel={vi.fn()}
      />
    )

    expect(screen.getByText(/18 \/ 500/i)).toBeInTheDocument()
  })

  it('should validate bio length', async () => {
    const user = userEvent.setup()
    render(
      <ProfileEditForm
        profile={mockProfile}
        onCancel={vi.fn()}
      />
    )

    const bioInput = screen.getByLabelText(/bio/i)
    await user.clear(bioInput)
    await user.type(bioInput, 'a'.repeat(501))

    expect(screen.getByText(/bio must be less than 500 characters/i)).toBeInTheDocument()
  })

  it('should validate URLs', async () => {
    const user = userEvent.setup()
    render(
      <ProfileEditForm
        profile={mockProfile}
        onCancel={vi.fn()}
      />
    )

    const twitterInput = screen.getByLabelText(/twitter/i)
    await user.type(twitterInput, 'not-a-url')

    expect(screen.getByText(/invalid url/i)).toBeInTheDocument()
  })

  it('should disable save button when form is invalid', () => {
    render(
      <ProfileEditForm
        profile={mockProfile}
        onCancel={vi.fn()}
      />
    )

    const saveButton = screen.getByRole('button', { name: /save changes/i })
    expect(saveButton).toBeDisabled()
  })

  it('should submit form with valid data', async () => {
    const user = userEvent.setup()
    const onSubmit = vi.fn()

    render(
      <ProfileEditForm
        profile={mockProfile}
        onCancel={vi.fn()}
      />
    )

    const bioInput = screen.getByLabelText(/bio/i)
    await user.clear(bioInput)
    await user.type(bioInput, 'Updated bio')

    const saveButton = screen.getByRole('button', { name: /save changes/i })
    await user.click(saveButton)

    await waitFor(() => {
      expect(onSubmit).toHaveBeenCalled()
    })
  })

  it('should show cancel confirmation when form is dirty', async () => {
    const user = userEvent.setup()
    const onCancel = vi.fn()

    render(
      <ProfileEditForm
        profile={mockProfile}
        onCancel={onCancel}
      />
    )

    const bioInput = screen.getByLabelText(/bio/i)
    await user.type(bioInput, ' more text')

    const cancelButton = screen.getByRole('button', { name: /cancel/i })
    await user.click(cancelButton)

    expect(screen.getByText(/unsaved changes/i)).toBeInTheDocument()
  })
})
```

### Step 3: Test AvatarUpload Component
```typescript
// src/domains/user/profile/3-avatar/ui/components/__tests__/AvatarUpload.test.tsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import { AvatarUpload } from '../AvatarUpload'

describe('AvatarUpload', () => {
  it('should display current avatar', () => {
    render(
      <AvatarUpload
        userId="user-123"
        currentAvatar="https://example.com/avatar.jpg"
      />
    )

    const avatar = screen.getByRole('img', { name: /profile avatar/i })
    expect(avatar).toHaveAttribute('src', 'https://example.com/avatar.jpg')
  })

  it('should show default avatar when none exists', () => {
    render(
      <AvatarUpload
        userId="user-123"
        currentAvatar={null}
      />
    )

    expect(screen.getByRole('img', { name: /profile avatar/i })).toBeInTheDocument()
  })

  it('should show remove button when avatar exists', () => {
    render(
      <AvatarUpload
        userId="user-123"
        currentAvatar="https://example.com/avatar.jpg"
      />
    )

    expect(screen.getByRole('button', { name: /remove/i })).toBeInTheDocument()
  })

  it('should show drag and drop zone', () => {
    render(
      <AvatarUpload
        userId="user-123"
        currentAvatar={null}
      />
    )

    expect(screen.getByText(/drag & drop image here/i)).toBeInTheDocument()
  })

  it('should handle file selection', async () => {
    const user = userEvent.setup()
    const file = new File(['test'], 'test.jpg', { type: 'image/jpeg' })

    render(
      <AvatarUpload
        userId="user-123"
        currentAvatar={null}
      />
    )

    const input = screen.getByRole('presentation').querySelector('input[type="file"]')
    await user.upload(input!, file)

    // Verify upload was triggered
    // (implementation depends on mock)
  })

  it('should show upload progress', async () => {
    // Test progress indicator
  })

  it('should display error message on upload failure', async () => {
    // Test error state
  })
})
```

### Step 4: Test PrivacySettings Component
```typescript
// src/domains/user/profile/4-privacy/ui/components/__tests__/PrivacySettings.test.tsx
import { describe, it, expect } from 'vitest'
import { render, screen } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import { PrivacySettings } from '../PrivacySettings'

const mockSettings = {
  profile_visible: false,
  email_visible: false,
  bio_visible: false,
  location_visible: false,
  social_links_visible: false
}

describe('PrivacySettings', () => {
  it('should render all visibility toggles', () => {
    render(
      <PrivacySettings userId="user-123" />
    )

    expect(screen.getByLabelText(/public profile/i)).toBeInTheDocument()
    expect(screen.getByLabelText(/email address/i)).toBeInTheDocument()
    expect(screen.getByLabelText(/bio/i)).toBeInTheDocument()
    expect(screen.getByLabelText(/location/i)).toBeInTheDocument()
    expect(screen.getByLabelText(/social links/i)).toBeInTheDocument()
  })

  it('should display current settings', () => {
    render(
      <PrivacySettings userId="user-123" />
    )

    const profileToggle = screen.getByLabelText(/public profile/i)
    expect(profileToggle).not.toBeChecked()
  })

  it('should update setting when toggle clicked', async () => {
    const user = userEvent.setup()

    render(
      <PrivacySettings userId="user-123" />
    )

    const profileToggle = screen.getByLabelText(/public profile/i)
    await user.click(profileToggle)

    // Verify update was triggered
  })

  it('should show data export button', () => {
    render(
      <PrivacySettings userId="user-123" />
    )

    expect(screen.getByRole('button', { name: /export my data/i })).toBeInTheDocument()
  })

  it('should trigger data export on button click', async () => {
    const user = userEvent.setup()

    render(
      <PrivacySettings userId="user-123" />
    )

    const exportButton = screen.getByRole('button', { name: /export my data/i })
    await user.click(exportButton)

    // Verify export was triggered
  })
})
```

### Step 5: Test AccountManagement Component
```typescript
// src/domains/user/profile/5-account/ui/components/__tests__/AccountManagement.test.tsx
import { describe, it, expect } from 'vitest'
import { render, screen } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import { AccountManagement } from '../AccountManagement'

describe('AccountManagement', () => {
  it('should show account not scheduled for deletion', () => {
    render(
      <AccountManagement
        userId="user-123"
        deletionScheduled={null}
      />
    )

    expect(screen.getByText(/your account is active/i)).toBeInTheDocument()
  })

  it('should show deletion scheduled message', () => {
    const deletionDate = new Date()
    deletionDate.setHours(deletionDate.getHours() + 24)

    render(
      <AccountManagement
        userId="user-123"
        deletionScheduled={deletionDate.toISOString()}
      />
    )

    expect(screen.getByText(/account deletion scheduled/i)).toBeInTheDocument()
  })

  it('should open delete confirmation dialog', async () => {
    const user = userEvent.setup()

    render(
      <AccountManagement
        userId="user-123"
        deletionScheduled={null}
      />
    )

    const deleteButton = screen.getByRole('button', { name: /delete account/i })
    await user.click(deleteButton)

    expect(screen.getByText(/delete account\?/i)).toBeInTheDocument()
  })

  it('should show first confirmation with warnings', async () => {
    const user = userEvent.setup()

    render(
      <AccountManagement
        userId="user-123"
        deletionScheduled={null}
      />
    )

    const deleteButton = screen.getByRole('button', { name: /delete account/i })
    await user.click(deleteButton)

    expect(screen.getByText(/this action has serious consequences/i)).toBeInTheDocument()
    expect(screen.getByText(/all your profile data will be permanently deleted/i)).toBeInTheDocument()
  })

  it('should require DELETE confirmation on second step', async () => {
    // Test two-step confirmation
  })

  it('should allow canceling deletion', async () => {
    const user = userEvent.setup()

    const deletionDate = new Date()
    deletionDate.setHours(deletionDate.getHours() + 24)

    render(
      <AccountManagement
        userId="user-123"
        deletionScheduled={deletionDate.toISOString()}
      />
    )

    const cancelButton = screen.getByRole('button', { name: /cancel/i })
    await user.click(cancelButton)

    // Verify cancellation was triggered
  })
})
```

## Dependencies
- Task 015 (Security measures must be implemented)

## Conflicts
None

## Testing
```bash
# Run component tests
npm run test -- components

# Run with coverage
npm run test:coverage -- components

# Run specific component tests
npm run test -- ProfileDisplay
npm run test -- ProfileEditForm
npm.run test -- AvatarUpload
```

## Verification
- [ ] All components tested
- [ ] User interactions tested
- [ ] Form validation tested
- [ ] Loading states tested
- [ ] Error states tested
- [ ] Accessibility tested
- [ ] 80%+ coverage
- [ ] All tests passing

## Testing Best Practices
- Test user behavior, not implementation
- Use getByRole for accessibility
- Test error cases
- Test loading states
- Mock external dependencies
- Use waitFor for async operations
- Keep tests simple and focused

## Accessibility Testing
- All interactive elements reachable
- Keyboard navigation works
- ARIA labels present
- Focus management correct
- Screen reader friendly

## Notes
- Use React Testing Library
- Mock Supabase and hooks
- Test form validation thoroughly
- Test error states
- Test loading states
- Use fireEvent/userEvent
