---
name: Create Unit Tests for Services and Hooks
status: open
created: 2026-01-18T08:24:04Z
parallel: true
effort: 6 hours
depends_on: [015]
conflicts_with: []
---

# Task: 016 - Create Unit Tests for Services and Hooks

## Specification
Create comprehensive unit tests for all services, hooks, and utilities. This ensures code quality and catches bugs early.

## Acceptance Criteria
- [ ] Tests for profileService
- [ ] Tests for avatarService
- [ ] Tests for privacyService
- [ ] Tests for all custom hooks
- [ ] Tests for validators
- [ ] Tests for sanitizers
- [ ] Tests for utilities
- [ ] 80%+ code coverage
- [ ] All tests passing

## Files
- `src/domains/user/profile/_shared/services/__tests__/profileService.test.ts` (new)
- `src/domains/user/profile/_shared/services/__tests__/avatarService.test.ts` (new)
- `src/domains/user/profile/_shared/services/__tests__/privacyService.test.ts` (new)
- `src/domains/user/profile/_shared/hooks/__tests__/useUserProfile.test.ts` (new)
- `src/domains/user/profile/_shared/hooks/__tests__/useProfileUpdate.test.ts` (new)
- `src/domains/user/profile/_shared/hooks/__tests__/useAvatarUpload.test.ts` (new)
- `src/domains/user/profile/_shared/utils/__tests__/validators.test.ts` (new)
- `.claude/epics/user-profile/016.md` (new)

## Technical Approach

### Step 1: Test Profile Service
```typescript
// src/domains/user/profile/_shared/services/__tests__/profileService.test.ts
import { describe, it, expect, beforeEach, vi } from 'vitest'
import { profileService } from '../profileService'

// Mock Supabase client
vi.mock('@/lib/supabase/client', () => ({
  supabase: {
    from: vi.fn(() => ({
      select: vi.fn(() => ({
        eq: vi.fn(() => ({
          single: vi.fn()
        }))
      })),
      update: vi.fn(() => ({
        eq: vi.fn(() => ({
          select: vi.fn(() => ({
            single: vi.fn()
          }))
        }))
      })),
      insert: vi.fn(() => ({
        select: vi.fn(() => ({
          single: vi.fn()
        }))
      }))
    })),
    auth: {
      getUser: vi.fn()
    }
  }
}))

describe('profileService', () => {
  const mockProfile = {
    id: 'user-123',
    name: 'John Doe',
    bio: 'Software developer',
    avatar_url: null,
    location: 'SF',
    timezone: 'PST',
    twitter_url: null,
    linkedin_url: null,
    youtube_url: null,
    instagram_url: null,
    sisos_tokens: 100,
    created_at: '2024-01-01',
    updated_at: '2024-01-01'
  }

  describe('getProfile', () => {
    it('should fetch user profile successfully', async () => {
      // Test implementation
      const result = await profileService.getProfile('user-123')
      expect(result).toEqual(mockProfile)
    })

    it('should return null when profile not found', async () => {
      // Test implementation with PGRST116 error
      const result = await profileService.getProfile('nonexistent')
      expect(result).toBeNull()
    })

    it('should handle errors gracefully', async () => {
      // Test error handling
      await expect(profileService.getProfile('invalid')).rejects.toThrow()
    })
  })

  describe('updateProfile', () => {
    it('should update profile successfully', async () => {
      const updates = { bio: 'Updated bio' }
      const result = await profileService.updateProfile('user-123', updates)

      expect(result.bio).toBe('Updated bio')
      expect(result.updated_at).toBeDefined()
    })

    it('should sanitize input before update', async () => {
      const updates = { bio: '<script>alert("xss")</script>' }
      const result = await profileService.updateProfile('user-123', updates)

      expect(result.bio).not.toContain('<script>')
    })
  })

  describe('createProfile', () => {
    it('should create new profile successfully', async () => {
      const result = await profileService.createProfile('user-456', {
        name: 'Jane Doe'
      })

      expect(result.id).toBe('user-456')
      expect(result.name).toBe('Jane Doe')
    })
  })

  describe('scheduleDeletion', () => {
    it('should schedule deletion 24 hours from now', async () => {
      const result = await profileService.scheduleDeletion('user-123')

      expect(result.deletion_scheduled).toBeDefined()
      const deletionDate = new Date(result.deletion_scheduled)
      const now = new Date()
      const diff = deletionDate.getTime() - now.getTime()
      expect(diff).toBeGreaterThan(23 * 60 * 60 * 1000) // ~24 hours
    })
  })
})
```

### Step 2: Test Avatar Service
```typescript
// src/domains/user/profile/_shared/services/__tests__/avatarService.test.ts
import { describe, it, expect, vi } from 'vitest'
import { avatarService } from '../avatarService'

describe('avatarService', () => {
  describe('uploadAvatar', () => {
    it('should upload avatar successfully', async () => {
      const mockFile = new File(['test'], 'test.jpg', {
        type: 'image/jpeg'
      })

      const result = await avatarService.uploadAvatar('user-123', mockFile)

      expect(result.path).toBeDefined()
      expect(result.publicUrl).toBeDefined()
    })

    it('should reject invalid file type', async () => {
      const mockFile = new File(['test'], 'test.pdf', {
        type: 'application/pdf'
      })

      await expect(
        avatarService.uploadAvatar('user-123', mockFile)
      ).rejects.toThrow('Invalid file type')
    })

    it('should reject file too large', async () => {
      const largeFile = new File(
        [new Array(6 * 1024 * 1024).fill('a').join('')],
        'large.jpg',
        { type: 'image/jpeg' }
      )

      await expect(
        avatarService.uploadAvatar('user-123', largeFile)
      ).rejects.toThrow('File too large')
    })

    it('should track upload progress', async () => {
      const mockFile = new File(['test'], 'test.jpg', {
        type: 'image/jpeg'
      })

      const progressCallback = vi.fn()
      await avatarService.uploadAvatar('user-123', mockFile, progressCallback)

      expect(progressCallback).toHaveBeenCalled()
      expect(progressCallback).toHaveBeenLastCalledWith(100)
    })
  })

  describe('deleteAvatar', () => {
    it('should delete avatar successfully', async () => {
      const result = await avatarService.deleteAvatar('user-123', 'avatar.jpg')
      expect(result).toBe(true)
    })
  })

  describe('getAvatarUrl', () => {
    it('should return public URL', () => {
      const url = avatarService.getAvatarUrl('user-123', 'avatar.jpg')
      expect(url).toContain('avatars')
      expect(url).toContain('user-123')
      expect(url).toContain('avatar.jpg')
    })
  })
})
```

### Step 3: Test Custom Hooks
```typescript
// src/domains/user/profile/_shared/hooks/__tests__/useUserProfile.test.ts
import { describe, it, expect, vi } from 'vitest'
import { renderHook, waitFor } from '@testing-library/react'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { useUserProfile } from '../useUserProfile'
import { profileService } from '../../services/profileService'

vi.mock('../../services/profileService')

describe('useUserProfile', () => {
  it('should fetch profile successfully', async () => {
    const mockProfile = {
      id: 'user-123',
      name: 'John Doe',
      // ... other fields
    }

    vi.mocked(profileService.getProfile).mockResolvedValue(mockProfile)

    const queryClient = new QueryClient({
      defaultOptions: {
        queries: { retry: false }
      }
    })

    const wrapper = ({ children }: { children: React.ReactNode }) => (
      <QueryClientProvider client={queryClient}>
        {children}
      </QueryClientProvider>
    )

    const { result } = renderHook(() => useUserProfile('user-123'), { wrapper })

    await waitFor(() => expect(result.current.isSuccess).toBe(true))
    expect(result.current.data).toEqual(mockProfile)
  })

  it('should handle loading state', () => {
    const queryClient = new QueryClient()
    const wrapper = ({ children }: { children: React.ReactNode }) => (
      <QueryClientProvider client={queryClient}>
        {children}
      </QueryClientProvider>
    )

    const { result } = renderHook(() => useUserProfile('user-123'), { wrapper })

    expect(result.current.isLoading).toBe(true)
  })

  it('should handle error state', async () => {
    vi.mocked(profileService.getProfile).mockRejectedValue(
      new Error('Failed to fetch')
    )

    const queryClient = new QueryClient({
      defaultOptions: {
        queries: { retry: false }
      }
    })

    const wrapper = ({ children }: { children: React.ReactNode }) => (
      <QueryClientProvider client={queryClient}>
        {children}
      </QueryClientProvider>
    )

    const { result } = renderHook(() => useUserProfile('user-123'), { wrapper })

    await waitFor(() => expect(result.current.isError).toBe(true))
    expect(result.current.error).toBeDefined()
  })
})
```

### Step 4: Test Validators
```typescript
// src/domains/user/profile/_shared/utils/__tests__/validators.test.ts
import { describe, it, expect } from 'vitest'
import {
  validateProfileUpdate,
  validateSocialLinks,
  validateAvatarFile,
  validatePrivacySettings
} from '../validators'

describe('Validators', () => {
  describe('validateProfileUpdate', () => {
    it('should validate valid profile update', () => {
      const result = validateProfileUpdate({
        bio: 'Software developer',
        location: 'San Francisco'
      })
      expect(result.success).toBe(true)
    })

    it('should reject bio over 500 characters', () => {
      const result = validateProfileUpdate({
        bio: 'a'.repeat(501)
      })
      expect(result.success).toBe(false)
    })

    it('should reject invalid URL', () => {
      const result = validateProfileUpdate({
        twitter_url: 'not-a-url'
      })
      expect(result.success).toBe(false)
    })
  })

  describe('validateSocialLinks', () => {
    it('should validate valid social links', () => {
      const result = validateSocialLinks({
        twitter_url: 'https://twitter.com/user',
        linkedin_url: 'https://linkedin.com/in/user'
      })
      expect(result.success).toBe(true)
    })

    it('should allow null values', () => {
      const result = validateSocialLinks({
        twitter_url: null,
        linkedin_url: null
      })
      expect(result.success).toBe(true)
    })
  })

  describe('validateAvatarFile', () => {
    it('should validate valid image file', () => {
      const file = new File(['test'], 'test.jpg', {
        type: 'image/jpeg'
      })
      const result = validateAvatarFile(file)
      expect(result.success).toBe(true)
    })

    it('should reject invalid file type', () => {
      const file = new File(['test'], 'test.pdf', {
        type: 'application/pdf'
      })
      const result = validateAvatarFile(file)
      expect(result.success).toBe(false)
    })

    it('should reject file too large', () => {
      const largeFile = new File(
        [new Array(6 * 1024 * 1024).fill('a').join('')],
        'large.jpg',
        { type: 'image/jpeg' }
      )
      const result = validateAvatarFile(largeFile)
      expect(result.success).toBe(false)
    })
  })

  describe('validatePrivacySettings', () => {
    it('should validate valid privacy settings', () => {
      const result = validatePrivacySettings({
        profile_visible: true,
        email_visible: false,
        bio_visible: true,
        location_visible: false,
        social_links_visible: true
      })
      expect(result.success).toBe(true)
    })

    it('should require boolean values', () => {
      const result = validatePrivacySettings({
        profile_visible: 'true' as any,
        email_visible: false,
        bio_visible: true,
        location_visible: false,
        social_links_visible: true
      })
      expect(result.success).toBe(false)
    })
  })
})
```

## Dependencies
- Task 015 (Security measures must be implemented)

## Conflicts
None

## Testing
```bash
# Run all unit tests
npm run test

# Run with coverage
npm run test:coverage

# Run specific test suites
npm run test -- profileService
npm run test -- avatarService
npm.run test -- useUserProfile
npm run test -- validators
```

## Verification
- [ ] All services tested
- [ ] All hooks tested
- [ ] All validators tested
- [ ] Error cases covered
- [ ] Edge cases covered
- [ ] 80%+ code coverage
- [ ] All tests passing
- [ ] No console errors

## Testing Strategy
- Unit tests for pure functions
- Integration tests for services
- Hook tests with renderHook
- Mock Supabase calls
- Test error cases
- Test edge cases
- Test race conditions

## Coverage Goals
- Services: 90%+
- Hooks: 85%+
- Utilities: 95%+
- Overall: 80%+

## Notes
- Mock all external dependencies
- Test both success and error cases
- Use describe blocks for organization
- Keep tests focused and simple
- Run tests in CI/CD pipeline
