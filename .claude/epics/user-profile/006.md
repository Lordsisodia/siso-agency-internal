---
name: Implement Avatar Service
status: open
created: 2026-01-18T08:24:04Z
parallel: true
effort: 4 hours
depends_on: [003, 004]
conflicts_with: []
---

# Task: 006 - Implement Avatar Service

## Specification
Create the avatar service that handles image upload, compression, and deletion operations. This service manages the complete avatar lifecycle from upload to storage.

## Acceptance Criteria
- [ ] `avatarService.ts` created with all methods
- [ ] `uploadAvatar()` method handles file upload
- [ ] `deleteAvatar()` method removes avatar
- [ ] `compressImage()` utility compresses images client-side
- [ ] `validateAvatarFile()` validates file type and size
- [ ] Progress tracking for uploads
- [ ] Error handling for all operations
- [ ] Public URL generation works
- [ ] Image compression reduces file size significantly

## Files
- `src/domains/user/profile/_shared/services/avatarService.ts` (new)
- `src/domains/user/profile/_shared/utils/imageCompression.ts` (new)
- `src/domains/user/profile/_shared/services/__tests__/avatarService.test.ts` (new)
- `.claude/epics/user-profile/006.md` (new)

## Technical Approach

### Step 1: Create Image Compression Utility
```typescript
// src/domains/user/profile/_shared/utils/imageCompression.ts
import type { AvatarCompressionOptions } from '../types'

/**
 * Default compression options
 */
const DEFAULT_OPTIONS: AvatarCompressionOptions = {
  maxWidth: 400,
  maxHeight: 400,
  quality: 0.8,
  outputFormat: 'image/jpeg'
}

/**
 * Compress image on client side
 * @param file - Image file to compress
 * @param options - Compression options
 * @returns Compressed image blob
 */
export async function compressImage(
  file: File,
  options: Partial<AvatarCompressionOptions> = {}
): Promise<Blob> {
  const opts = { ...DEFAULT_OPTIONS, ...options }

  return new Promise((resolve, reject) => {
    const img = new Image()

    img.onload = () => {
      // Create canvas
      const canvas = document.createElement('canvas')
      const ctx = canvas.getContext('2d')

      if (!ctx) {
        reject(new Error('Could not get canvas context'))
        return
      }

      // Calculate dimensions (maintain aspect ratio)
      let width = img.width
      let height = img.height

      if (width > height) {
        if (width > opts.maxWidth) {
          height = (height * opts.maxWidth) / width
          width = opts.maxWidth
        }
      } else {
        if (height > opts.maxHeight) {
          width = (width * opts.maxHeight) / height
          height = opts.maxHeight
        }
      }

      canvas.width = width
      canvas.height = height

      // Draw image on canvas
      ctx.drawImage(img, 0, 0, width, height)

      // Compress and get blob
      canvas.toBlob(
        (blob) => {
          if (blob) {
            resolve(blob)
          } else {
            reject(new Error('Could not compress image'))
          }
        },
        opts.outputFormat,
        opts.quality
      )
    }

    img.onerror = () => {
      reject(new Error('Could not load image'))
    }

    // Load image from file
    const reader = new FileReader()
    reader.onload = (e) => {
      img.src = e.target?.result as string
    }
    reader.onerror = () => {
      reject(new Error('Could not read file'))
    }
    reader.readAsDataURL(file)
  })
}

/**
 * Get image dimensions
 * @param file - Image file
 * @returns Width and height
 */
export async function getImageDimensions(
  file: File
): Promise<{ width: number; height: number }> {
  return new Promise((resolve, reject) => {
    const img = new Image()

    img.onload = () => {
      resolve({ width: img.width, height: img.height })
    }

    img.onerror = () => {
      reject(new Error('Could not load image'))
    }

    const reader = new FileReader()
    reader.onload = (e) => {
      img.src = e.target?.result as string
    }
    reader.onerror = () => {
      reject(new Error('Could not read file'))
    }
    reader.readAsDataURL(file)
  })
}

/**
 * Create image preview URL
 * @param file - Image file
 * @returns Object URL for preview
 */
export function createPreviewUrl(file: File): string {
  return URL.createObjectURL(file)
}

/**
 * Revoke preview URL to free memory
 * @param url - Preview URL to revoke
 */
export function revokePreviewUrl(url: string): void {
  URL.revokeObjectURL(url)
}
```

### Step 2: Create Avatar Service
```typescript
// src/domains/user/profile/_shared/services/avatarService.ts
import { supabase } from '@/lib/supabase/client'
import type { AvatarUploadResult } from '../types'
import { compressImage, createPreviewUrl, revokePreviewUrl } from '../utils/imageCompression'

/**
 * Avatar Service
 * Handles avatar upload, deletion, and management
 */
export const avatarService = {
  /**
   * Upload avatar for user
   * @param userId - User ID
   * @param file - Image file to upload
   * @param onProgress - Progress callback
   * @returns Upload result with public URL
   */
  async uploadAvatar(
    userId: string,
    file: File,
    onProgress?: (progress: number) => void
  ): Promise<AvatarUploadResult> {
    try {
      // Validate file type
      const validTypes = ['image/jpeg', 'image/png', 'image/webp']
      if (!validTypes.includes(file.type)) {
        throw new Error('Invalid file type. Please upload JPG, PNG, or WebP.')
      }

      // Validate file size (5MB max)
      const maxSize = 5 * 1024 * 1024
      if (file.size > maxSize) {
        throw new Error('File too large. Maximum size is 5MB.')
      }

      // Compress image
      onProgress?.(10)
      const compressed = await compressImage(file, {
        maxWidth: 400,
        maxHeight: 400,
        quality: 0.8,
        outputFormat: 'image/jpeg'
      })

      // Generate unique filename
      const timestamp = Date.now()
      const filename = `${userId}/${timestamp}.jpg`

      onProgress?.(30)

      // Upload to Supabase Storage
      const { data, error } = await supabase
        .storage
        .from('avatars')
        .upload(filename, compressed, {
          contentType: 'image/jpeg',
          upsert: true
        })

      if (error) {
        throw error
      }

      onProgress?.(80)

      // Get public URL
      const { data: urlData } = supabase
        .storage
        .from('avatars')
        .getPublicUrl(filename)

      onProgress?.(100)

      return {
        path: data.path,
        publicUrl: urlData.publicUrl
      }
    } catch (error) {
      console.error('Error uploading avatar:', error)
      throw new Error('Failed to upload avatar. Please try again.')
    }
  },

  /**
   * Delete user avatar
   * @param userId - User ID
   * @param filename - Filename to delete
   * @returns Success status
   */
  async deleteAvatar(
    userId: string,
    filename: string
  ): Promise<boolean> {
    try {
      const { error } = await supabase
        .storage
        .from('avatars')
        .remove([`${userId}/${filename}`])

      if (error) throw error

      return true
    } catch (error) {
      console.error('Error deleting avatar:', error)
      throw new Error('Failed to delete avatar. Please try again.')
    }
  },

  /**
   * Delete all user avatars
   * @param userId - User ID
   * @returns Success status
   */
  async deleteAllAvatars(userId: string): Promise<boolean> {
    try {
      // List all user's avatars
      const { data, error: listError } = await supabase
        .storage
        .from('avatars')
        .list(userId)

      if (listError) throw listError

      // Delete all files
      if (data && data.length > 0) {
        const filesToDelete = data.map(file => `${userId}/${file.name}`)
        const { error: deleteError } = await supabase
          .storage
          .from('avatars')
          .remove(filesToDelete)

        if (deleteError) throw deleteError
      }

      return true
    } catch (error) {
      console.error('Error deleting avatars:', error)
      throw new Error('Failed to delete avatars. Please try again.')
    }
  },

  /**
   * Get avatar public URL
   * @param userId - User ID
   * @param filename - Filename
   * @returns Public URL
   */
  getAvatarUrl(userId: string, filename: string): string {
    const { data } = supabase
      .storage
      .from('avatars')
      .getPublicUrl(`${userId}/${filename}`)

    return data.publicUrl
  },

  /**
   * Create preview URL for file
   * @param file - Image file
   * @returns Preview URL
   */
  createPreview(file: File): string {
    return createPreviewUrl(file)
  },

  /**
   * Clean up preview URL
   * @param url - Preview URL to revoke
   */
  cleanupPreview(url: string): void {
    revokePreviewUrl(url)
  }
}
```

### Step 3: Create Service Tests
```typescript
// src/domains/user/profile/_shared/services/__tests__/avatarService.test.ts
import { describe, it, expect, vi } from 'vitest'
import { avatarService } from '../avatarService'
import { compressImage } from '../../utils/imageCompression'

describe('avatarService', () => {
  describe('uploadAvatar', () => {
    it('should upload avatar successfully', async () => {
      const mockFile = new File(['test'], 'test.jpg', { type: 'image/jpeg' })

      // Mock implementation
      const result = await avatarService.uploadAvatar('user-123', mockFile)

      expect(result.path).toBeDefined()
      expect(result.publicUrl).toBeDefined()
    })

    it('should reject invalid file type', async () => {
      const mockFile = new File(['test'], 'test.pdf', { type: 'application/pdf' })

      await expect(
        avatarService.uploadAvatar('user-123', mockFile)
      ).rejects.toThrow('Invalid file type')
    })

    it('should reject file too large', async () => {
      const largeFile = new File(
        [new Array(6 * 1024 * 1024).fill('a').join('')],
        'large.jpg',
        { type: 'image/jpeg' }
      )

      await expect(
        avatarService.uploadAvatar('user-123', largeFile)
      ).rejects.toThrow('File too large')
    })
  })

  describe('deleteAvatar', () => {
    it('should delete avatar successfully', async () => {
      const result = await avatarService.deleteAvatar('user-123', 'avatar.jpg')
      expect(result).toBe(true)
    })
  })
})

describe('compressImage', () => {
  it('should compress image', async () => {
    const mockFile = new File(['test'], 'test.jpg', { type: 'image/jpeg' })

    const compressed = await compressImage(mockFile)
    expect(compressed).toBeInstanceOf(Blob)
    expect(compressed.size).toBeLessThan(mockFile.size)
  })
})
```

## Dependencies
- Task 003 (Supabase Storage must be configured)
- Task 004 (TypeScript types must be defined)

## Conflicts
None

## Testing
```bash
# Run unit tests
npm run test -- avatarService

# Test compression utility
npm run test -- imageCompression

# Manual upload test
npm run test-avatar-upload
```

## Verification
- [ ] Avatar service created with all methods
- [ ] uploadAvatar() works with progress tracking
- [ ] deleteAvatar() works correctly
- [ ] deleteAllAvatars() removes all user avatars
- [ ] getAvatarUrl() returns public URL
- [ ] compressImage() reduces file size
- [ ] File validation works (type, size)
- [ ] Preview creation/cleanup works
- [ ] Error handling implemented
- [ ] Tests pass

## Performance Notes
- Compression happens on client side (faster upload)
- Target compressed size: < 100KB
- Dimensions: 400x400 max (good for avatars)
- Quality: 0.8 (good balance)

## Security Considerations
- File type validation (MIME + magic bytes)
- File size limits prevent DOS
- RLS on storage bucket prevents unauthorized access
- Public URLs are signed and expire
- Consider adding virus scanning for production

## Notes
- Use upsert: true to overwrite existing avatars
- Clean up old avatars to save storage
- Consider implementing CDN caching
- Preview URLs should be revoked to free memory
- Test with different image formats and sizes
