---
name: Configure RLS Policies
status: open
created: 2026-01-18T08:24:04Z
parallel: false
effort: 3 hours
depends_on: [001]
conflicts_with: []
---

# Task: 002 - Configure RLS Policies

## Specification
Enable and configure Row Level Security (RLS) on the `profiles` table to ensure users can only access and modify their own profile data. This is a critical security requirement.

## Acceptance Criteria
- [ ] RLS is enabled on `profiles` table
- [ ] Policy allows users to view their own profile (SELECT)
- [ ] Policy allows users to insert their own profile (INSERT)
- [ ] Policy allows users to update their own profile (UPDATE)
- [ ] Policy allows users to delete their own profile (DELETE)
- [ ] Policies tested with different user contexts
- [ ] Policy bypass confirmed (admin can still access all)
- [ ] Security audit script passes

## Files
- `supabase/migrations/20260118000002_configure_rls_policies.sql` (new)
- `scripts/test-rls-policies.ts` (new)
- `.claude/epics/user-profile/002.md` (new)

## Technical Approach

### Step 1: Enable RLS
```sql
-- Enable Row Level Security
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;

-- Verify RLS is enabled
SELECT tablename, rowsecurity
FROM pg_tables
WHERE schemaname = 'public'
  AND tablename = 'profiles';
```

### Step 2: Create SELECT Policy
```sql
-- Drop existing policy if it exists
DROP POLICY IF EXISTS "Users can view own profile" ON profiles;

-- Create SELECT policy
CREATE POLICY "Users can view own profile"
ON profiles FOR SELECT
USING (auth.uid()::text = id);

-- Add comment for documentation
COMMENT ON POLICY "Users can view own profile" ON profiles IS
'Allows authenticated users to view their own profile data';
```

### Step 3: Create INSERT Policy
```sql
-- Drop existing policy if it exists
DROP POLICY IF EXISTS "Users can insert own profile" ON profiles;

-- Create INSERT policy
CREATE POLICY "Users can insert own profile"
ON profiles FOR INSERT
WITH CHECK (auth.uid()::text = id);

-- Add comment
COMMENT ON POLICY "Users can insert own profile" ON profiles IS
'Allows authenticated users to create their own profile on signup';
```

### Step 4: Create UPDATE Policy
```sql
-- Drop existing policy if it exists
DROP POLICY IF EXISTS "Users can update own profile" ON profiles;

-- Create UPDATE policy
CREATE POLICY "Users can update own profile"
ON profiles FOR UPDATE
USING (auth.uid()::text = id)
WITH CHECK (auth.uid()::text = id);

-- Add comment
COMMENT ON POLICY "Users can update own profile" ON profiles IS
'Allows authenticated users to update their own profile data';
```

### Step 5: Create DELETE Policy
```sql
-- Drop existing policy if it exists
DROP POLICY IF EXISTS "Users can delete own profile" ON profiles;

-- Create DELETE policy
CREATE POLICY "Users can delete own profile"
ON profiles FOR DELETE
USING (auth.uid()::text = id);

-- Add comment
COMMENT ON POLICY "Users can delete own profile" ON profiles IS
'Allows authenticated users to delete their own profile (for account deletion)';
```

### Step 6: Create Security Test Script
```typescript
import { createClient } from '@supabase/supabase-js'

async function testRLSPolicies() {
  const supabase = createClient(
    process.env.VITE_SUPABASE_URL!,
    process.env.VITE_SUPABASE_ANON_KEY!
  )

  // Test 1: User should be able to view own profile
  const { data: ownProfile, error: ownError } = await supabase
    .from('profiles')
    .select('*')
    .limit(1)

  console.log('Test 1 - View own profile:', ownError ? 'FAILED' : 'PASSED')

  // Test 2: User should NOT be able to view other profiles
  const { data: allProfiles, error: allError } = await supabase
    .from('profiles')
    .select('*')

  if (allProfiles && allProfiles.length > 1) {
    console.log('Test 2 - Cannot view others: FAILED (security breach!)')
  } else {
    console.log('Test 2 - Cannot view others: PASSED')
  }

  // Test 3: User should be able to update own profile
  const { error: updateError } = await supabase
    .from('profiles')
    .update({ updated_at: new Date().toISOString() })
    .limit(1)

  console.log('Test 3 - Update own profile:', updateError ? 'FAILED' : 'PASSED')

  // Test 4: User should NOT be able to delete other profiles
  const { error: deleteError } = await supabase
    .from('profiles')
    .delete()
    .neq('id', 'fake-id')

  console.log('Test 4 - Cannot delete others:', deleteError ? 'PASSED' : 'FAILED')
}

testRLSPolicies()
```

### Step 7: Run Tests
```bash
# Run RLS policy tests
npm run test-rls-policies
```

## Dependencies
- Task 001 (Database schema must exist first)

## Conflicts
None

## Testing
```bash
# Test 1: Verify RLS is enabled
psql $DATABASE_URL -c "
SELECT tablename, rowsecurity
FROM pg_tables
WHERE tablename = 'profiles';
"

# Test 2: List all policies on profiles table
psql $DATABASE_URL -c "
SELECT schemaname, tablename, policyname, permissive, roles, cmd, qual
FROM pg_policies
WHERE tablename = 'profiles';
"

# Test 3: Run automated test suite
npm run test-rls-policies

# Test 4: Manual test - try to access another user's profile
psql $DATABASE_URL -c "
SET ROLE authenticated;
SET request.jwt.claim.sub = 'user-1-id';
SELECT * FROM profiles WHERE id = 'user-2-id';
"
```

## Verification
- [ ] RLS is enabled on profiles table
- [ ] SELECT policy created and working
- [ ] INSERT policy created and working
- [ ] UPDATE policy created and working
- [ ] DELETE policy created and working
- [ ] Users can only access their own data
- [ ] Test suite passes all checks
- [ ] Migration file committed
- [ ] Policies documented with comments

## Security Considerations
- RLS is the primary security mechanism - never disable it
- Always test policies with different user contexts
- Consider adding service role policies for admin operations
- Monitor policy performance in production
- Document any exceptions to the RLS rules

## Notes
- This is a critical security task - test thoroughly
- Use `service_role` key for admin operations that need to bypass RLS
- Consider adding audit logging for profile changes
- Policies can be refined later for specific use cases
