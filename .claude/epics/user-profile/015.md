---
name: Implement Security Measures
status: open
created: 2026-01-18T08:24:04Z
parallel: false
effort: 4 hours
depends_on: [014]
conflicts_with: []
---

# Task: 015 - Implement Security Measures

## Specification
Implement comprehensive security measures including XSS prevention, CSRF protection, rate limiting, and input sanitization. This task ensures the profile feature is secure from common attacks.

## Acceptance Criteria
- [ ] XSS prevention implemented
- [ ] CSRF protection via Clerk tokens
- [ ] Rate limiting on profile updates (10/minute)
- [ ] Rate limiting on avatar uploads (5/hour)
- [ ] Input sanitization on all user inputs
- [ ] Content Security Policy headers
- [ ] File validation (MIME + magic bytes)
- [ ] RLS policies tested and verified
- [ ] Security audit passes

## Files
- `src/domains/user/profile/_shared/utils/security.ts` (new)
- `src/domains/user/profile/_shared/middleware/rateLimit.ts` (new)
- `src/domains/user/profile/_shared/utils/sanitizers.ts` (new)
- `.claude/epics/user-profile/015.md` (new)

## Technical Approach

### Step 1: Create Input Sanitization Utilities
```typescript
// src/domains/user/profile/_shared/utils/sanitizers.ts
import DOMPurify from 'dompurify'

/**
 * Sanitize user input to prevent XSS attacks
 */
export function sanitizeInput(input: string): string {
  return DOMPurify.sanitize(input, {
    ALLOWED_TAGS: [],
    ALLOWED_ATTR: []
  })
}

/**
 * Sanitize URL to prevent javascript: and data: attacks
 */
export function sanitizeUrl(url: string): string {
  // Remove whitespace
  let cleanUrl = url.trim()

  // Block dangerous protocols
  const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:']
  const lowerUrl = cleanUrl.toLowerCase()

  for (const protocol of dangerousProtocols) {
    if (lowerUrl.startsWith(protocol)) {
      throw new Error(`Dangerous protocol detected: ${protocol}`)
    }
  }

  // Ensure URL starts with http:// or https://
  if (!cleanUrl.startsWith('http://') && !cleanUrl.startsWith('https://')) {
    cleanUrl = `https://${cleanUrl}`
  }

  return cleanUrl
}

/**
 * Sanitize bio text (allow line breaks but no HTML)
 */
export function sanitizeBio(bio: string): string {
  return sanitizeInput(bio).replace(/\n/g, ' ')
}

/**
 * Sanitize location input
 */
export function sanitizeLocation(location: string): string {
  return sanitizeInput(location).trim()
}

/**
 * Validate and sanitize social media URLs
 */
export function sanitizeSocialUrl(url: string): string {
  if (!url) return ''

  const cleanUrl = sanitizeUrl(url)

  // Validate domain for known platforms
  const urlObj = new URL(cleanUrl)
  const allowedDomains = [
    'twitter.com',
    'x.com',
    'linkedin.com',
    'youtube.com',
    'instagram.com'
  ]

  const domain = urlObj.hostname.replace('www.', '')
  if (!allowedDomains.some(d => domain.endsWith(d))) {
    throw new Error(`Invalid social media domain: ${domain}`)
  }

  return cleanUrl
}
```

### Step 2: Create Rate Limiting Middleware
```typescript
// src/domains/user/profile/_shared/middleware/rateLimit.ts
interface RateLimitConfig {
  maxRequests: number
  windowMs: number
}

interface RateLimitEntry {
  count: number
  resetTime: number
}

const rateLimitStore = new Map<string, RateLimitEntry>()

/**
 * Rate limiter for profile operations
 */
export class RateLimiter {
  private config: RateLimitConfig

  constructor(config: RateLimitConfig) {
    this.config = config
  }

  /**
   * Check if request is allowed
   */
  async checkLimit(identifier: string): Promise<boolean> {
    const now = Date.now()
    const entry = rateLimitStore.get(identifier)

    // Clean up expired entries
    if (entry && entry.resetTime < now) {
      rateLimitStore.delete(identifier)
      return true
    }

    // Create new entry if doesn't exist
    if (!entry) {
      rateLimitStore.set(identifier, {
        count: 1,
        resetTime: now + this.config.windowMs
      })
      return true
    }

    // Check if limit exceeded
    if (entry.count >= this.config.maxRequests) {
      return false
    }

    // Increment count
    entry.count++
    return true
  }

  /**
   * Get remaining requests
   */
  getRemaining(identifier: string): number {
    const entry = rateLimitStore.get(identifier)
    if (!entry) return this.config.maxRequests

    return Math.max(0, this.config.maxRequests - entry.count)
  }

  /**
   * Get reset time
   */
  getResetTime(identifier: string): number | null {
    const entry = rateLimitStore.get(identifier)
    return entry?.resetTime || null
  }

  /**
   * Reset rate limit for identifier
   */
  reset(identifier: string): void {
    rateLimitStore.delete(identifier)
  }
}

// Pre-configured rate limiters
export const profileUpdateLimiter = new RateLimiter({
  maxRequests: 10,
  windowMs: 60 * 1000 // 1 minute
})

export const avatarUploadLimiter = new RateLimiter({
  maxRequests: 5,
  windowMs: 60 * 60 * 1000 // 1 hour
})

export const dataExportLimiter = new RateLimiter({
  maxRequests: 3,
  windowMs: 60 * 60 * 1000 // 1 hour
})
```

### Step 3: Create Security Utilities
```typescript
// src/domains/user/profile/_shared/utils/security.ts
import { supabase } from '@/lib/supabase/client'
import { profileUpdateLimiter, avatarUploadLimiter } from '../middleware/rateLimit'

/**
 * Get user-specific rate limit identifier
 */
export function getRateLimitId(): string {
  const { data } = supabase.auth.getUser()
  return `profile:${data.user?.id || 'anonymous'}`
}

/**
 * Check profile update rate limit
 */
export async function checkProfileUpdateRateLimit(): Promise<boolean> {
  const id = getRateLimitId()
  return profileUpdateLimiter.checkLimit(id)
}

/**
 * Check avatar upload rate limit
 */
export async function checkAvatarUploadRateLimit(): Promise<boolean> {
  const id = getRateLimitId()
  return avatarUploadLimiter.checkLimit(id)
}

/**
 * Verify CSRF token (via Clerk JWT)
 */
export async function verifyCSRFToken(): Promise<boolean> {
  try {
    const { data, error } = await supabase.auth.getSession()
    if (error || !data.session) {
      return false
    }
    return true
  } catch {
    return false
  }
}

/**
 * Security headers for profile pages
 */
export const securityHeaders = {
  'Content-Security-Policy': "default-src 'self'; img-src 'self' data: https:;",
  'X-Content-Type-Options': 'nosniff',
  'X-Frame-Options': 'DENY',
  'X-XSS-Protection': '1; mode=block',
  'Referrer-Policy': 'strict-origin-when-cross-origin'
}

/**
 * Validate file type (MIME + magic bytes)
 */
export function validateFileType(file: File): boolean {
  const validTypes = ['image/jpeg', 'image/png', 'image/webp']

  if (!validTypes.includes(file.type)) {
    return false
  }

  // Check magic bytes
  return new Promise((resolve) => {
    const reader = new FileReader()
    reader.onload = (e) => {
      const arr = new Uint8Array(e.target?.result as ArrayBuffer)
      const header = Array.from(arr.slice(0, 4)).map(b => b.toString(16).padStart(2, '0')).join('')

      // JPEG: ff d8 ff
      // PNG: 89 50 4e 47
      // WebP: 52 49 46 46
      const validMagicBytes = [
        'ffd8ff', // JPEG
        '89504e47', // PNG
        '52494646' // WebP
      ]

      resolve(validMagicBytes.some(magic => header.startsWith(magic)))
    }
    reader.onerror = () => resolve(false)
    reader.readAsArrayHeader(file.slice(0, 4))
  })
}
```

### Step 4: Update Services with Security
```typescript
// Update profileService.ts to include rate limiting
import { checkProfileUpdateRateLimit, sanitizeInput, sanitizeSocialUrl } from '../utils/security'

export const profileService = {
  async updateProfile(userId: string, updates: ProfileUpdate): Promise<Profile> {
    // Check rate limit
    const allowed = await checkProfileUpdateRateLimit()
    if (!allowed) {
      throw new Error('Too many updates. Please try again later.')
    }

    // Sanitize inputs
    const sanitized = {
      ...updates,
      bio: updates.bio ? sanitizeInput(updates.bio) : null,
      location: updates.location ? sanitizeInput(updates.location) : null,
      twitter_url: updates.twitter_url ? sanitizeSocialUrl(updates.twitter_url) : null,
      linkedin_url: updates.linkedin_url ? sanitizeSocialUrl(updates.linkedin_url) : null,
      youtube_url: updates.youtube_url ? sanitizeSocialUrl(updates.youtube_url) : null,
      instagram_url: updates.instagram_url ? sanitizeSocialUrl(updates.instagram_url) : null
    }

    // Continue with update...
    const { data, error } = await supabase
      .from('profiles')
      .update(sanitized)
      .eq('id', userId)
      .select()
      .single()

    if (error) throw error
    return data
  }
}
```

### Step 5: Create Security Audit Script
```typescript
// scripts/audit-security.ts
import { supabase } from '@/lib/supabase/client'

async function auditSecurity() {
  console.log('Running security audit...\n')

  const checks = []

  // Check 1: RLS enabled
  const { data: rlsStatus } = await supabase
    .rpc('check_rls_enabled', { table_name: 'profiles' })
  checks.push({ name: 'RLS Enabled', passed: rlsStatus })

  // Check 2: RLS policies exist
  const { data: policies } = await supabase
    .from('pg_policies')
    .select('*')
    .eq('tablename', 'profiles')
  checks.push({ name: 'RLS Policies Exist', passed: policies?.length > 0 })

  // Check 3: Storage bucket policies
  const { data: bucketPolicies } = await supabase
    .from('pg_policies')
    .select('*')
    .like('policyname', '%avatar%')
  checks.push({ name: 'Storage Policies Exist', passed: bucketPolicies?.length > 0 })

  // Print results
  checks.forEach(check => {
    console.log(`${check.passed ? '✓' : '✗'} ${check.name}`)
  })

  const allPassed = checks.every(c => c.passed)
  console.log(`\n${allPassed ? '✓ All checks passed' : '✗ Some checks failed'}`)
}

auditSecurity()
```

## Dependencies
- Task 014 (Routes must be configured)

## Conflicts
None

## Testing
```bash
# Run security audit
npm run audit-security

# Test XSS prevention
npm run test -- xss-prevention

# Test rate limiting
npm run test -- rate-limit

# Test file validation
npm run test -- file-validation
```

## Verification
- [ ] Input sanitization works
- [ ] XSS prevention tested
- [ ] CSRF protection verified
- [ ] Rate limiting enforced
- [ ] File validation works
- [ ] RLS policies tested
- [ ] Security audit passes
- [ ] No vulnerabilities found

## Security Checklist
- [ ] Input sanitization on all fields
- [ ] XSS prevention via DOMPurify
- [ ] CSRF protection via Clerk JWT
- [ ] Rate limiting on all mutations
- [ ] File validation (MIME + magic bytes)
- [ ] RLS policies enabled and tested
- [ ] Content Security Policy headers
- [ ] No sensitive data in client code
- [ ] Error messages don't leak info
- [ ] Audit logging implemented

## Notes
- Security is critical - test thoroughly
- Use helmet middleware for headers
- Monitor rate limit hits
- Log security events
- Regular security audits
- Keep dependencies updated
- Follow OWASP guidelines
